import { __awaiter, __generator, __read, __spreadArray } from "tslib";
import test from 'ava';
import sinon from 'sinon';
import { createSampleController } from '../pc-perf/sampleController';
import { createQueue } from '../pc-perf/utils';
import { getMockData } from './utils/getMockData';
test('queue', function (t) {
    var capacity = 4;
    var queue = createQueue(capacity);
    t.is(queue.getCapacity(), capacity);
    t.is(queue.getSize(), 0);
    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);
    queue.enqueue(4);
    t.is(queue.getSize(), capacity);
    queue.enqueue(5);
    t.is(queue.getSize(), capacity);
    var item = queue.dequeue();
    t.is(item, 2);
    t.is(queue.getSize(), capacity - 1);
    var newCapacity = 2;
    queue.setCapacity(newCapacity);
    t.is(queue.getSize(), 2);
    t.is(queue.dequeue(), 4);
    queue.clear();
    t.is(queue.getCapacity(), newCapacity);
    t.is(queue.getSize(), 0);
});
test('should throw error while the name is repeated', function (t) {
    var sampleConfigList = getMockData().sampleConfigList;
    var data = __spreadArray(__spreadArray([], __read(sampleConfigList), false), [sampleConfigList[0]], false);
    t.throws(function () { return createSampleController(data); }, null, "name asyncSample is exist");
});
test('should throw error while the name does not exist', function (t) {
    var sampleConfigList = getMockData().sampleConfigList;
    var _a = createSampleController(sampleConfigList), startAction = _a.startAction, stopAction = _a.stopAction, pauseAction = _a.pauseAction;
    t.throws(function () { return startAction('foo'); }, null, 'Sample foo does not exist');
    t.throws(function () { return stopAction('foo'); }, null, 'Sample foo does not exist');
    t.throws(function () { return pauseAction('foo'); }, null, 'Sample foo does not exist');
});
test('should init state is stop', function (t) {
    var _a = getMockData(), sampleConfigList = _a.sampleConfigList, transSucCbs = _a.transSucCbs;
    var getState = createSampleController(sampleConfigList).getState;
    // init state
    t.is(getState('asyncSample'), 'stop');
    t.false(transSucCbs['asyncSample'].called);
});
test('should [stop state] --<startAction>--> [running state]', function (t) {
    var _a = getMockData(), sampleConfigList = _a.sampleConfigList, transSucCbs = _a.transSucCbs;
    var _b = createSampleController(sampleConfigList), startAction = _b.startAction, getState = _b.getState;
    // [stop state] --<startAction>--> [running state]
    t.true(startAction('asyncSample'));
    t.deepEqual(transSucCbs['asyncSample'].getCall(0).args, ['stop', 'running']);
    t.is(getState('asyncSample'), 'running');
});
test('should [stop state] --<stopAction>--> fail', function (t) {
    var _a = getMockData(), sampleConfigList = _a.sampleConfigList, transSucCbs = _a.transSucCbs;
    var stopAction = createSampleController(sampleConfigList).stopAction;
    // [stop state] --<stopAction>--> fail
    t.false(stopAction('asyncSample'));
    t.false(transSucCbs['asyncSample'].called);
});
test('should [stop state] --<pauseAction>--> fail', function (t) {
    var _a = getMockData(), sampleConfigList = _a.sampleConfigList, transSucCbs = _a.transSucCbs;
    var pauseAction = createSampleController(sampleConfigList).pauseAction;
    // [stop state] --<stopAction>--> fail
    t.false(pauseAction('asyncSample'));
    t.false(transSucCbs['asyncSample'].called);
});
test('should [running state] --<startAction>--> fail', function (t) {
    var _a = getMockData(), sampleConfigList = _a.sampleConfigList, transSucCbs = _a.transSucCbs;
    var startAction = createSampleController(sampleConfigList).startAction;
    startAction('asyncSample');
    transSucCbs['asyncSample'].reset();
    // [running state] --<startAction>--> fail
    t.false(startAction('asyncSample'));
    t.false(transSucCbs['asyncSample'].called);
});
test('should [running state] --<stopAction>--> [stop state]', function (t) {
    var _a = getMockData(), sampleConfigList = _a.sampleConfigList, transSucCbs = _a.transSucCbs;
    var _b = createSampleController(sampleConfigList), startAction = _b.startAction, stopAction = _b.stopAction, getState = _b.getState;
    startAction('asyncSample');
    transSucCbs['asyncSample'].reset();
    // [running state] --<stopAction>--> [stop state]
    t.true(stopAction('asyncSample'));
    t.deepEqual(transSucCbs['asyncSample'].getCall(0).args, ['running', 'stop']);
    t.is(getState('asyncSample'), 'stop');
});
test('should [running state] --<pauseAction>--> [pause state]', function (t) {
    var _a = getMockData(), sampleConfigList = _a.sampleConfigList, transSucCbs = _a.transSucCbs;
    var _b = createSampleController(sampleConfigList), startAction = _b.startAction, pauseAction = _b.pauseAction, getState = _b.getState;
    startAction('asyncSample');
    transSucCbs['asyncSample'].reset();
    // [running state] --<pauseAction>--> [pause state]
    t.true(pauseAction('asyncSample'));
    t.deepEqual(transSucCbs['asyncSample'].getCall(0).args, ['running', 'pause']);
    t.is(getState('asyncSample'), 'pause');
});
test('should [pause state] --<startAction>--> [running state]', function (t) {
    var _a = getMockData(), sampleConfigList = _a.sampleConfigList, transSucCbs = _a.transSucCbs;
    var _b = createSampleController(sampleConfigList), startAction = _b.startAction, pauseAction = _b.pauseAction, getState = _b.getState;
    startAction('asyncSample');
    pauseAction('asyncSample');
    transSucCbs['asyncSample'].reset();
    // [pause state] --<startAction>--> [running state]
    t.true(startAction('asyncSample'));
    t.deepEqual(transSucCbs['asyncSample'].getCall(0).args, ['pause', 'running']);
    t.is(getState('asyncSample'), 'running');
});
test('should [pause state] --<stopAction>--> [stop state]', function (t) {
    var _a = getMockData(), sampleConfigList = _a.sampleConfigList, transSucCbs = _a.transSucCbs;
    var _b = createSampleController(sampleConfigList), startAction = _b.startAction, pauseAction = _b.pauseAction, stopAction = _b.stopAction, getState = _b.getState;
    startAction('asyncSample');
    pauseAction('asyncSample');
    transSucCbs['asyncSample'].reset();
    // [pause state] --<stopAction>--> [stop state]
    t.true(stopAction('asyncSample'));
    t.deepEqual(transSucCbs['asyncSample'].getCall(0).args, ['pause', 'stop']);
    t.is(getState('asyncSample'), 'stop');
});
test('should [pause state] --<pauseAction>--> fail', function (t) {
    var _a = getMockData(), sampleConfigList = _a.sampleConfigList, transSucCbs = _a.transSucCbs;
    var _b = createSampleController(sampleConfigList), startAction = _b.startAction, pauseAction = _b.pauseAction;
    startAction('asyncSample');
    pauseAction('asyncSample');
    transSucCbs['asyncSample'].reset();
    // [pause state] --<pauseAction>--> fail
    t.false(pauseAction('asyncSample'));
    t.false(transSucCbs['asyncSample'].called);
});
test('should not startAction invoke collectCb immediately, if options.isImmediately is false', function (t) {
    var _a = getMockData(), sampleConfigList = _a.sampleConfigList, collectCbs = _a.collectCbs;
    var startAction = createSampleController(sampleConfigList).startAction;
    startAction('asyncSample');
    t.false(collectCbs['asyncSample'].called);
});
test('should startAction invoke collectCb immediately, if options.isImmediately is true', function (t) {
    var _a = getMockData(), sampleConfigList = _a.sampleConfigList, collectCbs = _a.collectCbs;
    var startAction = createSampleController(sampleConfigList).startAction;
    startAction('asyncSample', { isImmediately: true });
    t.true(collectCbs['asyncSample'].called);
});
test('should the interval of each collection is constant, if collectCb is synchronous', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var sandbox, _a, sampleConfigList, reportCbs, startAction;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                sandbox = sinon.createSandbox();
                sandbox.useFakeTimers();
                _a = getMockData(), sampleConfigList = _a.sampleConfigList, reportCbs = _a.reportCbs;
                startAction = createSampleController(sampleConfigList).startAction;
                startAction('syncSample');
                t.false(reportCbs['syncSample'].called);
                return [4 /*yield*/, sandbox.clock.tickAsync(201)];
            case 1:
                _b.sent();
                t.true(reportCbs['syncSample'].called);
                return [4 /*yield*/, sandbox.clock.tickAsync(201)];
            case 2:
                _b.sent();
                t.is(reportCbs['syncSample'].callCount, 2);
                return [2 /*return*/];
        }
    });
}); });
test.serial('should the interval of each collection is constant, if collectCb is asynchronous and async.isWaitTillReturn is false', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var sandbox, _a, sampleConfigList, reportCbs, collectCbs, startAction;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                sandbox = sinon.createSandbox();
                sandbox.useFakeTimers();
                _a = getMockData(), sampleConfigList = _a.sampleConfigList, reportCbs = _a.reportCbs, collectCbs = _a.collectCbs;
                sampleConfigList[0].async.isWaitTillReturn = false;
                startAction = createSampleController(sampleConfigList).startAction;
                startAction('asyncSample');
                t.false(reportCbs['asyncSample'].called);
                return [4 /*yield*/, sandbox.clock.tickAsync(201)];
            case 1:
                _b.sent();
                t.true(collectCbs['asyncSample'].called);
                t.false(reportCbs['asyncSample'].called);
                return [4 /*yield*/, sandbox.clock.tickAsync(201)];
            case 2:
                _b.sent();
                t.is(collectCbs['asyncSample'].callCount, 2);
                t.false(reportCbs['asyncSample'].called);
                // first report
                return [4 /*yield*/, sandbox.clock.tickAsync(800)];
            case 3:
                // first report
                _b.sent();
                t.is(collectCbs['asyncSample'].callCount, (200 + 200 + 800) / 200);
                t.is(reportCbs['asyncSample'].callCount, 1);
                // second report
                return [4 /*yield*/, sandbox.clock.tickAsync(201)];
            case 4:
                // second report
                _b.sent();
                t.is(collectCbs['asyncSample'].callCount, (200 + 200 + 800 + 200) / 200);
                t.is(reportCbs['asyncSample'].callCount, 2);
                return [2 /*return*/];
        }
    });
}); });
test.serial('should each collection needs to wait until the last collection is complete, if collectCb is asynchronous and async.isWaitTillReturn is true', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var sandbox, _a, sampleConfigList, collectCbs, reportCbs, startAction;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                sandbox = sinon.createSandbox();
                sandbox.useFakeTimers();
                _a = getMockData(), sampleConfigList = _a.sampleConfigList, collectCbs = _a.collectCbs, reportCbs = _a.reportCbs;
                sampleConfigList[0].async.isWaitTillReturn = true;
                startAction = createSampleController(sampleConfigList).startAction;
                startAction('asyncSample');
                t.false(reportCbs['asyncSample'].called);
                return [4 /*yield*/, sandbox.clock.tickAsync(201)];
            case 1:
                _b.sent();
                t.is(collectCbs['asyncSample'].callCount, 1);
                t.false(reportCbs['asyncSample'].called);
                return [4 /*yield*/, sandbox.clock.tickAsync(800)];
            case 2:
                _b.sent();
                t.is(collectCbs['asyncSample'].callCount, 1);
                // first report
                return [4 /*yield*/, sandbox.clock.tickAsync(200)];
            case 3:
                // first report
                _b.sent();
                t.is(collectCbs['asyncSample'].callCount, 1);
                t.is(reportCbs['asyncSample'].callCount, 1);
                return [4 /*yield*/, sandbox.clock.tickAsync(201)];
            case 4:
                _b.sent();
                t.is(collectCbs['asyncSample'].callCount, 2);
                t.is(reportCbs['asyncSample'].callCount, 1);
                // second report
                return [4 /*yield*/, sandbox.clock.tickAsync(1000)];
            case 5:
                // second report
                _b.sent();
                t.is(collectCbs['asyncSample'].callCount, 2);
                t.is(reportCbs['asyncSample'].callCount, 2);
                return [2 /*return*/];
        }
    });
}); });
test.serial('should continue to collect but not report, if state is pause', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var sandbox, _a, sampleConfigList, collectCbs, reportCbs, _b, startAction, pauseAction, getQueueSize;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                sandbox = sinon.createSandbox();
                sandbox.useFakeTimers();
                _a = getMockData(), sampleConfigList = _a.sampleConfigList, collectCbs = _a.collectCbs, reportCbs = _a.reportCbs;
                _b = createSampleController(sampleConfigList), startAction = _b.startAction, pauseAction = _b.pauseAction, getQueueSize = _b.getQueueSize;
                startAction('syncSample');
                pauseAction('syncSample');
                return [4 /*yield*/, sandbox.clock.tickAsync(201)];
            case 1:
                _c.sent();
                t.is(collectCbs['syncSample'].callCount, 1);
                t.false(reportCbs['syncSample'].called);
                t.is(getQueueSize('syncSample'), 1);
                return [4 /*yield*/, sandbox.clock.tickAsync(201)];
            case 2:
                _c.sent();
                t.is(collectCbs['syncSample'].callCount, 2);
                t.false(reportCbs['syncSample'].called);
                t.is(getQueueSize('syncSample'), 2);
                return [2 /*return*/];
        }
    });
}); });
test.serial('should stop collecting and report data when state transition from pause to stop if options.isReportAll is true', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var sandbox, _a, sampleConfigList, collectCbs, reportCbs, _b, startAction, pauseAction, stopAction, getQueueSize;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                sandbox = sinon.createSandbox();
                sandbox.useFakeTimers();
                _a = getMockData(), sampleConfigList = _a.sampleConfigList, collectCbs = _a.collectCbs, reportCbs = _a.reportCbs;
                _b = createSampleController(sampleConfigList), startAction = _b.startAction, pauseAction = _b.pauseAction, stopAction = _b.stopAction, getQueueSize = _b.getQueueSize;
                startAction('syncSample');
                pauseAction('syncSample');
                return [4 /*yield*/, sandbox.clock.tickAsync(401)];
            case 1:
                _c.sent();
                t.is(collectCbs['syncSample'].callCount, 2);
                t.false(reportCbs['syncSample'].called);
                t.is(getQueueSize('syncSample'), 2);
                stopAction('syncSample', { isReportAll: true });
                t.is(reportCbs['syncSample'].callCount, 2);
                t.is(getQueueSize('syncSample'), 0);
                return [4 /*yield*/, sandbox.clock.tickAsync(401)];
            case 2:
                _c.sent();
                t.is(reportCbs['syncSample'].callCount, 2);
                return [2 /*return*/];
        }
    });
}); });
test.serial('should stop collecting, discard, and report nothing when state transition from pause to stop if options.isReportAll is false', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var sandbox, _a, sampleConfigList, collectCbs, reportCbs, _b, startAction, pauseAction, stopAction, getQueueSize;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                sandbox = sinon.createSandbox();
                sandbox.useFakeTimers();
                _a = getMockData(), sampleConfigList = _a.sampleConfigList, collectCbs = _a.collectCbs, reportCbs = _a.reportCbs;
                _b = createSampleController(sampleConfigList), startAction = _b.startAction, pauseAction = _b.pauseAction, stopAction = _b.stopAction, getQueueSize = _b.getQueueSize;
                startAction('syncSample');
                pauseAction('syncSample');
                return [4 /*yield*/, sandbox.clock.tickAsync(401)];
            case 1:
                _c.sent();
                t.is(collectCbs['syncSample'].callCount, 2);
                t.false(reportCbs['syncSample'].called);
                t.is(getQueueSize('syncSample'), 2);
                stopAction('syncSample', { isReportAll: false });
                t.false(reportCbs['syncSample'].called);
                t.is(getQueueSize('syncSample'), 0);
                return [2 /*return*/];
        }
    });
}); });
test.serial('should continue to collect and report data  when state transition from pause to running', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var sandbox, _a, sampleConfigList, collectCbs, reportCbs, _b, startAction, pauseAction, getQueueSize;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                sandbox = sinon.createSandbox();
                sandbox.useFakeTimers();
                _a = getMockData(), sampleConfigList = _a.sampleConfigList, collectCbs = _a.collectCbs, reportCbs = _a.reportCbs;
                _b = createSampleController(sampleConfigList), startAction = _b.startAction, pauseAction = _b.pauseAction, getQueueSize = _b.getQueueSize;
                startAction('syncSample');
                pauseAction('syncSample');
                return [4 /*yield*/, sandbox.clock.tickAsync(401)];
            case 1:
                _c.sent();
                t.is(collectCbs['syncSample'].callCount, 2);
                t.false(reportCbs['syncSample'].called);
                t.is(getQueueSize('syncSample'), 2);
                startAction('syncSample');
                t.is(reportCbs['syncSample'].callCount, 2);
                t.is(getQueueSize('syncSample'), 0);
                return [4 /*yield*/, sandbox.clock.tickAsync(401)];
            case 2:
                _c.sent();
                t.is(reportCbs['syncSample'].callCount, 4);
                t.is(getQueueSize('syncSample'), 0);
                return [2 /*return*/];
        }
    });
}); });
test.serial('should discard collection when exceed the queue capacity, if state is pause', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var sandbox, _a, sampleConfigList, collectCbs, reportCbs, _b, startAction, pauseAction, getQueueSize, capacity;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                sandbox = sinon.createSandbox();
                sandbox.useFakeTimers();
                _a = getMockData(), sampleConfigList = _a.sampleConfigList, collectCbs = _a.collectCbs, reportCbs = _a.reportCbs;
                _b = createSampleController(sampleConfigList), startAction = _b.startAction, pauseAction = _b.pauseAction, getQueueSize = _b.getQueueSize;
                capacity = 3;
                startAction('syncSample');
                pauseAction('syncSample', { capacity: capacity });
                return [4 /*yield*/, sandbox.clock.tickAsync(1001)];
            case 1:
                _c.sent();
                t.is(collectCbs['syncSample'].callCount, 5);
                t.false(reportCbs['syncSample'].called);
                t.is(getQueueSize('syncSample'), capacity);
                startAction('syncSample');
                t.is(reportCbs['syncSample'].callCount, capacity);
                t.is(getQueueSize('syncSample'), 0);
                return [2 /*return*/];
        }
    });
}); });
test.serial('should stop collecting and reporting, if state is stop', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var sandbox, _a, sampleConfigList, collectCbs, reportCbs, _b, startAction, stopAction, getQueueSize;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                sandbox = sinon.createSandbox();
                sandbox.useFakeTimers();
                _a = getMockData(), sampleConfigList = _a.sampleConfigList, collectCbs = _a.collectCbs, reportCbs = _a.reportCbs;
                _b = createSampleController(sampleConfigList), startAction = _b.startAction, stopAction = _b.stopAction, getQueueSize = _b.getQueueSize;
                startAction('syncSample');
                return [4 /*yield*/, sandbox.clock.tickAsync(201)];
            case 1:
                _c.sent();
                t.is(collectCbs['syncSample'].callCount, 1);
                t.is(reportCbs['syncSample'].callCount, 1);
                stopAction('syncSample');
                return [4 /*yield*/, sandbox.clock.tickAsync(201)];
            case 2:
                _c.sent();
                t.is(collectCbs['syncSample'].callCount, 1);
                t.is(reportCbs['syncSample'].callCount, 1);
                t.is(getQueueSize('syncSample'), 0);
                return [2 /*return*/];
        }
    });
}); });
test.serial('should takes immediate effect except collectInterval if update config with option.isReStartImmediately=false', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var sandbox, _a, sampleConfigList, transSucCbs, _b, startAction, update, fake;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                sandbox = sinon.createSandbox();
                sandbox.useFakeTimers();
                _a = getMockData(), sampleConfigList = _a.sampleConfigList, transSucCbs = _a.transSucCbs;
                _b = createSampleController(sampleConfigList), startAction = _b.startAction, update = _b.update;
                startAction('syncSample');
                return [4 /*yield*/, sandbox.clock.tickAsync(201)];
            case 1:
                _c.sent();
                t.true(transSucCbs['syncSample'].called);
                fake = sinon.fake();
                update('syncSample', { collectCb: fake, collectInterval: 1200 });
                t.false(fake.called);
                // The modification of collectCb takes immediate effect
                // However, collectInterval takes effect only after the timer is set next time
                return [4 /*yield*/, sandbox.clock.tickAsync(201)];
            case 2:
                // The modification of collectCb takes immediate effect
                // However, collectInterval takes effect only after the timer is set next time
                _c.sent();
                t.is(transSucCbs['syncSample'].callCount, 1);
                t.true(fake.called);
                return [4 /*yield*/, sandbox.clock.tickAsync(1200)];
            case 3:
                _c.sent();
                t.is(transSucCbs['syncSample'].callCount, 1);
                t.is(fake.callCount, 2);
                return [2 /*return*/];
        }
    });
}); });
test.serial('should takes immediate effect after the restart if update config with option.isReStartImmediately=true', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var sandbox, _a, sampleConfigList, transSucCbs, collectCbs, _b, startAction, update, fake;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                sandbox = sinon.createSandbox();
                sandbox.useFakeTimers();
                _a = getMockData(), sampleConfigList = _a.sampleConfigList, transSucCbs = _a.transSucCbs, collectCbs = _a.collectCbs;
                _b = createSampleController(sampleConfigList), startAction = _b.startAction, update = _b.update;
                startAction('syncSample');
                return [4 /*yield*/, sandbox.clock.tickAsync(201)];
            case 1:
                _c.sent();
                t.is(transSucCbs['syncSample'].callCount, 1);
                fake = sinon.fake();
                update('syncSample', { collectCb: fake, collectInterval: 100 }, { isReStartImmediately: true });
                t.false(fake.called);
                // The modification of collectCb takes immediate effect
                // However, collectInterval takes effect only after the timer is set next time
                return [4 /*yield*/, sandbox.clock.tickAsync(101)];
            case 2:
                // The modification of collectCb takes immediate effect
                // However, collectInterval takes effect only after the timer is set next time
                _c.sent();
                t.is(transSucCbs['syncSample'].callCount, 3);
                t.is(collectCbs['syncSample'].callCount, 1);
                t.is(fake.callCount, 1);
                return [4 /*yield*/, sandbox.clock.tickAsync(101)];
            case 3:
                _c.sent();
                t.is(collectCbs['syncSample'].callCount, 1);
                t.is(fake.callCount, 2);
                return [2 /*return*/];
        }
    });
}); });
//# sourceMappingURL=pc-perf-utils.spec.js.map