"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskDefinitionRegistryImpl = exports.ITaskDefinitionRegistry = exports.KeyedTaskIdentifier = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@opensumi/di");
const ide_utils_1 = require("@opensumi/ide-utils");
const localize_1 = require("./localize");
const { deepClone } = ide_utils_1.objects;
var KeyedTaskIdentifier;
(function (KeyedTaskIdentifier) {
    function sortedStringify(literal) {
        const keys = Object.keys(literal).sort();
        let result = '';
        for (const key of keys) {
            let stringified = literal[key];
            if (stringified instanceof Object) {
                stringified = sortedStringify(stringified);
            }
            else if (typeof stringified === 'string') {
                stringified = stringified.replace(/,/g, ',,');
            }
            result += key + ',' + stringified + ',';
        }
        return result;
    }
    function create(value) {
        const resultKey = sortedStringify(value);
        const result = { _key: resultKey, type: value.taskType };
        Object.assign(result, value);
        return result;
    }
    KeyedTaskIdentifier.create = create;
})(KeyedTaskIdentifier = exports.KeyedTaskIdentifier || (exports.KeyedTaskIdentifier = {}));
exports.ITaskDefinitionRegistry = Symbol('ITaskDefinitionRegistry');
let TaskDefinitionRegistryImpl = class TaskDefinitionRegistryImpl {
    constructor() {
        this.createTaskIdentifier = (external, reporter) => {
            const definition = this.get(external.type);
            if (definition === undefined) {
                // We have no task definition so we can't sanitize the literal. Take it as is
                const copy = deepClone(external);
                delete copy._key;
                return KeyedTaskIdentifier.create(copy);
            }
            const literal = Object.create(null);
            literal.type = definition.taskType;
            const required = new Set();
            definition.required.forEach((element) => required.add(element));
            const properties = definition.properties;
            for (const property of Object.keys(properties)) {
                const value = external[property];
                if (value !== undefined && value !== null) {
                    literal[property] = value;
                }
                else if (required.has(property)) {
                    const schema = properties[property];
                    if (schema.default !== undefined) {
                        literal[property] = deepClone(schema.default);
                    }
                    else {
                        switch (schema.type) {
                            case 'boolean':
                                literal[property] = false;
                                break;
                            case 'number':
                            case 'integer':
                                literal[property] = 0;
                                break;
                            case 'string':
                                literal[property] = '';
                                break;
                            default:
                                reporter.error((0, localize_1.formatLocalize)('TaskDefinition.missingRequiredProperty', "Error: the task identifier '{0}' is missing the required property '{1}'. The task identifier will be ignored.", JSON.stringify(external, undefined, 0), property));
                                return undefined;
                        }
                    }
                }
            }
            return KeyedTaskIdentifier.create(literal);
        };
        this.taskTypes = Object.create(null);
        this.readyPromise = new Promise((res, rej) => res(undefined));
    }
    onReady() {
        return this.readyPromise;
    }
    register(taskType, definition) {
        this.taskTypes[taskType] = definition;
        return ide_utils_1.Disposable.create(() => delete this.taskTypes[taskType]);
    }
    get(key) {
        return this.taskTypes[key];
    }
    all() {
        return Object.keys(this.taskTypes).map((key) => this.taskTypes[key]);
    }
    getJsonSchema() {
        if (this._schema === undefined) {
            const schemas = [];
            for (const definition of this.all()) {
                const schema = {
                    type: 'object',
                    additionalProperties: false,
                };
                if (definition.required.length > 0) {
                    schema.required = definition.required.slice(0);
                }
                if (definition.properties !== undefined) {
                    schema.properties = deepClone(definition.properties);
                }
                else {
                    schema.properties = Object.create(null);
                }
                schema.properties.type = {
                    type: 'string',
                    enum: [definition.taskType],
                };
                schemas.push(schema);
            }
            this._schema = { oneOf: schemas };
        }
        return this._schema;
    }
};
TaskDefinitionRegistryImpl = tslib_1.__decorate([
    (0, di_1.Injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], TaskDefinitionRegistryImpl);
exports.TaskDefinitionRegistryImpl = TaskDefinitionRegistryImpl;
//# sourceMappingURL=task-definition.js.map