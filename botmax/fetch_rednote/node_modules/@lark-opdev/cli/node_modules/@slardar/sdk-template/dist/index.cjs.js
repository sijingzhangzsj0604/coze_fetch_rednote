'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');

var DEFAULT_SIZE = 10;
var DEFAULT_WAIT = 1000;
var stringifyBatch = function (list) {
    return JSON.stringify({
        ev_type: 'batch',
        list: list,
    });
};
function createBatchSender(config) {
    var transport = config.transport;
    var endpoint = config.endpoint, _a = config.size, size = _a === void 0 ? DEFAULT_SIZE : _a, _b = config.wait, wait = _b === void 0 ? DEFAULT_WAIT : _b;
    var batch = [];
    var tid = 0;
    var fail;
    var sender = {
        getSize: function () {
            return size;
        },
        getWait: function () {
            return wait;
        },
        setSize: function (v) {
            size = v;
        },
        setWait: function (v) {
            wait = v;
        },
        getEndpoint: function () {
            return endpoint;
        },
        setEndpoint: function (v) {
            endpoint = v;
        },
        send: function (e) {
            batch.push(e);
            if (batch.length >= size) {
                sendBatch.call(this);
            }
            clearTimeout(tid);
            tid = setTimeout(sendBatch.bind(this), wait);
        },
        flush: function () {
            clearTimeout(tid);
            sendBatch.call(this);
        },
        getBatchData: function () {
            return batch.length ? stringifyBatch(batch) : '';
        },
        clear: function () {
            clearTimeout(tid);
            batch = [];
        },
        fail: function (cb) {
            fail = cb;
        },
    };
    function sendBatch() {
        if (!batch.length) {
            return;
        }
        var data = this.getBatchData();
        transport.post({
            url: endpoint,
            data: data,
            fail: function (err) {
                fail && fail(err, data);
            },
        });
        batch = [];
    }
    return sender;
}

var EVENTS = [
    'init',
    'start',
    'config',
    'beforeDestroy',
    'provide',
    'beforeReport',
    'report',
    'beforeBuild',
    'build',
    'beforeSend',
    'send',
    'beforeConfig',
];

var noop = function () { return ({}); };
function id(v) {
    return v;
}

// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(o) {
    return typeof o === 'object' && o !== null;
}
function isInstanceOf(wat, base) {
    try {
        return wat instanceof base;
    }
    catch (_e) {
        return false;
    }
}
var objProto = Object.prototype;
// https://stackoverflow.com/a/5878101
function isPlainObject(o) {
    if (isObject(o)) {
        if (typeof Object.getPrototypeOf === 'function') {
            var proto = Object.getPrototypeOf(o);
            return proto === objProto || proto === null;
        }
        // cannot test, requires ES3
        /* istanbul ignore next */
        return objProto.toString.call(o) === '[object Object]';
    }
    return false;
}
function isArray(o) {
    return objProto.toString.call(o) === '[object Array]';
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isFunction(o) {
    return typeof o === 'function';
}
function isBoolean(o) {
    return typeof o === 'boolean';
}
function isNumber(o) {
    return typeof o === 'number';
}
function isString(o) {
    return typeof o === 'string';
}
function isEqual(a, b) {
    // special
    if (isNumber(a) && isNaN(a)) {
        return isNumber(b) && isNaN(b);
    }
    // same primitive or same object
    if (a === b) {
        return true;
    }
    if (isObject(a)) {
        if (isPlainObject(a)) {
            return isPlainObject(b) && isEqualPlainObject(a, b);
        }
        else if (isArray(a)) {
            return isArray(b) && isEqualArray(a, b);
            //TODO: handle TypedArray, Map, Set, ArrayLike
        }
        else {
            // different object
            return false;
        }
    }
    // different primitive
    return false;
}
function isEqualPlainObject(a, b) {
    for (var k in a) {
        if (!isEqual(a[k], b[k])) {
            return false;
        }
    }
    return true;
}
function isEqualArray(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    return a.every(function (v, i) { return isEqual(v, b[i]); });
}
function isError(wat) {
    switch (Object.prototype.toString.call(wat)) {
        case '[object Error]':
            return true;
        case '[object Exception]':
            /* istanbul ignore next */
            return true;
        case '[object DOMError]':
            return true;
        case '[object DOMException]':
            /* istanbul ignore next */
            return true;
        default:
            /* istanbul ignore next */
            return wat instanceof Error;
    }
}
function isEvent(wat) {
    return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
}
function isErrorEvent(what) {
    return Object.prototype.toString.call(what) === '[object ErrorEvent]';
}
function isPromiseRejectionEvent(what) {
    return Object.prototype.toString.call(what) === '[object PromiseRejectionEvent]';
}

// eslint-disable-next-line @typescript-eslint/ban-types
function omit(object) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    if (isObject(object)) {
        var res_1 = {};
        objectForIn(object, function (k, v) {
            if (!arrayIncludes(keys, k)) {
                res_1[k] = v;
            }
        });
        return res_1;
    }
    return object;
}
function hasKey(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
}
function objectForIn(object, callback) {
    if (isObject(object)) {
        for (var i in object) {
            if (hasKey(object, i)) {
                callback.call(null, i, object[i]);
            }
        }
    }
}
function filterObjectValueBy(obj, p) {
    if (!isObject(obj)) {
        return obj;
    }
    if (!isFunction(p)) {
        return obj;
    }
    var res = {};
    objectForIn(obj, function (key, value) {
        if (p(value)) {
            res[key] = value;
        }
    });
    return res;
}
// 把source对象中的内容深度赋给target, 数组覆盖
function mergeDeepCopyArray() {
    var source = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        source[_i] = arguments[_i];
    }
    var result = {};
    var k = 0;
    while (k < source.length) {
        result = _mergeDeepCopyArray(result, source[k++]);
    }
    return result;
}
// 把source对象中的内容深度赋给target, 数组合并
function mergeDeepConcatArray() {
    var source = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        source[_i] = arguments[_i];
    }
    var result = {};
    var k = 0;
    while (k < source.length) {
        result = _mergeDeepMergeArray(result, source[k++]);
    }
    return result;
}
function _mergeDeepCopyArray(target, source) {
    var result = tslib.__assign({}, target);
    for (var key in source) {
        if (hasKey(source, key) && source[key] !== undefined) {
            if (isObject(source[key]) && isPlainObject(source[key])) {
                result[key] = _mergeDeepCopyArray(isObject(target[key]) ? target[key] : {}, source[key]);
            }
            else if (isArray(source[key])) {
                result[key] = cloneArray(source[key]);
            }
            else {
                result[key] = source[key];
            }
        }
    }
    return result;
}
// 递归赋值
function _mergeDeepMergeArray(target, source) {
    var result = tslib.__assign({}, target);
    for (var key in source) {
        if (hasKey(source, key) && source[key] !== undefined) {
            if (isObject(source[key]) && isPlainObject(source[key])) {
                result[key] = _mergeDeepMergeArray(isObject(target[key]) ? target[key] : {}, source[key]);
            }
            else if (isArray(source[key]) && isArray(target[key])) {
                result[key] = _mergeDeepArray(target[key], source[key]);
            }
            else {
                result[key] = source[key];
            }
        }
    }
    return result;
}
function _mergeDeepArray(target, source) {
    var _target = isArray(target) ? target : [];
    var _source = isArray(source) ? source : [];
    return Array.prototype.concat.call(_target, _source).map(function (v) {
        if (v instanceof RegExp) {
            return v;
        }
        else if (isObject(v) && isPlainObject(v)) {
            return _mergeDeepMergeArray({}, v);
        }
        else if (isArray(v)) {
            return _mergeDeepArray([], v);
        }
        else {
            return v;
        }
    });
}
function cloneArray(array) {
    return array.slice();
}
// 检查数组中是否有元素
function arrayIncludes(array, value) {
    if (!isArray(array)) {
        return false;
    }
    if (array.length === 0) {
        return false;
    }
    var k = 0;
    while (k < array.length) {
        if (array[k] === value) {
            return true;
        }
        k++;
    }
    return false;
}
var arrayRemove = function (arr, e) {
    if (!isArray(arr)) {
        return arr;
    }
    var i = arr.indexOf(e);
    if (i >= 0) {
        var arr_ = arr.slice();
        arr_.splice(i, 1);
        return arr_;
    }
    return arr;
};
/**
 * 按路径访问对象属性
 * @param target 待访问对象
 * @param property 访问属性路径
 * @param { (target: any, property: string): any } visitor 访问器
 */
var safeVisit = function (target, path, visitor) {
    var _a, _b;
    var paths = path.split('.');
    var _c = tslib.__read(paths), method = _c[0], rest = _c.slice(1);
    while (target && rest.length > 0) {
        target = target[method];
        _a = rest, _b = tslib.__read(_a), method = _b[0], rest = _b.slice(1);
    }
    if (!target) {
        return undefined;
    }
    return visitor(target, method);
};
var safeSet = function (target, path, value) {
    safeVisit(target, path, function (obj, property) {
        try {
            obj[property] = value;
        }
        catch (e) {
            // ignore
        }
    });
};
/**
 *  按路径调用函数
 * @param target 待调用对象，如 `client`
 * @param methods 待调用方法路径，可能是一级路径 `client.start`, 或者是多级命令 `client.context.set`
 * @param args 调用参数
 */
var safeCall = function (target, method, args) {
    return safeVisit(target, method, function (obj, property) {
        if (obj && property in obj && isFunction(obj[property])) {
            try {
                return obj[property].apply(obj, args);
            }
            catch (err) {
                // ignore
                return undefined;
            }
        }
    });
};
/**
 *  按路径调用函数或获取值
 * @param target 待调用对象，如 `client`
 * @param methods 待调用方法路径或属性路径
 * @param args 调用参数
 */
var safeCallOrGet = function (target, method, args) {
    return safeVisit(target, method, function (obj, property) {
        if (obj && property in obj) {
            // call
            if ((args && args.length) || isFunction(obj[property])) {
                try {
                    return obj[property].apply(obj, args);
                }
                catch (err) {
                    // ignore
                    return undefined;
                }
            }
            else {
                // get
                return obj[property];
            }
        }
    });
};
var applyRecord = function () {
    var record = {};
    var set = function (key, val) { return (record[key] = val); };
    var del = function (key) { return delete record[key]; };
    return [record, set, del];
};
var pick = function (obj, keys) {
    if (!obj || !isObject(obj))
        return obj;
    return keys.reduce(function (prev, cur) {
        prev[cur] = obj[cur];
        return prev;
    }, {});
};

var noopSender = {
    send: function () { },
};
var noopBuilder = {
    build: function () { },
};
var directBuilder = {
    build: id,
};
var createBaseConfigManager = function (c) {
    var onChange = noop;
    var config = c;
    return {
        getConfig: function () {
            return config;
        },
        setConfig: function (c) {
            config = tslib.__assign(tslib.__assign({}, config), c);
            onChange();
            return config;
        },
        onChange: function (fn) {
            onChange = fn;
        },
        onReady: function (fn) {
            fn();
        },
    };
};
var createMergeConfigManager = function (c) {
    var onChange = noop;
    var config = c;
    return {
        getConfig: function () {
            return config;
        },
        setConfig: function (c) {
            config = mergeDeepConcatArray(config, c);
            onChange();
            return config;
        },
        onChange: function (fn) {
            onChange = fn;
        },
        onReady: function (fn) {
            fn();
        },
    };
};

var camelToKebab = function (str) {
    return str.replace(/([a-z])([A-Z])/g, function (_, a, b) { return a + "-" + b.toLowerCase(); });
};
function getRegexp(ignore) {
    if (!isArray(ignore)) {
        return null;
    }
    return ignore.length ? joinRegExp(ignore) : null;
}
function joinRegExp(patterns) {
    var sources = [];
    var len = patterns.length;
    for (var i = 0; i < len; i++) {
        var pattern = patterns[i];
        if (isString(pattern)) {
            sources.push(pattern.replace(/([.*+?^=!:${}()|[\]/\\])/g, '\\$1'));
        }
        else if (pattern && pattern.source) {
            sources.push(pattern.source);
        }
    }
    return new RegExp(sources.join('|'), 'i');
}
function safeStringify(a) {
    try {
        return isString(a) ? a : JSON.stringify(a);
    }
    catch (err) {
        return '[FAILED_TO_STRINGIFY]:' + String(err);
    }
}
function safeJoin(input, delimiter) {
    if (!isArray(input)) {
        return '';
    }
    var output = [];
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (var i = 0; i < input.length; i++) {
        try {
            output.push(String(input[i]));
        }
        catch (e) {
            output.push('[value cannot be serialized]');
        }
    }
    return output.join(delimiter);
}
/**
 * get query string from map
 * @param  {Record<string | number, string | number>} map
 */
var joinQueryWithMap = function (map) {
    return isObject(map)
        ? Object.keys(map)
            .reduce(function (result, currentKey) {
            result += "&" + currentKey + "=" + map[currentKey];
            return result;
        }, '')
            .replace('&', '?')
        : '';
};

function createContextAgent() {
    var context = {};
    var stringified = {};
    var contextAgent = {
        set: function (k, v) {
            context[k] = v;
            stringified[k] = safeStringify(v);
            return contextAgent;
        },
        merge: function (ctx) {
            context = tslib.__assign(tslib.__assign({}, context), ctx);
            Object.keys(ctx).forEach(function (key) {
                stringified[key] = safeStringify(ctx[key]);
            });
            return contextAgent;
        },
        delete: function (k) {
            delete context[k];
            delete stringified[k];
            return contextAgent;
        },
        clear: function () {
            context = {};
            stringified = {};
            return contextAgent;
        },
        get: function (k) {
            return stringified[k];
        },
        toString: function () {
            return tslib.__assign({}, stringified);
        },
    };
    return contextAgent;
}

// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * You can feel free to restore when you hook a function.
 * But you ought to restore 「in order」 if you hooked a value reference or a real obj reference.Because we not store the last value referent for now.
 * eg: obj.a = 1;
 * const r_1 = hookObjectProperty(obj, 'a',() =>2)()
 * const r_2 = hookObjectProperty(obj, 'a',() =>3)()
 * r_2() // obj.a === 2
 * r_1() // obj.a === 1
 *
 * @template T
 * @template K
 * @template P
 * @param {T} obj
 * @param {K} key
 * @param {(origin: T[K], ...params: P) => T[K]} hookFunc
 * @param {boolean} isCatchError When an error occurs after calling a hooked function, we want to suppress the errors and try to call the original function by default.
 * @return {*}
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var hookObjectProperty = function (obj, key, hookFunc, isCatchError) {
    if (isCatchError === void 0) { isCatchError = true; }
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, tslib.__spreadArray([origin], tslib.__read(params), false));
        var hooked = hookedUnsafe;
        // 给所有 hook 之后的方法包一层 try catch
        if (isFunction(hooked) && isCatchError) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                try {
                    return hookedUnsafe.apply(this, args);
                }
                catch (_a) {
                    return isFunction(origin) && origin.apply(this, args);
                }
            };
        }
        obj[key] = hooked;
        // strict: is break
        return function (strict) {
            if (!strict) {
                hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
            }
        };
    };
};
/**
 * 劫持对象方法
 * 必须记得给 hookFunc 劫持的方法包 try catch ！
 * 不在本方法里包是为了避免对象原方法被调用两次
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var hookMethodDangerously = function (obj, key, hookFunc) {
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, tslib.__spreadArray([origin], tslib.__read(params), false));
        var hooked = hookedUnsafe;
        if (isFunction(hooked)) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return hookedUnsafe.apply(this, args);
            };
        }
        obj[key] = hooked;
        return function () {
            hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
        };
    };
};

var createLogger = function (prefix, prefixLen) {
    if (prefixLen === void 0) { prefixLen = 20; }
    var count = 0;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // eslint-disable-next-line no-console
        console.log.apply(console, tslib.__spreadArray([prefix.padStart(prefixLen, ' '), Date.now(), ("" + count++).padStart(8, ' ')], tslib.__read(args), false));
    };
};
var count = 0;
var log = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    // eslint-disable-next-line no-console
    console.log.apply(console, tslib.__spreadArray(['[SDK]', Date.now(), ("" + count++).padStart(8, ' ')], tslib.__read(args), false));
};
var errCount = 0;
var error = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    // eslint-disable-next-line no-console
    console.error.apply(console, tslib.__spreadArray(['[SDK]', Date.now(), ("" + errCount++).padStart(8, ' ')], tslib.__read(args), false));
};
var warnCount = 0;
var warn = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    // eslint-disable-next-line no-console
    console.warn.apply(console, tslib.__spreadArray(['[SDK]', Date.now(), ("" + warnCount++).padStart(8, ' ')], tslib.__read(args), false));
};

var isHitBySampleRate = function (sampleRate) {
    if (Math.random() < Number(sampleRate)) {
        return true;
    }
    return false;
};
var isHitByRandom = function (random, sampleRate) {
    if (random < Number(sampleRate)) {
        return true;
    }
    return false;
};

var runProcessors = function (fns) {
    return function (e) {
        var r = e;
        for (var i = 0; i < fns.length; i++) {
            if (r) {
                try {
                    r = fns[i](r);
                }
                catch (err) {
                    error(err);
                }
            }
            else {
                break;
            }
        }
        return r;
    };
};

/**
 * 生成uuid
 * stolen from https://github.com/kelektiv/node-uuid#readme uuid/v4
 *
 * @returns
 */
function mathRNG() {
    var rnds = new Array(16);
    var r = 0;
    for (var i = 0; i < 16; i++) {
        if ((i & 0x03) === 0) {
            r = Math.random() * 0x100000000;
        }
        rnds[i] = (r >>> ((i & 0x03) << 3)) & 0xff;
    }
    return rnds;
}
function bytesToUuid(buf) {
    var byteToHex = [];
    for (var index = 0; index < 256; ++index) {
        byteToHex[index] = (index + 0x100).toString(16).substr(1);
    }
    var i = 0;
    var bth = byteToHex;
    // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
    return [
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
    ].join('');
}
function uuid() {
    var rnds = mathRNG();
    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    return bytesToUuid(rnds);
}

var BUFFER_TIME = 300000; // 5分钟
var applyBufferTimer = function (checkIfNeedCancel, cb, bufferTime) {
    var tid = 0;
    if (bufferTime === -1)
        return noop;
    return function () {
        if (checkIfNeedCancel()) {
            tid && clearTimeout(tid);
            tid = 0;
            return;
        }
        tid === 0 && (tid = setTimeout(cb, bufferTime));
    };
};

/* eslint-disable @typescript-eslint/no-invalid-void-type */
var nextLink = function (args, cb) {
    var nextCbs = [];
    try {
        nextCbs = cb.reduce(function (sum, s) {
            try {
                var nextCb = s(args);
                typeof nextCb === 'function' && sum.push(nextCb);
            }
            catch (_a) {
                // do nothing
            }
            return sum;
        }, []);
    }
    catch (_a) {
        // do nothing
    }
    return function (nextArgs) { return nextLink(nextArgs, nextCbs); };
};
var toObservable = function (bufferTime) {
    if (bufferTime === void 0) { bufferTime = BUFFER_TIME; }
    var subscribers = [];
    var __complete = [];
    var closed = false;
    var attachCb;
    // 暂缓的自动销毁机制，比如5min 没有人订阅就自动销毁
    var setCloseIfNeed = applyBufferTimer(function () { return !!subscribers.length; }, function () {
        closed = true;
        attachCb && attachCb[0]();
        __complete.forEach(function (e) { return e(); });
        __complete.length = 0;
        attachCb = undefined;
    }, bufferTime);
    var unsubscribe = function (o) {
        subscribers = arrayRemove(subscribers, o);
        !closed && setCloseIfNeed();
    };
    return {
        next: function (args) {
            return nextLink(args, subscribers);
        },
        complete: function (cb) {
            __complete.push(cb);
        },
        attach: function (disconnect, onSubscribe) {
            attachCb = [disconnect, onSubscribe];
        },
        subscribe: function (o) {
            if (closed)
                throw new Error('Observer is closed');
            subscribers.push(o);
            attachCb && attachCb[1] && attachCb[1](o);
            setCloseIfNeed();
            return function () { return unsubscribe(o); };
        },
        unsubscribe: unsubscribe,
    };
};
var createSafeObserver = function (observer, completeCb, bufferTime) {
    var cur = toObservable(bufferTime);
    try {
        observer(cur.next, cur.attach);
        completeCb && cur.complete(completeCb);
    }
    catch (_a) {
        //
    }
    return [cur.subscribe, cur.unsubscribe];
};

function createClient(creationConfig) {
    var builder = creationConfig.builder, createSender = creationConfig.createSender, createDefaultConfig = creationConfig.createDefaultConfig, createConfigManager = creationConfig.createConfigManager, userConfigNormalizer = creationConfig.userConfigNormalizer, initConfigNormalizer = creationConfig.initConfigNormalizer, validateInitConfig = creationConfig.validateInitConfig;
    var sender;
    var configManager;
    var handlers = {};
    EVENTS.forEach(function (e) { return (handlers[e] = []); });
    var inited = false;
    var started = false;
    var destroyed = false;
    // 缓存 start 之前 build 的事件
    var preStartQueue = [];
    // 禁止通过 provide 挂载的字段名
    var reservedNames = [];
    var client = {
        getBuilder: function () { return builder; },
        getSender: function () { return sender; },
        getPreStartQueue: function () { return preStartQueue; },
        init: function (c) {
            if (inited) {
                warn('already inited');
                return;
            }
            if (c && isObject(c) && validateInitConfig(c)) {
                var defaultConfig = createDefaultConfig(c);
                if (!defaultConfig) {
                    throw new Error('defaultConfig missing');
                }
                var initConfig = initConfigNormalizer(c);
                configManager = createConfigManager(defaultConfig);
                configManager.setConfig(initConfig);
                configManager.onChange(function () {
                    handle('config');
                });
                sender = createSender(configManager.getConfig());
                if (!sender) {
                    throw new Error('sender missing');
                }
                inited = true;
                handle('init', true);
            }
            else {
                throw new Error('invalid InitConfig, init failed');
            }
        },
        set: function (c) {
            if (!inited) {
                return;
            }
            if (c && isObject(c)) {
                handle('beforeConfig', false, c);
                configManager === null || configManager === void 0 ? void 0 : configManager.setConfig(c);
            }
        },
        config: function (c) {
            if (!inited) {
                return;
            }
            if (c && isObject(c)) {
                handle('beforeConfig', false, c);
                configManager === null || configManager === void 0 ? void 0 : configManager.setConfig(userConfigNormalizer(c));
            }
            return configManager === null || configManager === void 0 ? void 0 : configManager.getConfig();
        },
        provide: function (name, value) {
            if (arrayIncludes(reservedNames, name)) {
                warn("cannot provide " + name + ", reserved");
                return;
            }
            client[name] = value;
            handle('provide', false, name);
        },
        start: function () {
            var _this = this;
            if (!inited) {
                return;
            }
            if (started) {
                return;
            }
            configManager === null || configManager === void 0 ? void 0 : configManager.onReady(function () {
                started = true;
                handle('start', true);
                preStartQueue.forEach(function (e) { return _this.build(e); });
                preStartQueue = [];
            });
        },
        report: function (data) {
            if (!data) {
                return;
            }
            var preReport = runProcessors(handlers['beforeReport'])(data);
            if (!preReport) {
                return;
            }
            var processed = runProcessors(handlers['report'])(preReport);
            if (!processed) {
                return;
            }
            if (started) {
                this.build(processed);
            }
            else {
                preStartQueue.push(processed);
            }
        },
        build: function (data) {
            if (!started) {
                return;
            }
            var preBuild = runProcessors(handlers['beforeBuild'])(data);
            if (!preBuild) {
                return;
            }
            var built = builder.build(preBuild);
            if (!built) {
                return;
            }
            var processed = runProcessors(handlers['build'])(built);
            if (!processed) {
                return;
            }
            this.send(processed);
        },
        send: function (data) {
            if (!started) {
                return;
            }
            var processed = runProcessors(handlers['beforeSend'])(data);
            if (processed) {
                sender.send(processed);
                handle('send', false, processed);
            }
        },
        destroy: function () {
            destroyed = true;
            handle('beforeDestroy', true);
        },
        on: function (ev, handler) {
            if (ev === 'init' && inited) {
                handler();
            }
            else if (ev === 'start' && started) {
                handler();
            }
            else if (ev === 'beforeDestroy' && destroyed) {
                handler();
            }
            else if (handlers[ev]) {
                handlers[ev].push(handler);
            }
        },
        off: function (ev, handler) {
            if (handlers[ev])
                handlers[ev] = arrayRemove(handlers[ev], handler);
        },
    };
    reservedNames = Object.keys(client);
    return client;
    function handle(ev, once) {
        if (once === void 0) { once = false; }
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        handlers[ev].forEach(function (f) {
            try {
                f.apply(void 0, tslib.__spreadArray([], tslib.__read(args), false));
            }
            catch (_err) {
                // ignore
            }
        });
        if (once) {
            handlers[ev].length = 0;
        }
    }
}

var ContextPlugin = function (client) {
    var contextAgent = createContextAgent();
    client.provide('context', contextAgent);
    client.on('report', function (ev) {
        if (!ev.extra) {
            ev.extra = {};
        }
        ev.extra.context = contextAgent.toString();
        return ev;
    });
};

var withCommandArray = function (client, captureContext, applyArgsWithContext) {
    // 缓存需要异步插件来消费的命令
    var cache = {};
    var newClient = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var methodPath = args[0];
        if (!methodPath)
            return;
        var method = methodPath.split('.')[0];
        // 捕获上下文，等异步插件加载后传入
        if (!(method in newClient)) {
            var cachedCommands = cache[method] || [];
            // 区分预收集来的上下文与普通上下文
            var capturedContext = (_a = captureContext === null || captureContext === void 0 ? void 0 : captureContext(client)) !== null && _a !== void 0 ? _a : {};
            cachedCommands.push(tslib.__spreadArray([capturedContext], tslib.__read(args), false));
            cache[method] = cachedCommands;
            return;
        }
        return safeCall(newClient, methodPath, [].slice.call(args, 1));
    };
    hookObjectProperty(client, 'provide', function (origin) {
        return function (name, value) {
            newClient[name] = value;
            origin.call(client, name, value);
        };
    })();
    for (var nextKey in client) {
        // Avoid bugs when hasOwnProperty is shadowed
        if (Object.prototype.hasOwnProperty.call(client, nextKey)) {
            newClient[nextKey] = client[nextKey];
        }
    }
    client.on('provide', function (name) {
        if (cache[name]) {
            cache[name].forEach(function (cachedCommands) {
                var _a = tslib.__read(cachedCommands), capturedContext = _a[0], args = _a.slice(1);
                applyArgsWithContext === null || applyArgsWithContext === void 0 ? void 0 : applyArgsWithContext(client, capturedContext, args);
            });
            cache[name] = null;
        }
    });
    return newClient;
};

var LOGGER_NAME = 'logger';
createLogger('[LoggerPlugin]');
function LoggerPlugin(client) {
    client.on('send', function (ev) {
    });
}

function IntegrationPlugin(client) {
    client.on('init', function () {
        var nameList = [];
        var config = client.config();
        if (!config || !config.integrations) {
            return;
        }
        config.integrations.forEach(function (integration) {
            if (!arrayIncludes(nameList, integration.name)) {
                nameList.push(integration.name);
                integration.setup(client);
                integration.tearDown && client.on('beforeDestroy', integration.tearDown);
            }
        });
    });
}

function SubjectPlugin(client, globalSubjectMap) {
    var subjectMap = globalSubjectMap || {};
    var initSubject = function (_a) {
        var _b = tslib.__read(_a, 2), subjectKey = _b[0], observer = _b[1];
        if (!subjectMap[subjectKey])
            subjectMap[subjectKey] = createSafeObserver(observer, function () {
                subjectMap[subjectKey] = undefined;
            });
        return subjectMap[subjectKey];
    };
    client.provide('initSubject', initSubject);
    client.provide('getSubject', function (key) { return subjectMap[key]; });
    client.provide('privateSubject', {});
}
/**
 * 由于 Observer 带有自动销毁机制，意味着subject 只支持同步注册并使用
 */
function initSubjectInGlobal(client, args) {
    return client.initSubject(args);
}
/**
 * 此方法不会挂载到全局对象上，同时只支持同步注册并使用
 */
function initPrivateSubject(client, _a, bufferTime) {
    var _b = tslib.__read(_a, 2), subjectKey = _b[0], observer = _b[1];
    var subjectMap = client.privateSubject || {};
    if (!subjectMap[subjectKey])
        subjectMap[subjectKey] = createSafeObserver(observer, function () {
            subjectMap[subjectKey] = undefined;
        }, bufferTime);
    return subjectMap[subjectKey];
}

exports.BUFFER_TIME = BUFFER_TIME;
exports.ContextPlugin = ContextPlugin;
exports.EVENTS = EVENTS;
exports.IntegrationPlugin = IntegrationPlugin;
exports.LOGGER_NAME = LOGGER_NAME;
exports.LoggerPlugin = LoggerPlugin;
exports.SubjectPlugin = SubjectPlugin;
exports.applyBufferTimer = applyBufferTimer;
exports.applyRecord = applyRecord;
exports.arrayIncludes = arrayIncludes;
exports.arrayRemove = arrayRemove;
exports.camelToKebab = camelToKebab;
exports.cloneArray = cloneArray;
exports.createBaseConfigManager = createBaseConfigManager;
exports.createBatchSender = createBatchSender;
exports.createClient = createClient;
exports.createContextAgent = createContextAgent;
exports.createLogger = createLogger;
exports.createMergeConfigManager = createMergeConfigManager;
exports.createSafeObserver = createSafeObserver;
exports.directBuilder = directBuilder;
exports.error = error;
exports.filterObjectValueBy = filterObjectValueBy;
exports.getRegexp = getRegexp;
exports.hasKey = hasKey;
exports.hookMethodDangerously = hookMethodDangerously;
exports.hookObjectProperty = hookObjectProperty;
exports.id = id;
exports.initPrivateSubject = initPrivateSubject;
exports.initSubjectInGlobal = initSubjectInGlobal;
exports.isArray = isArray;
exports.isBoolean = isBoolean;
exports.isEqual = isEqual;
exports.isEqualArray = isEqualArray;
exports.isEqualPlainObject = isEqualPlainObject;
exports.isError = isError;
exports.isErrorEvent = isErrorEvent;
exports.isEvent = isEvent;
exports.isFunction = isFunction;
exports.isHitByRandom = isHitByRandom;
exports.isHitBySampleRate = isHitBySampleRate;
exports.isInstanceOf = isInstanceOf;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isPlainObject = isPlainObject;
exports.isPromiseRejectionEvent = isPromiseRejectionEvent;
exports.isString = isString;
exports.joinQueryWithMap = joinQueryWithMap;
exports.joinRegExp = joinRegExp;
exports.log = log;
exports.mergeDeepConcatArray = mergeDeepConcatArray;
exports.mergeDeepCopyArray = mergeDeepCopyArray;
exports.nextLink = nextLink;
exports.noop = noop;
exports.noopBuilder = noopBuilder;
exports.noopSender = noopSender;
exports.objectForIn = objectForIn;
exports.omit = omit;
exports.pick = pick;
exports.runProcessors = runProcessors;
exports.safeCall = safeCall;
exports.safeCallOrGet = safeCallOrGet;
exports.safeJoin = safeJoin;
exports.safeSet = safeSet;
exports.safeStringify = safeStringify;
exports.safeVisit = safeVisit;
exports.stringifyBatch = stringifyBatch;
exports.toObservable = toObservable;
exports.uuid = uuid;
exports.warn = warn;
exports.withCommandArray = withCommandArray;
//# sourceMappingURL=index.cjs.js.map
