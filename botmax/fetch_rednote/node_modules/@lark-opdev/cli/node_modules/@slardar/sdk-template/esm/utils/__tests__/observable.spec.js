import { __awaiter, __generator, __read } from "tslib";
import test from 'ava';
import sinon from 'sinon';
import { nextLink, toObservable, createSafeObserver } from '../observable';
test('nextLink', function (t) {
    var firstNext = sinon.spy();
    var secondNext = sinon.spy();
    var thridNext = sinon.spy();
    var next = function (args) {
        firstNext(args);
        return function (brgs) {
            secondNext(brgs);
            return function (crgs) {
                thridNext(crgs);
            };
        };
    };
    var a = nextLink('1', [next]);
    t.assert(firstNext.calledOnce);
    t.is(firstNext.args[0][0], '1');
    t.assert(secondNext.notCalled);
    var b = nextLink(2, [a]);
    t.assert(firstNext.calledOnce);
    t.assert(secondNext.calledOnce);
    t.is(secondNext.args[0][0], 2);
    t.assert(thridNext.notCalled);
    nextLink(['3'], [b]);
    t.assert(firstNext.calledOnce);
    t.assert(secondNext.calledOnce);
    t.assert(thridNext.calledOnce);
    t.deepEqual(thridNext.args[0][0], ['3']);
});
test('toObservable', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var observableA, subscriber, subscriber2, completeCb, disconnect, unsubscribe2;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                observableA = toObservable(0);
                subscriber = sinon.spy();
                subscriber2 = sinon.spy();
                completeCb = sinon.spy();
                disconnect = sinon.spy();
                // subscribe
                observableA.subscribe(subscriber);
                unsubscribe2 = observableA.subscribe(subscriber2);
                observableA.next('1');
                t.assert(subscriber.calledOnce);
                t.is(subscriber.args[0][0], '1');
                observableA.next('2');
                t.assert(subscriber.calledTwice);
                t.is(subscriber.args[1][0], '2');
                // complete
                observableA.complete(completeCb);
                // disconnect
                observableA.attach(disconnect);
                observableA.unsubscribe(subscriber);
                // eslint-disable-next-line compat/compat
                return [4 /*yield*/, new Promise(function (resolve) {
                        setTimeout(function () {
                            t.assert(disconnect.notCalled);
                            t.assert(completeCb.notCalled);
                            resolve(true);
                        }, 1);
                    })];
            case 1:
                // eslint-disable-next-line compat/compat
                _a.sent();
                observableA.next('3');
                t.assert(subscriber.calledTwice);
                t.assert(subscriber2.calledThrice);
                t.is(subscriber2.args[2][0], '3');
                unsubscribe2();
                // eslint-disable-next-line compat/compat
                return [4 /*yield*/, new Promise(function (resolve) {
                        setTimeout(function () {
                            t.assert(disconnect.calledOnce);
                            t.assert(completeCb.calledOnce);
                            resolve(true);
                        }, 1);
                    })];
            case 2:
                // eslint-disable-next-line compat/compat
                _a.sent();
                observableA.next('4');
                t.assert(subscriber2.calledThrice);
                return [2 /*return*/];
        }
    });
}); });
test('createSafeObserver', function (t) {
    var subscriber = sinon.spy();
    var subscriber2 = sinon.spy();
    var disconnectCb = sinon.spy();
    var fakeNext;
    var observer = function (next, disconnect) {
        disconnect(disconnectCb);
        fakeNext = next;
    };
    var _a = __read(createSafeObserver(observer), 2), subscribe = _a[0], unsubscribe = _a[1];
    subscribe(subscriber);
    fakeNext(1);
    t.assert(subscriber.calledOnce);
    fakeNext(2);
    t.assert(subscriber.calledTwice);
    t.is(subscriber.args[1][0], 2);
    unsubscribe(subscriber);
    fakeNext(3);
    t.assert(subscriber.calledTwice);
    t.assert(subscriber2.notCalled);
    subscribe(subscriber2);
    fakeNext(4);
    t.assert(subscriber2.calledOnce);
    t.is(subscriber2.args[0][0], 4);
});
//# sourceMappingURL=observable.spec.js.map