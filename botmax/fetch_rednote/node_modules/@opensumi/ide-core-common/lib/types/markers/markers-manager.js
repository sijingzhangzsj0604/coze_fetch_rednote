"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarkerManager = exports.MarkerStats = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@opensumi/di");
const ide_utils_1 = require("@opensumi/ide-utils");
const event_bus_1 = require("../../event-bus");
const markers_1 = require("./markers");
const markers_2 = require("./markers");
const { isFalsyOrEmpty } = ide_utils_1.arrays;
class MarkerStats {
    constructor(manager) {
        this.errors = 0;
        this.infos = 0;
        this.warnings = 0;
        this.unknowns = 0;
        this._data = Object.create(null);
        this._manager = manager;
        this._subscription = manager.onMarkerChanged(this._update, this);
    }
    dispose() {
        this._subscription.dispose();
        this._data = undefined;
    }
    _update(resources) {
        if (!this._data) {
            return;
        }
        for (const resource of resources) {
            const key = resource.toString();
            const oldStats = this._data[key];
            if (oldStats) {
                this._substract(oldStats);
            }
            const newStats = this._resourceStats(resource);
            this._add(newStats);
            this._data[key] = newStats;
        }
    }
    _resourceStats(resource) {
        const result = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };
        const markers = this._manager.getMarkers({ resource, opened: true });
        for (const { severity } of markers) {
            if (severity === markers_2.MarkerSeverity.Error) {
                result.errors += 1;
            }
            else if (severity === markers_2.MarkerSeverity.Warning) {
                result.warnings += 1;
            }
            else if (severity === markers_2.MarkerSeverity.Info) {
                result.infos += 1;
            }
            else {
                // Hint
                result.unknowns += 1;
            }
        }
        return result;
    }
    _substract(op) {
        this.errors -= op.errors;
        this.warnings -= op.warnings;
        this.infos -= op.infos;
        this.unknowns -= op.unknowns;
    }
    _add(op) {
        this.errors += op.errors;
        this.warnings += op.warnings;
        this.infos += op.infos;
        this.unknowns += op.unknowns;
    }
}
exports.MarkerStats = MarkerStats;
let MarkerManager = class MarkerManager extends event_bus_1.WithEventBus {
    constructor() {
        super();
        // 所有Marker
        this._byResource = Object.create(null);
        this._byType = Object.create(null);
        this._byResourceCloseCache = Object.create(null);
        this._openedResource = new Set();
        // marker 变更 事件
        this.onMarkerChangedEmitter = new ide_utils_1.Emitter();
        this.onMarkerChanged = this.onMarkerChangedEmitter.event;
        this.addDispose([(this._stats = new MarkerStats(this)), this.onMarkerChangedEmitter]);
    }
    /**
     * 接受Diagnostics信息，更新marker
     * @param type marker 类型，比如 typescript, eslint等
     * @param uri marker 资源
     * @param rawMarkers 来源于diagnostics的原始marker信息
     */
    updateMarkers(type, uri, rawMarkers) {
        if (isFalsyOrEmpty(rawMarkers)) {
            // remove marker for this (owner,resource)-tuple
            const a = markers_1.MapMap.remove(this._byResource, uri, type);
            const b = markers_1.MapMap.remove(this._byType, type, uri);
            if (a !== b) {
                throw new Error('invalid marker service state');
            }
            if (a && b) {
                this.onMarkerChangedEmitter.fire([uri]);
            }
        }
        else {
            // insert marker for this (owner,resource)-tuple
            const markers = [];
            for (const data of rawMarkers) {
                const marker = this.convertToMarker(type, uri, data);
                if (marker) {
                    markers.push(marker);
                }
            }
            markers_1.MapMap.set(this._byResource, uri, type, markers);
            markers_1.MapMap.set(this._byType, type, uri, markers);
            this.onMarkerChangedEmitter.fire([uri]);
        }
    }
    /**
     * Marker数据类型转换
     * @param type marker类型
     * @param resource 资源uri
     * @param data marker数据
     */
    convertToMarker(type, resource, data) {
        const { message } = data;
        if (!message) {
            return undefined;
        }
        let { startLineNumber, startColumn, endLineNumber, endColumn } = data;
        // santize data
        // marker 的 startLineNumber 等是 1-base 的
        startLineNumber = startLineNumber > 0 ? startLineNumber : 1;
        startColumn = startColumn > 0 ? startColumn : 1;
        endLineNumber = endLineNumber >= startLineNumber ? endLineNumber : startLineNumber;
        endColumn = endColumn > 0 ? endColumn : startColumn;
        return Object.assign(Object.assign({}, data), { resource,
            type,
            message,
            startLineNumber,
            startColumn,
            endLineNumber,
            endColumn });
    }
    /**
     * 清空特定类型的marker
     * @param type 消息类型
     */
    clearMarkers(type) {
        const changes = [];
        const map = this._byType[type];
        // remove old marker
        if (map) {
            delete this._byType[type];
            // eslint-disable-next-line guard-for-in
            for (const resource in map) {
                const entry = markers_1.MapMap.get(this._byResource, resource, type);
                if (entry) {
                    // remeber what we remove
                    const [first] = entry;
                    if (first) {
                        changes.push(first.resource);
                    }
                    // actual remove
                    markers_1.MapMap.remove(this._byResource, resource, type);
                }
            }
        }
        this.onMarkerChangedEmitter.fire(changes);
    }
    /**
     * 清空给定uri的所有marker
     * @param resource 资源uri
     */
    clearMarkersOfUri(resource) {
        const map = this._byResource[resource];
        if (map) {
            delete this._byResource[resource];
            // eslint-disable-next-line guard-for-in
            for (const type in map) {
                const entry = markers_1.MapMap.get(this._byType, type, resource);
                if (entry) {
                    // actual remove
                    markers_1.MapMap.remove(this._byType, type, resource);
                }
            }
        }
        this.onMarkerChangedEmitter.fire([resource]);
    }
    /**
     * 根据过滤条件，查询marker列表
     * - type 类型
     * - resource 资源URI
     * - severities 安全等级
     * - take 提取个数
     * - opened 是否过滤打开的
     * @param filter 过滤条件
     */
    getMarkers(filter = Object.create(null)) {
        const { type, resource, severities, opened } = filter;
        let { take } = filter;
        if (!take || take < 0) {
            take = -1;
        }
        if (type && resource) {
            // exactly one owner AND resource
            const data = markers_1.MapMap.get(this._byResource, resource.toString(), type);
            if (!data) {
                return [];
            }
            else {
                const result = [];
                for (const marker of data) {
                    if (this.isTargetMarker(marker, severities, opened)) {
                        const newLen = result.push(marker);
                        if (take > 0 && newLen === take) {
                            break;
                        }
                    }
                }
                return result;
            }
        }
        else if (!type && !resource) {
            // all
            const result = [];
            // eslint-disable-next-line guard-for-in
            for (const key1 in this._byResource) {
                // eslint-disable-next-line guard-for-in
                for (const key2 in this._byResource[key1]) {
                    for (const data of this._byResource[key1][key2]) {
                        if (this.isTargetMarker(data, severities, opened)) {
                            const newLen = result.push(data);
                            if (take > 0 && newLen === take) {
                                return result;
                            }
                        }
                    }
                }
            }
            return result;
        }
        else {
            // of one resource OR owner
            const map = type
                ? this._byType[type]
                : resource
                    ? this._byResource[resource.toString()]
                    : undefined;
            if (!map) {
                return [];
            }
            const result = [];
            // eslint-disable-next-line guard-for-in
            for (const key in map) {
                for (const data of map[key]) {
                    if (this.isTargetMarker(data, severities, opened)) {
                        const newLen = result.push(data);
                        if (take > 0 && newLen === take) {
                            return result;
                        }
                    }
                }
            }
            return result;
        }
    }
    isTargetMarker(marker, severities, visible) {
        const isTargetSeverity = severities === undefined || (severities & marker.severity) === marker.severity;
        const isTargetVisible = visible ? this._openedResource.has(marker.resource) : true;
        return isTargetSeverity && isTargetVisible;
    }
    getResources() {
        return markers_1.MapMap.keys(this._byResource);
    }
    getStats() {
        return this._stats;
    }
    onEditorGroupOpen(resource) {
        this._openedResource.add(resource);
        const cacheMap = markers_1.MapMap.removeMap(this._byResourceCloseCache, resource);
        if (cacheMap) {
            markers_1.MapMap.setMap(this._byResource, resource, cacheMap);
            Object.keys(cacheMap).forEach((type) => {
                markers_1.MapMap.set(this._byType, type, resource, cacheMap[type]);
            });
        }
        this.onMarkerChangedEmitter.fire([resource]);
    }
    onEditorGroupClose(resource) {
        this._openedResource.delete(resource);
        const resourceToCache = markers_1.MapMap.getMap(this._byResource, resource);
        if (resourceToCache) {
            markers_1.MapMap.setMap(this._byResourceCloseCache, resource, resourceToCache);
        }
        this.clearMarkersOfUri(resource);
    }
};
MarkerManager = tslib_1.__decorate([
    (0, di_1.Injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], MarkerManager);
exports.MarkerManager = MarkerManager;
//# sourceMappingURL=markers-manager.js.map