import { __assign, __read, __spreadArray } from "tslib";
/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
/* eslint-disable @typescript-eslint/prefer-optional-chain */
/* eslint-disable @typescript-eslint/ban-types */
import { isFunction, hookObjectProperty } from '@slardar/sdk-template';
import { getDefaultBrowser, getDefaultXMLHttpRequest } from '../../utils';
import { normalize } from './util';
export var DEFAULT_EVENT_TARGET = [
    'EventTarget',
    'Window',
    'Node',
    'ApplicationCache',
    'ChannelMergerNode',
    'EventSource',
    'FileReader',
    'HTMLUnknownElement',
    'IDBDatabase',
    'IDBRequest',
    'IDBTransaction',
    'MessagePort',
    'Notification',
    'SVGElementInstance',
    'Screen',
    'TextTrack',
    'TextTrackCue',
    'TextTrackList',
    'WebSocket',
    'Worker',
    'XMLHttpRequest',
    'XMLHttpRequestEventTarget',
    'XMLHttpRequestUpload',
];
export var DEFAULT_TIME_FUNCTION = [
    'setTimeout',
    'setInterval',
    'requestAnimationFrame',
    'requestIdleCallback',
];
export var xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];
var ADD_EVENT_LISTENER = 'addEventListener';
var REMOVE_EVENT_LISTENER = 'removeEventListener';
var DEFAULT_SOURCE_TYPE = 'capture-global';
export var hookGlobalAsync = function (report, window, xhr) {
    if (window === void 0) { window = getDefaultBrowser(); }
    if (xhr === void 0) { xhr = getDefaultXMLHttpRequest(); }
    var restoreFns = [];
    var wrap = function (fn, sourceData) {
        if (!isFunction(fn))
            return fn;
        var source = {
            type: DEFAULT_SOURCE_TYPE,
            data: __assign({}, sourceData),
        };
        var hookFn = (fn._w_ || (fn._w_ = function () {
            try {
                // NOTE: If you are a Slardar user, and you are seeing this stack frame, it
                //       means the Slardar SDK caught an error invoking your application code. This
                //       is expected behavior and NOT indicative of a bug with Slardar SDK.
                return (fn.handleEvent && isFunction(fn.handleEvent) ? fn.handleEvent : fn).apply(this, [].map.call(arguments, function (arg) { return wrap(arg, sourceData); }));
            }
            catch (e) {
                var error = normalize(e);
                error && report({ error: error, source: source });
                throw e;
            }
        }));
        hookFn._hook_ = true;
        return hookFn;
    };
    window && restoreFns.push.apply(restoreFns, __spreadArray([], __read(DEFAULT_TIME_FUNCTION.filter(function (timeFunc) { return window[timeFunc]; }).map(function (timeFunc) {
        return hookObjectProperty(window, timeFunc, function (origin) {
            return function (handler) {
                var params = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    params[_i - 1] = arguments[_i];
                }
                return (origin && origin.call.apply(origin, __spreadArray([this,
                    wrap(handler, {
                        function: timeFunc,
                    })], __read(params), false)));
            };
        }, false)();
    })), false));
    xhr &&
        xhr.prototype &&
        restoreFns.push(hookObjectProperty(xhr.prototype, 'send', function (origin) {
            return function () {
                var _this = this;
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i] = arguments[_i];
                }
                // filter 防御一个 xhr 实例被多次 send 导致 wrap 多次的情况
                xmlHttpRequestProps
                    .filter(function (prop) { return _this[prop] && !_this[prop]._hook_; })
                    .forEach(function (prop) {
                    // never restore xhr instance callback
                    _this[prop] = wrap(_this[prop], { function: prop });
                });
                return origin.apply(this, params);
            };
        }, false)());
    DEFAULT_EVENT_TARGET.forEach(function (target) {
        var proto = window[target] && window[target].prototype;
        if (!proto || !proto[ADD_EVENT_LISTENER]) {
            return;
        }
        restoreFns.push(hookObjectProperty(proto, ADD_EVENT_LISTENER, function (origin) {
            return function (evName, fn, options) {
                try {
                    var handleEventFn = fn.handleEvent;
                    if (isFunction(handleEventFn)) {
                        fn.handleEvent = wrap(handleEventFn, { function: 'handleEvent', target: target });
                    }
                }
                catch (_a) {
                    //
                }
                return origin && origin.call(this, evName, wrap(fn, { function: ADD_EVENT_LISTENER, target: target }), options);
            };
        }, false)());
        restoreFns.push(hookObjectProperty(proto, REMOVE_EVENT_LISTENER, function (origin) {
            return function (eventName, fn, options) {
                if (fn === null || fn === void 0 ? void 0 : fn._w_) {
                    origin.call(this, eventName, fn._w_, options);
                }
                return origin.call(this, eventName, fn, options);
            };
        }, false)());
    });
    return restoreFns;
};
//# sourceMappingURL=capture-global.js.map