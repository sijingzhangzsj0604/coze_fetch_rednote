import { __read } from "tslib";
import { noop } from '@slardar/sdk-template';
import { applyPerformanceObserver, getDefaultPerformanceObserver, onceHidden } from '../../../utils';
import { initMetric } from '../util';
export var CLSMonitorMetricName = 'cls';
var LS = 'layout-shift';
export var applyHandleEntries = function () {
    var sessionValue = 0;
    var sessionTimes = [];
    var resetSessionValue = function () {
        sessionValue = 0;
    };
    var handleEntriesWithMetric = function (callback, entry) {
        // Only count layout shifts without recent user input.
        if (!entry.hadRecentInput) {
            var firstSessionTime = sessionTimes[0];
            var lastSessionTime = sessionTimes[sessionTimes.length - 1];
            if (sessionValue && entry.startTime - lastSessionTime < 1000 && entry.startTime - firstSessionTime < 5000) {
                sessionValue += entry.value;
                sessionTimes.push(entry.startTime);
            }
            else {
                sessionValue = entry.value;
                sessionTimes = [entry.startTime];
            }
            callback(sessionValue);
        }
    };
    return [resetSessionValue, handleEntriesWithMetric];
};
export var CLSMonitor = function (PerformanceObserver) {
    if (PerformanceObserver === void 0) { PerformanceObserver = getDefaultPerformanceObserver(); }
    return function (props, cb) {
        var _a = __read(props, 1), precollect = _a[0];
        var metric = initMetric(CLSMonitorMetricName, 0);
        if (!PerformanceObserver) {
            metric.isSupport = false;
            return [function () { return cb && cb(metric); }, noop];
        }
        var _b = __read(applyHandleEntries(), 2), resetSessionValue = _b[0], handleEntriesWithMetric = _b[1];
        var handleEntries = handleEntriesWithMetric.bind(null, function (sessionValue) {
            // If the current session value is larger than the current CLS value, update CLS and the entries contributing to it.
            sessionValue > metric.value && (metric.value = sessionValue);
        });
        (precollect.entries || []).forEach(function (entry) {
            entry.entryType === LS && handleEntries(entry);
        });
        var _c = __read(applyPerformanceObserver(PerformanceObserver, handleEntries), 2), observe = _c[0], disconnect = _c[1];
        observe(LS);
        onceHidden(function () {
            resetSessionValue();
        }, false);
        return [
            function () {
                cb && cb(metric);
                resetSessionValue();
                metric = initMetric(CLSMonitorMetricName, 0);
            },
            disconnect,
        ];
    };
};
//# sourceMappingURL=index.js.map