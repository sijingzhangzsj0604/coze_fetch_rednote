import { __read, __spreadArray } from "tslib";
import { getRegexp } from '@slardar/sdk-template';
import { hookGlobalAsync } from './capture-global';
import { dedupe } from './dedupe';
import { normalizeError, normalizeException, normalizeUnknownError } from './util';
export var JS_ERROR_EV_TYPE = 'js_error';
export var jsErrorGetterWithContext = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 2), errorObserver = _b[0], promiseRejectionObserver = _b[1];
    var ignoreErrors = config.ignoreErrors, onerror = config.onerror, onunhandledrejection = config.onunhandledrejection, dedupeFlag = config.dedupe, captureGlobalAsync = config.captureGlobalAsync;
    var ignoreRegExp = getRegexp(ignoreErrors);
    var dedupeFn = dedupe();
    var reportJsError = function (_a) {
        var error = _a.error, extra = _a.extra, react = _a.react, source = _a.source;
        var err = dedupeFlag ? dedupeFn(error) : error;
        if (!err || (ignoreRegExp && ignoreRegExp.test(err.message))) {
            return;
        }
        report({
            ev_type: JS_ERROR_EV_TYPE,
            payload: {
                error: err,
                breadcrumbs: [],
                extra: extra,
                react: react,
                source: source,
            },
        });
    };
    onerror &&
        tearDownGroup.push(errorObserver[0](function (ev) { return reportJsError({ error: normalizeError(ev), source: { type: 'onerror' } }); }));
    onunhandledrejection &&
        tearDownGroup.push(promiseRejectionObserver[0](function (ev) {
            return reportJsError({ error: normalizeException(ev), source: { type: 'onunhandledrejection' } });
        }));
    captureGlobalAsync && tearDownGroup.push.apply(tearDownGroup, __spreadArray([], __read(hookGlobalAsync(reportJsError)), false));
    return function (err, extra, react) {
        return reportJsError({ error: normalizeUnknownError(err), extra: extra, react: react, source: { type: 'manual' } });
    };
};
//# sourceMappingURL=index.js.map