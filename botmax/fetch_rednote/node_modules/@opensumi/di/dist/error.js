"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.aliasCircularError = exports.circularError = exports.noInjectorError = exports.tokenInvalidError = exports.notInjectError = exports.noInjectableError = exports.tagOnlyError = exports.noProviderError = void 0;
function stringify(target) {
    if (typeof target === 'object') {
        return target.constructor.name;
    }
    else if (typeof target === 'function') {
        return target.name;
    }
    else {
        return String(target);
    }
}
function noProviderError() {
    var tokens = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        tokens[_i] = arguments[_i];
    }
    return new Error("Cannot find Provider of ".concat(tokens.map(function (t) { return stringify(t); }).join(', ')));
}
exports.noProviderError = noProviderError;
function tagOnlyError(expectTag, currentTag) {
    return new Error("Expect creating class in Injector with tag: ".concat(expectTag, ", but current: ").concat(currentTag, "."));
}
exports.tagOnlyError = tagOnlyError;
function noInjectableError(target) {
    return new Error("Target ".concat(stringify(target), " has not decorated by Injectable. Maybe you have multiple packages installed."));
}
exports.noInjectableError = noInjectableError;
function notInjectError(target, index) {
    return new Error("The ".concat(index, "th constructor parameter of ").concat(stringify(target), " has not decorated by `Inject`, or maybe you want to set `multiple` in the Injectable decorator."));
}
exports.notInjectError = notInjectError;
function tokenInvalidError(target, key, token) {
    var tokenType = String(token);
    var reason = '(1) Please check your `tsconfig.json` to enable `emitDecoratorMetadata` and `experimentalDecorators`. (2) Has not defined token cause TS compiled to Object. (3) Has circular dependencies cause reading property error.';
    return new Error("Autowired error: The type of property ".concat(String(key), " of ").concat(stringify(target), " is unsupported. Allowed type: string/symbol/function, but received \"").concat(tokenType, "\". ").concat(reason));
}
exports.tokenInvalidError = tokenInvalidError;
function noInjectorError(target) {
    return new Error("Cannot find the Injector of ".concat(stringify(target)));
}
exports.noInjectorError = noInjectorError;
function circularError(target, ctx) {
    var tokenTrace = [];
    var current = ctx;
    while (current) {
        tokenTrace.push(stringify(current.token));
        current = current.parent;
    }
    var traceResult = tokenTrace.reverse().join(' > ');
    return new Error("Detected circular dependencies when creating ".concat(stringify(target), ". ") + traceResult);
}
exports.circularError = circularError;
function aliasCircularError(paths, current) {
    return new Error("useAlias registration cycle detected! ".concat(__spreadArray(__spreadArray([], __read(paths), false), [current], false).map(function (v) { return stringify(v); }).join(' -> ')));
}
exports.aliasCircularError = aliasCircularError;
