"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandServiceImpl = exports.CommandRegistryImpl = exports.CoreCommandRegistryImpl = exports.HANDLER_NOT_FOUND = exports.CommandRegistry = exports.CommandService = exports.CommandContribution = exports.Command = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@opensumi/di");
const ide_utils_1 = require("@opensumi/ide-utils");
const contribution_provider_1 = require("./contribution-provider");
const localize_1 = require("./localize");
const log_1 = require("./log");
/**
 * Command 的工具方法
 */
var Command;
(function (Command) {
    /**
     * 判断是否是命令
     * @param arg 要判断的对象
     */
    function is(arg) {
        return !!arg && arg === Object(arg) && 'id' in arg;
    }
    Command.is = is;
    /**
     * 比较两个命令是否相等
     * 用于命令面板的排序
     * @param a 待比较的命令
     * @param b 待比较的命令
     */
    function compareCommands(a, b) {
        if (a.label && b.label) {
            const aCommand = a.category ? a.category + a.label : a.label;
            const bCommand = b.category ? b.category + b.label : b.label;
            return aCommand.localeCompare(bCommand);
        }
        else {
            return 0;
        }
    }
    Command.compareCommands = compareCommands;
})(Command = exports.Command || (exports.Command = {}));
exports.CommandContribution = Symbol('CommandContribution');
exports.CommandService = Symbol('CommandService');
exports.CommandRegistry = Symbol('CommandRegistry');
exports.HANDLER_NOT_FOUND = 'HANDLER_NOT_FOUND';
// 不带 contribution 的 CommandRegistry
let CoreCommandRegistryImpl = class CoreCommandRegistryImpl {
    constructor() {
        this._commands = {};
        this._handlers = {};
        this.unregisterCommands = new Map();
        // 最近执行的命令列表
        this._recent = [];
        this.preCommandInterceptors = [];
        this.postCommandInterceptors = [];
        this.preCommandInterceptorMap = new Map();
        this.postCommandInterceptor = new Map();
        this.logger = (0, log_1.getDebugLogger)();
    }
    /**
     * 命令执行方法
     * @param commandId 命令执行方法
     * @param args
     */
    async executeCommand(commandId, ...args) {
        const command = this.getCommand(commandId);
        // 执行代理命令。即该命令是另一个命令的 alias，这里转为执行真实的命令
        if (command && command.delegate) {
            return this.executeCommand(command.delegate, ...args);
        }
        // 把 before 在 handler 判断前置，对于 onCommand 激活的插件如果没有在 contributes 配置，那么 handler 是不存在的，也就无法激活
        // 如 node debug 插件 https://github.com/microsoft/vscode-node-debug/blob/main/package.json
        const _preCommandInterceptor = this.preCommandInterceptorMap.get(commandId);
        const preInterceptorWrapper = (_preCommandInterceptor !== null && _preCommandInterceptor !== void 0 ? _preCommandInterceptor : []).map((cb) => (_, args) => cb(args));
        const currentPreInterceptors = [...preInterceptorWrapper, ...this.preCommandInterceptors];
        for (const preInterceptor of currentPreInterceptors) {
            const result = await preInterceptor(commandId, args);
            if (result === false) {
                this.logger.log(`command ${commandId} is prevented by pre interceptor`, preInterceptor.name);
                return undefined;
            }
            else if (Array.isArray(result)) {
                args = result;
            }
        }
        const handler = this.getActiveHandler(commandId, ...args);
        if (handler) {
            let result = await handler.execute(...args);
            const commandInterceptor = this.postCommandInterceptor.get(commandId);
            if (commandInterceptor) {
                for (const postInterceptor of commandInterceptor) {
                    result = await postInterceptor(result);
                }
            }
            for (const postCommand of this.postCommandInterceptors) {
                result = await postCommand(commandId, result);
            }
            return result;
        }
        let argsMessage = '';
        try {
            argsMessage = args && args.length > 0 ? ` (args: ${JSON.stringify(args)})` : '';
        }
        catch (e) {
            argsMessage = 'args cannot be convert to JSON';
        }
        const err = new Error(`The command '${commandId}' cannot be executed. There are no active handlers available for the command.${argsMessage}`);
        err.name = `${exports.HANDLER_NOT_FOUND}:${commandId}`;
        throw err;
    }
    /**
     * 获取所有命令
     */
    getCommands() {
        return Object.keys(this._commands).map((id) => this.getCommand(id));
    }
    /**
     * 注册命令，命令不能重复注册
     * @param command
     * @param handler
     * @returns 命令销毁函数
     */
    registerCommand(command, handler) {
        if (this._commands[command.id]) {
            this.logger.warn(`A command ${command.id} is already registered.`);
            return ide_utils_1.Disposable.NULL;
        }
        const toDispose = new ide_utils_1.Disposable();
        // 添加命令的销毁函数
        toDispose.addDispose(this.doRegisterCommand(command));
        if (handler) {
            // 添加处理函数的销毁函数
            toDispose.addDispose(this.registerHandler(command.id, handler));
        }
        // 添加解绑时的销毁逻辑
        this.unregisterCommands.set(command.id, toDispose);
        toDispose.addDispose(ide_utils_1.Disposable.create(() => this.unregisterCommands.delete(command.id)));
        return toDispose;
    }
    /**
     * 有时候我们需要在命令注册后才更新其描述。
     *
     * 比如说我们会为所有的 ContainerId 注册 Toggle Panel 的命令，但我们不想在 QuickOpen 中展示所有 ContainerId 对应的命令
     * 这个时候我们可以先注册所有命令，然后再更新所有 Command 的描述
     * @param id 命令 ID
     * @param command
     */
    updateCommandDetailById(id, command) {
        if (!this._commands[id]) {
            this.logger.warn(`Command ${id} not found.`);
            return;
        }
        this._commands[id] = Object.assign(Object.assign({}, this._commands[id]), command);
    }
    /**
     * 解绑命令
     * @param id 命令 id
     */
    unregisterCommand(commandOrId) {
        const id = Command.is(commandOrId) ? commandOrId.id : commandOrId;
        const unregisterCommand = this.unregisterCommands.get(id);
        if (unregisterCommand) {
            unregisterCommand.dispose();
        }
    }
    /**
     * 给命令注册处理函数
     * 可以给命令加多个处理函数
     * 默认后面注册的优先级更高
     * @param commandId 要添加的命令 id
     * @param handler 要添加的处理函数
     * @returns 销毁函数
     */
    registerHandler(commandId, handler) {
        let handlers = this._handlers[commandId];
        if (!handlers) {
            this._handlers[commandId] = handlers = [];
        }
        handlers.unshift(handler);
        return {
            dispose: () => {
                const idx = handlers.indexOf(handler);
                if (idx >= 0) {
                    handlers.splice(idx, 1);
                }
            },
        };
    }
    /**
     * 判断命令是否启用
     * @param commandId 命令 id
     * @param args 传递参数
     */
    isEnabled(command, ...args) {
        if (!this._handlers[command]) {
            // 对于插件package.json中注册的command，会没有handler，
            // 但是它应该可用，这样才能让插件在未启动的情况下点击菜单
            return true;
        }
        return this.getActiveHandler(command, ...args) !== undefined;
    }
    /**
     * 判断命令是否可见
     * @param commandId 命令 id
     * @param args 传递参数
     */
    isVisible(command, ...args) {
        if (!this._handlers[command]) {
            // 对于插件package.json中注册的command，会没有handler，
            // 但是它应该可见，这样才能让插件在未启动的情况下显示菜单
            return true;
        }
        return this.getVisibleHandler(command, ...args) !== undefined;
    }
    /**
     * 是否可切换
     * 主要给菜单使用
     * @param commandId 命令 id
     * @param args 传递参数
     */
    isToggled(command, ...args) {
        const handler = this.getToggledHandler(command);
        return handler && handler.isToggled ? handler.isToggled(...args) : false;
    }
    /**
     * 获取可见的命令处理函数
     * @param commandId 命令 id
     * @param args 传递参数
     */
    getVisibleHandler(commandId, ...args) {
        const handlers = this._handlers[commandId];
        if (handlers) {
            for (const handler of handlers) {
                if (!handler.isVisible || handler.isVisible(...args)) {
                    return handler;
                }
            }
        }
        return undefined;
    }
    /**
     * 获取启用的命令处理函数
     * @param commandId 命令 id
     * @param args
     */
    getActiveHandler(commandId, ...args) {
        const command = this.getCommand(commandId);
        if (command && command.delegate) {
            return this.getActiveHandler(command.delegate, ...args);
        }
        const handlers = this._handlers[commandId];
        if (handlers) {
            for (const handler of handlers) {
                if (!handler.isEnabled || handler.isEnabled(...args)) {
                    return handler;
                }
            }
        }
        return undefined;
    }
    /**
     * 获取鉴过权的命令处理函数
     * @param commandId 命令 id
     * @param extensionInfo 插件的主要属性
     * @param args 命令其他参数
     */
    isPermittedCommand(commandId, extensionInfo, ...args) {
        const command = this.getCommand(commandId);
        if (command && command.delegate) {
            return this.isPermittedCommand(command.delegate, extensionInfo, ...args);
        }
        const handlers = this._handlers[commandId];
        return (!Array.isArray(handlers) ||
            handlers.every((handler) => !handler.isPermitted || handler.isPermitted(extensionInfo, ...args)));
    }
    /**
     * 获取可切换的命令处理函数
     * @param commandId 命令 id
     */
    getToggledHandler(commandId) {
        const handlers = this._handlers[commandId];
        if (handlers) {
            for (const handler of handlers) {
                if (handler.isToggled) {
                    return handler;
                }
            }
        }
        return undefined;
    }
    /**
     * 解决语言包未加载时注册命令时没有 label/category 的场景
     * 使用方需要自定处理 i18n 问题
     */
    getRawCommand(id) {
        const command = this._commands[id];
        return command;
    }
    /**
     * 通过命令 id 获取命令
     * @param commandId 命令 id
     */
    getCommand(id) {
        const command = this._commands[id];
        return command
            ? Object.assign(Object.assign({}, command), { label: (0, localize_1.replaceLocalizePlaceholder)(command.label), category: (0, localize_1.replaceLocalizePlaceholder)(command.category) }) : undefined;
    }
    localizeCommand(command) {
        if (command.label && !command.labelLocalized) {
            command.labelLocalized = (0, localize_1.createLocalizedStr)(command.label);
        }
        if (command.category && !command.categoryLocalized) {
            command.categoryLocalized = (0, localize_1.createLocalizedStr)(command.category);
        }
        if (command.shortLabel && !command.shortLabelLocalized) {
            command.shortLabelLocalized = (0, localize_1.createLocalizedStr)(command.shortLabel);
        }
        return command;
    }
    /**
     * 给命令添加销毁函数
     * @param command 要添加销毁函数的命令
     */
    doRegisterCommand(command) {
        this._commands[command.id] = this.localizeCommand(command);
        return {
            dispose: () => {
                delete this._commands[command.id];
            },
        };
    }
    beforeExecuteCommand(interceptor, interceptorFunc) {
        if (typeof interceptor === 'string') {
            const commandInterceptor = this.preCommandInterceptorMap.get(interceptor);
            if (commandInterceptor) {
                interceptorFunc && commandInterceptor.push(interceptorFunc);
            }
            else {
                interceptorFunc && this.preCommandInterceptorMap.set(interceptor, [interceptorFunc]);
            }
            return {
                dispose: () => {
                    const commandInterceptor = this.preCommandInterceptorMap.get(interceptor);
                    if (commandInterceptor && interceptorFunc) {
                        const index = commandInterceptor.indexOf(interceptorFunc);
                        if (index !== -1) {
                            commandInterceptor.splice(index, 1);
                        }
                    }
                },
            };
        }
        else {
            this.preCommandInterceptors.push(interceptor);
            return {
                dispose: () => {
                    const index = this.preCommandInterceptors.indexOf(interceptor);
                    if (index !== -1) {
                        this.preCommandInterceptors.splice(index, 1);
                    }
                },
            };
        }
    }
    afterExecuteCommand(interceptor, result) {
        if (typeof interceptor === 'string') {
            const commandInterceptor = this.postCommandInterceptor.get(interceptor);
            if (commandInterceptor) {
                result && commandInterceptor.push(result);
            }
            else {
                result && this.postCommandInterceptor.set(interceptor, [result]);
            }
            return {
                dispose: () => {
                    const commandInterceptor = this.postCommandInterceptor.get(interceptor);
                    if (commandInterceptor && result) {
                        const index = commandInterceptor.indexOf(result);
                        if (index !== -1) {
                            commandInterceptor.splice(index, 1);
                        }
                    }
                },
            };
        }
        else {
            this.postCommandInterceptors.push(interceptor);
            return {
                dispose: () => {
                    const index = this.postCommandInterceptors.indexOf(interceptor);
                    if (index !== -1) {
                        this.postCommandInterceptors.splice(index, 1);
                    }
                },
            };
        }
    }
    /**
     * 获取最近使用的命令列表
     */
    getRecentCommands() {
        return this._recent;
    }
    /**
     * 获取最近使用的命令列表
     */
    setRecentCommands(commands) {
        commands.forEach((command) => {
            this.addRecentCommand(command);
        });
        return this._recent;
    }
    /**
     * 添加一个命令到最近使用列表中
     * @param recent 待添加的命令
     */
    addRecentCommand(recent) {
        if (!recent || !recent.label) {
            return; // 某些情况会报错
        }
        // 确定命令当前是否存在于最近使用的列表中
        const index = this._recent.findIndex((command) => command.id === recent.id);
        // 如果已经存在，则从最近使用的列表中删除
        if (index >= 0) {
            this._recent.splice(index, 1);
        }
        // 将这个命令添加到最近使用的列表的第一位
        this._recent.unshift(recent);
    }
};
CoreCommandRegistryImpl = tslib_1.__decorate([
    (0, di_1.Injectable)()
], CoreCommandRegistryImpl);
exports.CoreCommandRegistryImpl = CoreCommandRegistryImpl;
let CommandRegistryImpl = class CommandRegistryImpl extends CoreCommandRegistryImpl {
    /**
     * 执行 CommandContribution 的注册方法
     */
    initialize() {
        const contributions = this.contributionProvider.getContributions();
        for (const contrib of contributions) {
            contrib.registerCommands(this);
        }
    }
};
tslib_1.__decorate([
    (0, di_1.Autowired)(exports.CommandContribution),
    tslib_1.__metadata("design:type", Object)
], CommandRegistryImpl.prototype, "contributionProvider", void 0);
CommandRegistryImpl = tslib_1.__decorate([
    (0, di_1.Injectable)()
], CommandRegistryImpl);
exports.CommandRegistryImpl = CommandRegistryImpl;
let CommandServiceImpl = class CommandServiceImpl {
    constructor() {
        this._onWillExecuteCommand = new ide_utils_1.Emitter();
        this.onWillExecuteCommand = this._onWillExecuteCommand.event;
        this._onDidExecuteCommand = new ide_utils_1.Emitter();
        this.onDidExecuteCommand = this._onDidExecuteCommand.event;
    }
    executeCommand(commandId, ...args) {
        this._onWillExecuteCommand.fire({ commandId, args });
        const result = this.commandRegistry.executeCommand(commandId, ...args).finally(() => {
            this._onDidExecuteCommand.fire({ commandId, args });
        });
        return Promise.resolve(result);
    }
    async tryExecuteCommand(commandId, ...args) {
        try {
            return await this.executeCommand(commandId, ...args);
        }
        catch (err) {
            // no-op: failed when command not found
            (0, log_1.getDebugLogger)().warn(err);
        }
    }
};
tslib_1.__decorate([
    (0, di_1.Autowired)(exports.CommandRegistry),
    tslib_1.__metadata("design:type", CommandRegistryImpl)
], CommandServiceImpl.prototype, "commandRegistry", void 0);
CommandServiceImpl = tslib_1.__decorate([
    (0, di_1.Injectable)()
], CommandServiceImpl);
exports.CommandServiceImpl = CommandServiceImpl;
//# sourceMappingURL=command.js.map