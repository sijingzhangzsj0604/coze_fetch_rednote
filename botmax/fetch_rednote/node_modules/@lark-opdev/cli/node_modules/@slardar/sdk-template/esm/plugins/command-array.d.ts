import { AnyClient, ClientEvent, ReportEventFromClient, SendEventFromClient, UnionToIntersection } from '../types';
export declare type WithCommandArray<C extends AnyClient> = C & GetCommandFunction<C>;
export declare const withCommandArray: <C extends AnyClient, CapturedContext>(client: C, captureContext?: ((c: C) => CapturedContext) | undefined, applyArgsWithContext?: ((c: C, ctx: CapturedContext, args: any[]) => void) | undefined) => WithCommandArray<C>;
declare type PropertyToFunction<C extends Record<string, any>, P extends keyof C> = P extends infer K ? K extends keyof C ? C[K] extends (...args: any) => any ? (m: K, ...args: Parameters<C[K]>) => ReturnType<C[K]> : C[K] extends ((...args: any) => any) | undefined ? (m: K, ...args: Parameters<NonNullable<C[K]>>) => ReturnType<NonNullable<C[K]>> | undefined : (m: K) => C[K] : never : never;
declare type Event<C extends AnyClient> = ClientEvent<ReportEventFromClient<C>, SendEventFromClient<C>, any>;
declare type EventToOnFunctions<Event extends ClientEvent<any, any, any>, T extends keyof Event> = T extends infer K ? K extends keyof Event ? (m: 'on', ev: K, handler: Event[K]) => void : never : never;
declare type EventToOffFunctions<Event extends ClientEvent<any, any, any>, T extends keyof Event> = T extends infer K ? K extends keyof Event ? (m: 'off', ev: K, handler: Event[K]) => void : never : never;
declare type EventFunctions<C extends AnyClient> = EventToOnFunctions<Event<C>, keyof Event<C>> | EventToOffFunctions<Event<C>, keyof Event<C>>;
declare type GetCommandFunction<C extends AnyClient> = Function & UnionToIntersection<PropertyToFunction<C, Exclude<keyof C, 'on' | 'off'>> | EventFunctions<C>>;
export {};
