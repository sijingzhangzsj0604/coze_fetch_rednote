import { __read } from "tslib";
import { getRegexp } from '@slardar/sdk-template';
import { applyMonitor, normalizeUnknownError } from '@slardar/sdk-web';
import { getPluginConfig } from '../utils';
import { dedupe, normalize } from './utils';
export var JS_ERR_PLUGIN_NAME = 'jsError';
export var JS_ERROR_EV_TYPE = 'js_error';
var defaultConfig = {
    ignoreErrors: [],
    uncaughtException: true,
    unhandledRejection: true,
    dedupe: false,
};
export function JsErrorMonitorPlugin(client) {
    client.on('init', function () {
        var config = getPluginConfig(client, JS_ERR_PLUGIN_NAME, defaultConfig);
        if (!config) {
            return;
        }
        var _a = __read(applyMonitor(JsErrorMonitor, config, function (ev) {
            client.report(ev);
        }, [process]), 2), reportJsError = _a[0], tearDown = _a[1];
        client.on('beforeDestroy', tearDown);
        client.provide('captureException', reportJsError);
    });
}
export var JsErrorMonitor = function (_process) {
    if (_process === void 0) { _process = null; }
    if (!_process) {
        return;
    }
    return function (props, cb) {
        var ignoreErrors = props.ignoreErrors, uncaughtException = props.uncaughtException, unhandledRejection = props.unhandledRejection, dedupeFlag = props.dedupe;
        var ignoreRegExp = getRegexp(ignoreErrors);
        var restoreFns = [];
        var dedupeFn = dedupe();
        var report = function (error, extra) {
            var err = dedupeFlag ? dedupeFn(error) : error;
            if (cb && err) {
                if (ignoreRegExp === null || ignoreRegExp === void 0 ? void 0 : ignoreRegExp.test(err.message)) {
                    return;
                }
                cb({
                    ev_type: JS_ERROR_EV_TYPE,
                    payload: {
                        error: err,
                        breadcrumbs: [],
                        extra: extra,
                    },
                });
            }
        };
        if (uncaughtException) {
            var handleError_1 = function (ev) {
                // try{...}catch{...} itself to make sure app doesn't pop up when it exits
                try {
                    report(normalize(ev));
                }
                catch (error) {
                    // ignore
                }
            };
            _process.on('uncaughtException', handleError_1);
            restoreFns.push(function () { return _process.off('uncaughtException', handleError_1); });
        }
        if (unhandledRejection) {
            var handleError_2 = function (ev) { return report(normalize(ev)); };
            _process.on('unhandledRejection', handleError_2);
            restoreFns.push(function () { return _process.off('unhandledRejection', handleError_2); });
        }
        var tearDown = function () {
            restoreFns.forEach(function (fn) { return fn(); });
        };
        return [function (err, extra) { return report(normalizeUnknownError(err), extra); }, tearDown];
    };
};
//# sourceMappingURL=index.js.map