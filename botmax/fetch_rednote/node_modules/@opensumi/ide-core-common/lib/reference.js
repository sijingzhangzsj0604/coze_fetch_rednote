"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ref = exports.ReferenceManager = exports.normalizeFileUrl = void 0;
const ide_utils_1 = require("@opensumi/ide-utils");
function normalizeFileUrl(uri) {
    // 部分情况下可能出现类似 `file:///a//` 的路径，此时需要替换路径中的 `//` 为 `/`
    // 从 `file:///a//b` 规范为 `file:///a/b`
    return uri.replace(/\w+\/\/\w+/gi, (match) => match.replace('//', '/'));
}
exports.normalizeFileUrl = normalizeFileUrl;
class ReferenceManager {
    constructor(factory) {
        this.factory = factory;
        this.instances = new Map();
        this.refs = new Map();
        this._onReferenceAllDisposed = new ide_utils_1.Emitter();
        this._onInstanceCreated = new ide_utils_1.Emitter();
        this.onReferenceAllDisposed = this._onReferenceAllDisposed.event;
        this.onInstanceCreated = this._onInstanceCreated.event;
        this._creating = new Map();
    }
    async getReference(uri, reason) {
        const key = normalizeFileUrl(uri);
        if (!this.instances.has(key)) {
            // 由于创建过程可能为异步，此处标注为 creating， 防止重复创建。
            if (!this._creating.has(key)) {
                const promise = (async () => {
                    const instance = await this.factory(key);
                    this.instances.set(key, instance);
                    this._onInstanceCreated.fire(instance);
                })();
                this._creating.set(key, promise);
            }
            try {
                await this._creating.get(key);
            }
            catch (e) {
                // 出错时需要清除创建中状态
                this._creating.delete(key);
                throw e;
            }
        }
        const ref = this.createRef(key, reason);
        // 需要在 ref 被创建后再结束 creating 状态，否则如果在 onInstanceCreated 事件中触发了 removeRef 至 0,
        // 可能导致 instance 意外被删除。
        if (this._creating.get(key)) {
            const creatingPromise = this._creating.get(key);
            this._creating.delete(key);
            creatingPromise === null || creatingPromise === void 0 ? void 0 : creatingPromise.then(() => {
                // 再触发一次空remove，防止被保护的instance意外残留
                this.removeRef(key, undefined);
            });
        }
        return ref;
    }
    getReferenceIfHasInstance(key, reason) {
        if (this.instances.has(key)) {
            return this.createRef(key, reason);
        }
        return null;
    }
    createRef(key, reason) {
        const instance = this.instances.get(key);
        const ref = new Ref(instance, reason, (reason) => this.createRef(key, reason));
        ref.addDispose({
            dispose: () => {
                this.removeRef(key, ref);
            },
        });
        this.addRef(key, ref);
        return ref;
    }
    addRef(key, ref) {
        if (!this.refs.get(key)) {
            this.refs.set(key, []);
        }
        this.refs.get(key).push(ref);
    }
    removeRef(key, ref) {
        if (this.refs.get(key)) {
            if (ref) {
                const index = this.refs.get(key).indexOf(ref);
                if (index !== -1) {
                    this.refs.get(key).splice(index, 1);
                }
            }
            if (this.refs.get(key).length === 0) {
                if (this._creating.has(key)) {
                    return; // 正在被创建， 进行保护
                }
                this.refs.delete(key);
                this.instances.delete(key);
                this._onReferenceAllDisposed.fire(key);
            }
        }
    }
}
exports.ReferenceManager = ReferenceManager;
class Ref extends ide_utils_1.Disposable {
    constructor(_instance, reason, _clone) {
        super();
        this._instance = _instance;
        this.reason = reason;
        this._clone = _clone;
        this.addDispose({
            dispose: () => {
                this._instance = null;
                this._clone = null;
            },
        });
    }
    get instance() {
        if (this.disposed) {
            throw new Error('Ref has been disposed!');
        }
        return this._instance;
    }
    hold(reason) {
        if (this.disposed) {
            throw new Error('Ref has been disposed!');
        }
        return this._clone(reason);
    }
}
exports.Ref = Ref;
//# sourceMappingURL=reference.js.map