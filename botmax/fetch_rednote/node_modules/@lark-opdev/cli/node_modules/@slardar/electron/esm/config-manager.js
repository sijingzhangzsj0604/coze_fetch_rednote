import { __assign, __read, __spreadArray } from "tslib";
/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
import { log, mergeDeepConcatArray, noop } from '@slardar/sdk-template';
import { parseServerConfig } from './normalize';
import { getSettingsUrl, hasSetStorageItem, setStorageUserIdAndDeviceId } from './utils';
export var configHolder = {
    get: function () {
        return this.__SLARDAR__REPALCE__HOLDER__;
    },
};
export var createElectronConfigManager = function (defaultConfig) {
    // the merged config
    var config = defaultConfig;
    // save it so we know when initConfig is set
    var initConfig;
    // save UserConfig so we can merge with priority
    var userConfig = {};
    // save the original server config, from sdk-server or from get_setting response
    var serverConfig = configHolder.get();
    // cache the parsed ServerConfig, used in merge
    var parsedServerConfig;
    // call when ready to start(with initConfig and serverConfig)
    var onReady = noop;
    // call when config changed
    var onChange = noop;
    return {
        getConfig: function () {
            return config;
        },
        setConfig: function (c) {
            userConfig = __assign(__assign({}, userConfig), (c || {}));
            updateConfig();
            if (!initConfig) {
                log('[configManager] handle initConfig');
                // handle init
                initConfig = c;
                if (config.useLocalConfig || !config.bid) {
                    // when useLocalConfig is true, ignore serverConfig
                    log('[configManager] use localConfig');
                    parsedServerConfig = {};
                    onReady();
                }
                else if (serverConfig) {
                    // check injected serverConfig
                    log('[configManager] use injected serverConfig');
                    handleServerConfig();
                }
                else {
                    // get serverConfig from server
                    log('[configManager] get serverConfig');
                    getServerConfig(config, function (res) {
                        serverConfig = res;
                        handleServerConfig();
                    });
                }
            }
            return config;
        },
        onChange: function (fn) {
            onChange = fn;
        },
        onReady: function (fn) {
            onReady = function () {
                setStorageUserIdAndDeviceId(config);
                fn();
            };
            if (parsedServerConfig) {
                onReady();
            }
        },
    };
    function updateConfig() {
        // merge priority: UserConfig > ServerConfig > CurrentConfig(including default config)
        log('[configManager].updateConfig');
        var newConfig = __assign(__assign(__assign({}, defaultConfig), (parsedServerConfig || {})), userConfig);
        newConfig.plugins = mergeDeepConcatArray(defaultConfig.plugins, (parsedServerConfig === null || parsedServerConfig === void 0 ? void 0 : parsedServerConfig.plugins) || {}, userConfig.plugins || {});
        newConfig.sample = mergeSampleConfig(mergeSampleConfig(defaultConfig.sample, parsedServerConfig === null || parsedServerConfig === void 0 ? void 0 : parsedServerConfig.sample), userConfig.sample);
        config = newConfig;
        onChange();
    }
    function handleServerConfig() {
        log('[configManager].handleServerConfig');
        parsedServerConfig = parseServerConfig(serverConfig);
        // comments from web
        // 兜底处理，如果目前localstorage中有值，则不需要setting下发的从cookie中拿的数据做覆盖
        // 但是仍然需要保留server 返回的userID，当localstorage中没有值时，说明第一次设置还没有生效，需要走正常的覆盖逻辑，不然UV会偏高
        if (hasSetStorageItem(config.bid, config.localDataPath)) {
            parsedServerConfig.userId = defaultConfig.userId;
        }
        updateConfig();
        onReady();
    }
};
export function getServerConfig(config, cb) {
    var transport = config.transport, serverDomain = config.serverDomain, serverPath = config.serverPath, bid = config.bid;
    transport.get({
        url: getSettingsUrl(serverDomain, serverPath) + "?bid=" + bid + "&store=1",
        success: function (res) {
            cb(res.data || {});
        },
        fail: function () {
            cb({ sample: { sample_rate: 0.001 } });
        },
    });
}
export function mergeSampleConfig(a, b) {
    if (!a || !b)
        return a || b;
    var res = __assign(__assign({}, a), b);
    res.include_users = __spreadArray(__spreadArray([], __read((a.include_users || [])), false), __read((b.include_users || [])), false);
    res.rules = __spreadArray(__spreadArray([], __read(Object.keys(a.rules || {})), false), __read(Object.keys(b.rules || {})), false).reduce(function (obj, key) {
        var _a, _b;
        if (!(key in obj)) {
            if (key in (a.rules || {}) && key in (b.rules || {})) {
                obj[key] = __assign(__assign({}, a.rules[key]), b.rules[key]);
                obj[key].conditional_sample_rules = __spreadArray(__spreadArray([], __read((a.rules[key].conditional_sample_rules || [])), false), __read((b.rules[key].conditional_sample_rules || [])), false);
            }
            else {
                obj[key] = ((_a = a.rules) === null || _a === void 0 ? void 0 : _a[key]) || ((_b = b.rules) === null || _b === void 0 ? void 0 : _b[key]);
            }
        }
        return obj;
    }, {});
    return res;
}
//# sourceMappingURL=config-manager.js.map