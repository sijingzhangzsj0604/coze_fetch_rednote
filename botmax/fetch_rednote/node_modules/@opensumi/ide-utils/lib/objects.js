"use strict";
/* ---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Some code copied and modified from https://github.com/microsoft/vscode/blob/1.44.0/src/vs/base/common/objects.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.cloneAndChangeByKV = exports.removeUndefined = exports.isPlainObject = exports.deepClone = exports.cloneAndChange = exports.deepFreeze = void 0;
const types_1 = require("./types");
const _hasOwnProperty = Object.prototype.hasOwnProperty;
function deepFreeze(obj) {
    if (!obj || typeof obj !== 'object') {
        return obj;
    }
    const stack = [obj];
    while (stack.length > 0) {
        const objectToFreeze = stack.shift();
        Object.freeze(objectToFreeze);
        for (const key in objectToFreeze) {
            if (_hasOwnProperty.call(objectToFreeze, key)) {
                const prop = objectToFreeze[key];
                if (typeof prop === 'object' && !Object.isFrozen(prop)) {
                    stack.push(prop);
                }
            }
        }
    }
    return obj;
}
exports.deepFreeze = deepFreeze;
function cloneAndChange(obj, changer) {
    return _cloneAndChange(obj, changer, new Set());
}
exports.cloneAndChange = cloneAndChange;
function _cloneAndChange(obj, changer, seen) {
    if ((0, types_1.isUndefinedOrNull)(obj)) {
        return obj;
    }
    const changed = changer(obj);
    if (typeof changed !== 'undefined') {
        return changed;
    }
    if ((0, types_1.isArray)(obj)) {
        const r1 = [];
        for (const e of obj) {
            r1.push(_cloneAndChange(e, changer, seen));
        }
        return r1;
    }
    if ((0, types_1.isObject)(obj)) {
        if (seen.has(obj)) {
            throw new Error('Cannot clone recursive data-structure');
        }
        seen.add(obj);
        const r2 = {};
        for (const i2 in obj) {
            if (_hasOwnProperty.call(obj, i2)) {
                r2[i2] = _cloneAndChange(obj[i2], changer, seen);
            }
        }
        seen.delete(obj);
        return r2;
    }
    return obj;
}
function deepClone(obj) {
    if (!obj || typeof obj !== 'object') {
        return obj;
    }
    if (obj instanceof RegExp) {
        return obj;
    }
    const result = Array.isArray(obj) ? [] : {};
    Object.keys(obj).forEach((key) => {
        const prop = obj[key];
        if (prop && typeof prop === 'object') {
            result[key] = deepClone(prop);
        }
        else {
            result[key] = prop;
        }
    });
    return result;
}
exports.deepClone = deepClone;
function isPlainObject(obj) {
    return typeof obj === 'object' && obj.constructor === Object;
}
exports.isPlainObject = isPlainObject;
function removeUndefined(obj) {
    if (!isPlainObject(obj)) {
        return obj;
    }
    const keys = Object.keys(obj);
    keys.forEach((key) => {
        if (obj[key] === undefined) {
            delete obj[key];
        }
    });
    return obj;
}
exports.removeUndefined = removeUndefined;
function cloneAndChangeByKV(obj, changer) {
    return _cloneAndChangeByKV(obj, changer, new Set());
}
exports.cloneAndChangeByKV = cloneAndChangeByKV;
function _cloneAndChangeByKV(obj, changer, seen) {
    if ((0, types_1.isUndefinedOrNull)(obj)) {
        return obj;
    }
    if ((0, types_1.isArray)(obj)) {
        const r1 = [];
        for (const e of obj) {
            r1.push(_cloneAndChangeByKV(e, changer, seen));
        }
        return r1;
    }
    if ((0, types_1.isObject)(obj)) {
        if (seen.has(obj)) {
            throw new Error('Cannot clone recursive data-structure');
        }
        seen.add(obj);
        const r2 = {};
        for (const i2 in obj) {
            if (_hasOwnProperty.call(obj, i2)) {
                const changed = changer(i2, obj[i2]);
                if (typeof changed !== 'undefined') {
                    r2[i2] = changed;
                }
                else {
                    r2[i2] = _cloneAndChangeByKV(obj[i2], changer, seen);
                }
            }
        }
        seen.delete(obj);
        return r2;
    }
    return obj;
}
//# sourceMappingURL=objects.js.map