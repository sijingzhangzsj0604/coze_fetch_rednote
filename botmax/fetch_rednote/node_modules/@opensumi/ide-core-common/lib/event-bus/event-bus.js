"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventBusImpl = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@opensumi/di");
const ide_utils_1 = require("@opensumi/ide-utils");
const basic_event_1 = require("./basic-event");
let EventBusImpl = class EventBusImpl {
    constructor() {
        this.emitterMap = new Map();
    }
    fire(e, opts = {}) {
        const Constructor = e && e.constructor;
        if (typeof Constructor === 'function' && basic_event_1.BasicEvent.isPrototypeOf(Constructor)) {
            const emitter = this.emitterMap.get(Constructor);
            if (emitter) {
                emitter.fire(e);
            }
        }
    }
    async fireAndAwait(e, opts = { timeout: 2000 }) {
        const Constructor = e && e.constructor;
        if (typeof Constructor === 'function' && basic_event_1.BasicEvent.isPrototypeOf(Constructor)) {
            const emitter = this.emitterMap.get(Constructor);
            if (emitter) {
                return emitter.fireAndAwait(e, opts.timeout);
            }
        }
        return [];
    }
    on(Constructor, listener) {
        const emitter = this.getOrCreateEmitter(Constructor);
        return emitter.event(listener);
    }
    once(Constructor, listener) {
        const emitter = this.getOrCreateEmitter(Constructor);
        return ide_utils_1.Event.once(emitter.event)(listener);
    }
    getOrCreateEmitter(key) {
        const current = this.emitterMap.get(key);
        if (current) {
            return current;
        }
        const emitter = new ide_utils_1.Emitter();
        this.emitterMap.set(key, emitter);
        return emitter;
    }
};
EventBusImpl = tslib_1.__decorate([
    (0, di_1.Injectable)()
], EventBusImpl);
exports.EventBusImpl = EventBusImpl;
//# sourceMappingURL=event-bus.js.map