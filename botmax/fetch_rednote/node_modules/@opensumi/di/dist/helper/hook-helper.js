"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHooked = exports.getHookMeta = exports.isAspectCreator = exports.markAsHook = exports.markAsAspect = exports.HookStore = exports.isPromiseLike = exports.createHookedFunction = exports.applyHooks = exports.HOOKED_SYMBOL = void 0;
require("reflect-metadata");
var declare_1 = require("../declare");
var compose_1 = __importDefault(require("./compose"));
exports.HOOKED_SYMBOL = Symbol('COMMON_DI_HOOKED');
function applyHooks(instance, token, hooks) {
    if (typeof instance !== 'object') {
        // Only object can be hook.
        return instance;
    }
    if (!hooks.hasHooks(token)) {
        return instance;
    }
    // One disadvantage of using a proxy is that it can be difficult to intercept certain methods
    // that are defined using bound functions.
    //
    // If the methods of a class defined using a bound function such as a = () => this.b() are used,
    // the b() function cannot be intercepted correctly.
    var hookedCache = new Map();
    var proxy = new Proxy(instance, {
        get: function (target, prop) {
            if (prop === exports.HOOKED_SYMBOL) {
                return true;
            }
            var raw = target[prop];
            if (typeof raw === 'function' && hooks.getHooks(token, prop).length > 0) {
                if (!hookedCache.has(prop)) {
                    hookedCache.set(prop, createHookedFunction(prop, raw, hooks.getHooks(token, prop)));
                }
                return hookedCache.get(prop);
            }
            return raw;
        },
    });
    return proxy;
}
exports.applyHooks = applyHooks;
/**
 * To use hooks to assemble a final wrapped function
 * @param rawMethod the original method
 * @param hooks hooks
 */
function createHookedFunction(methodName, rawMethod, hooks) {
    var beforeHooks = [];
    var afterHooks = [];
    var aroundHooks = [];
    var afterReturningHooks = [];
    var afterThrowingHooks = [];
    // Onion model
    hooks.forEach(function (h) {
        if (isBeforeHook(h)) {
            // for the "before hook", the first one to come is executed first.
            beforeHooks.push(h);
        }
        else if (isAfterHook(h)) {
            // For the "after hook", the one that comes later is executed first.
            afterHooks.unshift(h);
        }
        else if (isAroundHook(h)) {
            // For the "around hook", the one that comes later is executed first.
            aroundHooks.unshift(h);
        }
        else if (isAfterReturningHook(h)) {
            afterReturningHooks.push(h);
        }
        else if (isAfterThrowingHook(h)) {
            afterThrowingHooks.push(h);
        }
    });
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var promise;
        var ret = undefined;
        var error;
        var self = this;
        var originalArgs = args;
        try {
            promise = runAroundHooks();
            if (promise) {
                // If there is one hook that is asynchronous, convert all of them to asynchronous.
                promise = promise.then(function () {
                    return ret;
                });
                return promise;
            }
            else {
                return ret;
            }
        }
        catch (e) {
            error = e;
            runAfterThrowing();
            throw e;
        }
        finally {
            if (error) {
                // noop
            }
            else {
                // 异步逻辑
                var p = void 0;
                if (promise) {
                    p = promise;
                }
                if (p) {
                    // p is a promise, use Promise's reject and resolve at this time
                    p.then(function () {
                        runAfterReturning();
                    }, function (e) {
                        error = e;
                        runAfterThrowing();
                    });
                }
                else {
                    runAfterReturning();
                }
            }
        }
        function runAroundHooks() {
            var hooks = aroundHooks.map(function (v) {
                var fn = v.hook;
                return fn;
            });
            var composed = (0, compose_1.default)(hooks);
            var aroundJoinPoint = {
                getArgs: function () {
                    return args;
                },
                getMethodName: function () {
                    return methodName;
                },
                getOriginalArgs: function () {
                    return originalArgs;
                },
                getResult: function () {
                    return ret;
                },
                getThis: function () {
                    return self;
                },
                setArgs: function (_args) {
                    args = _args;
                },
                setResult: function (_ret) {
                    ret = _ret;
                },
                proceed: function () {
                    var maybePromise = wrapped();
                    if (maybePromise && isPromiseLike(maybePromise)) {
                        return maybePromise.then(function () { return Promise.resolve(); });
                    }
                },
            };
            return composed(aroundJoinPoint);
        }
        function runBeforeHooks() {
            if (beforeHooks.length === 0) {
                return;
            }
            var _inThisHook = true;
            var beforeJointPont = {
                getArgs: function () {
                    return args;
                },
                getMethodName: function () {
                    return methodName;
                },
                getOriginalArgs: function () {
                    return originalArgs;
                },
                getThis: function () {
                    return self;
                },
                setArgs: function (_args) {
                    if (!_inThisHook) {
                        throw new Error('It is not allowed to set the parameters after the Hook effect time is over');
                    }
                    args = _args;
                },
            };
            return runHooks(beforeHooks, beforeJointPont, function () {
                _inThisHook = false;
            });
        }
        function runAfterHooks() {
            if (afterHooks.length === 0) {
                return;
            }
            var _inThisHook = true;
            var afterJoinPoint = {
                getArgs: function () {
                    return args;
                },
                getMethodName: function () {
                    return methodName;
                },
                getOriginalArgs: function () {
                    return originalArgs;
                },
                getResult: function () {
                    return ret;
                },
                getThis: function () {
                    return self;
                },
                setResult: function (_ret) {
                    if (!_inThisHook) {
                        throw new Error('It is not allowed to set the return value after the Hook effect time is over');
                    }
                    ret = _ret;
                },
            };
            return runHooks(afterHooks, afterJoinPoint, function () {
                _inThisHook = false;
            });
        }
        function runAfterReturning() {
            if (afterReturningHooks.length === 0) {
                return;
            }
            var afterReturningJoinPoint = {
                getArgs: function () {
                    return args;
                },
                getMethodName: function () {
                    return methodName;
                },
                getOriginalArgs: function () {
                    return originalArgs;
                },
                getResult: function () {
                    return ret;
                },
                getThis: function () {
                    return self;
                },
            };
            afterReturningHooks.forEach(function (hook) {
                try {
                    hook.hook(afterReturningJoinPoint);
                }
                catch (e) {
                    // no op, ignore error on AfterReturning
                }
            });
        }
        function runAfterThrowing() {
            if (afterThrowingHooks.length === 0) {
                return;
            }
            var afterThrowingJoinPoint = {
                getError: function () {
                    return error;
                },
                getMethodName: function () {
                    return methodName;
                },
                getOriginalArgs: function () {
                    return originalArgs;
                },
                getThis: function () {
                    return self;
                },
            };
            afterThrowingHooks.forEach(function (hook) {
                try {
                    hook.hook(afterThrowingJoinPoint);
                }
                catch (e) {
                    // no op, ignore error on AfterThrowing
                }
            });
        }
        function wrapped() {
            promise = runBeforeHooks();
            if (promise) {
                promise = promise.then(function () {
                    ret = rawMethod.apply(self, args);
                    return;
                });
            }
            else {
                ret = rawMethod.apply(self, args);
            }
            if (promise) {
                promise = promise.then(function () {
                    return runAfterHooks();
                });
            }
            else {
                promise = runAfterHooks();
            }
            if (promise) {
                return promise.then(function () {
                    return ret;
                });
            }
            else {
                return ret;
            }
        }
    };
}
exports.createHookedFunction = createHookedFunction;
function isBeforeHook(hook) {
    return hook && hook.type === declare_1.HookType.Before;
}
function isAfterHook(hook) {
    return hook && hook.type === declare_1.HookType.After;
}
function isAroundHook(hook) {
    return hook && hook.type === declare_1.HookType.Around;
}
function isAfterReturningHook(hook) {
    return hook && hook.type === declare_1.HookType.AfterReturning;
}
function isAfterThrowingHook(hook) {
    return hook && hook.type === declare_1.HookType.AfterThrowing;
}
function isPromiseLike(thing) {
    return !!thing.then;
}
exports.isPromiseLike = isPromiseLike;
function runHooks(hooks, joinPoint, then) {
    var e_1, _a;
    var promise;
    try {
        for (var hooks_1 = __values(hooks), hooks_1_1 = hooks_1.next(); !hooks_1_1.done; hooks_1_1 = hooks_1.next()) {
            var hook = hooks_1_1.value;
            promise = runOneHook(hook, joinPoint, promise);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (hooks_1_1 && !hooks_1_1.done && (_a = hooks_1.return)) _a.call(hooks_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (promise) {
        promise = promise.then(then);
    }
    else {
        then();
    }
    return promise;
}
function runOneHook(hook, joinPoint, promise) {
    if (hook.awaitPromise) {
        promise = promise || Promise.resolve();
        promise = promise.then(function () {
            return hook.hook(joinPoint);
        });
    }
    else {
        if (promise) {
            promise = promise.then(function () {
                hook.hook(joinPoint);
                return;
            });
        }
        else {
            hook.hook(joinPoint);
        }
    }
    return promise;
}
var HookStore = /** @class */ (function () {
    function HookStore(parent) {
        this.parent = parent;
        this.hooks = new Map();
    }
    HookStore.prototype.createHooks = function (hooks) {
        var _this = this;
        var disposers = hooks.map(function (hook) {
            return _this.createOneHook(hook);
        });
        return {
            dispose: function () {
                disposers.forEach(function (disposer) {
                    disposer.dispose();
                });
            },
        };
    };
    HookStore.prototype.hasHooks = function (token) {
        if (!this.hooks.has(token)) {
            if (this.parent) {
                return this.parent.hasHooks(token);
            }
            else {
                return false;
            }
        }
        else {
            return true;
        }
    };
    HookStore.prototype.getHooks = function (token, method) {
        var _a;
        var hooks = [];
        if (this.parent) {
            hooks = this.parent.getHooks(token, method);
        }
        if ((_a = this.hooks.get(token)) === null || _a === void 0 ? void 0 : _a.has(method)) {
            hooks = hooks.concat(this.hooks.get(token).get(method));
        }
        return hooks;
    };
    HookStore.prototype.createOneHook = function (hook) {
        var _this = this;
        var token = hook.target;
        if (!this.hooks.has(token)) {
            this.hooks.set(token, new Map());
        }
        var instanceHooks = this.hooks.get(token);
        if (!instanceHooks.has(hook.method)) {
            instanceHooks.set(hook.method, []);
        }
        // TODO: 支持order
        instanceHooks.get(hook.method).push(hook);
        return {
            dispose: function () {
                _this.removeOneHook(hook);
            },
        };
    };
    HookStore.prototype.removeOneHook = function (hook) {
        var token = hook.target;
        if (!this.hooks.has(token)) {
            return;
        }
        var instanceHooks = this.hooks.get(token);
        if (!instanceHooks.has(hook.method)) {
            return;
        }
        var methodHooks = instanceHooks.get(hook.method);
        var index = methodHooks.indexOf(hook);
        if (index > -1) {
            methodHooks.splice(index, 1);
        }
    };
    return HookStore;
}());
exports.HookStore = HookStore;
var HOOK_KEY = Symbol('HOOK_KEY');
var ASPECT_KEY = Symbol('ASPECT_KEY');
function markAsAspect(target) {
    Reflect.defineMetadata(ASPECT_KEY, true, target);
}
exports.markAsAspect = markAsAspect;
function markAsHook(target, prop, type, hookTarget, targetMethod, options) {
    var hooks = Reflect.getOwnMetadata(HOOK_KEY, target);
    if (!hooks) {
        hooks = [];
        Reflect.defineMetadata(HOOK_KEY, hooks, target);
    }
    hooks.push({ prop: prop, type: type, target: hookTarget, targetMethod: targetMethod, options: options });
}
exports.markAsHook = markAsHook;
function isAspectCreator(target) {
    return !!Reflect.getMetadata(ASPECT_KEY, target.useClass);
}
exports.isAspectCreator = isAspectCreator;
function getHookMeta(target) {
    return Reflect.getOwnMetadata(HOOK_KEY, target.prototype) || [];
}
exports.getHookMeta = getHookMeta;
function isHooked(target) {
    return target && !!target[exports.HOOKED_SYMBOL];
}
exports.isHooked = isHooked;
