export interface RestoreFunction {
    (strict?: boolean): void;
}
/**
 * You can feel free to restore when you hook a function.
 * But you ought to restore 「in order」 if you hooked a value reference or a real obj reference.Because we not store the last value referent for now.
 * eg: obj.a = 1;
 * const r_1 = hookObjectProperty(obj, 'a',() =>2)()
 * const r_2 = hookObjectProperty(obj, 'a',() =>3)()
 * r_2() // obj.a === 2
 * r_1() // obj.a === 1
 *
 * @template T
 * @template K
 * @template P
 * @param {T} obj
 * @param {K} key
 * @param {(origin: T[K], ...params: P) => T[K]} hookFunc
 * @param {boolean} isCatchError When an error occurs after calling a hooked function, we want to suppress the errors and try to call the original function by default.
 * @return {*}
 */
export declare const hookObjectProperty: <T extends {}, K extends keyof T, P extends any[]>(obj: T, key: K, hookFunc: (origin: T[K], ...params: P) => T[K], isCatchError?: boolean) => (...params: P) => (strict?: boolean | undefined) => void;
/**
 * 劫持对象方法
 * 必须记得给 hookFunc 劫持的方法包 try catch ！
 * 不在本方法里包是为了避免对象原方法被调用两次
 */
export declare const hookMethodDangerously: <T extends {}, K extends keyof T, P extends any[]>(obj: T, key: K, hookFunc: (origin: T[K], ...params: P) => T[K]) => (...params: P) => () => any;
