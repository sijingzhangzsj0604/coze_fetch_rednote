import { __read, __spreadArray } from "tslib";
/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
import { EVENTS, } from './types';
import { arrayIncludes, arrayRemove, isObject, log, runProcessors, warn } from './utils';
export function createClient(creationConfig) {
    var builder = creationConfig.builder, createSender = creationConfig.createSender, createDefaultConfig = creationConfig.createDefaultConfig, createConfigManager = creationConfig.createConfigManager, userConfigNormalizer = creationConfig.userConfigNormalizer, initConfigNormalizer = creationConfig.initConfigNormalizer, validateInitConfig = creationConfig.validateInitConfig;
    var sender;
    var configManager;
    var handlers = {};
    EVENTS.forEach(function (e) { return (handlers[e] = []); });
    var inited = false;
    var started = false;
    var destroyed = false;
    // 缓存 start 之前 build 的事件
    var preStartQueue = [];
    // 禁止通过 provide 挂载的字段名
    var reservedNames = [];
    var client = {
        getBuilder: function () { return builder; },
        getSender: function () { return sender; },
        getPreStartQueue: function () { return preStartQueue; },
        init: function (c) {
            if (inited) {
                warn('already inited');
                return;
            }
            if (c && isObject(c) && validateInitConfig(c)) {
                var defaultConfig = createDefaultConfig(c);
                if (!defaultConfig) {
                    throw new Error('defaultConfig missing');
                }
                var initConfig = initConfigNormalizer(c);
                configManager = createConfigManager(defaultConfig);
                configManager.setConfig(initConfig);
                configManager.onChange(function () {
                    handle('config');
                });
                sender = createSender(configManager.getConfig());
                if (!sender) {
                    throw new Error('sender missing');
                }
                inited = true;
                handle('init', true);
            }
            else {
                throw new Error('invalid InitConfig, init failed');
            }
        },
        set: function (c) {
            if (!inited) {
                return;
            }
            if (c && isObject(c)) {
                handle('beforeConfig', false, c);
                configManager === null || configManager === void 0 ? void 0 : configManager.setConfig(c);
            }
        },
        config: function (c) {
            if (!inited) {
                return;
            }
            if (c && isObject(c)) {
                handle('beforeConfig', false, c);
                configManager === null || configManager === void 0 ? void 0 : configManager.setConfig(userConfigNormalizer(c));
            }
            return configManager === null || configManager === void 0 ? void 0 : configManager.getConfig();
        },
        provide: function (name, value) {
            if (arrayIncludes(reservedNames, name)) {
                warn("cannot provide " + name + ", reserved");
                return;
            }
            client[name] = value;
            handle('provide', false, name);
        },
        start: function () {
            var _this = this;
            if (!inited) {
                return;
            }
            if (started) {
                return;
            }
            configManager === null || configManager === void 0 ? void 0 : configManager.onReady(function () {
                started = true;
                handle('start', true);
                preStartQueue.forEach(function (e) { return _this.build(e); });
                preStartQueue = [];
            });
        },
        report: function (data) {
            if (!data) {
                return;
            }
            var preReport = runProcessors(handlers['beforeReport'])(data);
            if (!preReport) {
                return;
            }
            var processed = runProcessors(handlers['report'])(preReport);
            if (!processed) {
                return;
            }
            if (started) {
                this.build(processed);
            }
            else {
                preStartQueue.push(processed);
            }
        },
        build: function (data) {
            if (!started) {
                return;
            }
            var preBuild = runProcessors(handlers['beforeBuild'])(data);
            if (!preBuild) {
                return;
            }
            var built = builder.build(preBuild);
            if (!built) {
                return;
            }
            var processed = runProcessors(handlers['build'])(built);
            if (!processed) {
                return;
            }
            this.send(processed);
        },
        send: function (data) {
            if (!started) {
                return;
            }
            var processed = runProcessors(handlers['beforeSend'])(data);
            if (processed) {
                sender.send(processed);
                handle('send', false, processed);
            }
        },
        destroy: function () {
            destroyed = true;
            handle('beforeDestroy', true);
        },
        on: function (ev, handler) {
            if (ev === 'init' && inited) {
                ;
                handler();
            }
            else if (ev === 'start' && started) {
                ;
                handler();
            }
            else if (ev === 'beforeDestroy' && destroyed) {
                ;
                handler();
            }
            else if (handlers[ev]) {
                handlers[ev].push(handler);
            }
        },
        off: function (ev, handler) {
            if (handlers[ev])
                handlers[ev] = arrayRemove(handlers[ev], handler);
        },
    };
    reservedNames = Object.keys(client);
    return client;
    function handle(ev, once) {
        if (once === void 0) { once = false; }
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        handlers[ev].forEach(function (f) {
            try {
                f.apply(void 0, __spreadArray([], __read(args), false));
            }
            catch (_err) {
                // ignore
            }
        });
        if (once) {
            handlers[ev].length = 0;
        }
    }
}
//# sourceMappingURL=client.js.map