export declare type ReportEventFromClient<C extends AnyClient> = C extends {
    report: (e: infer R) => void;
} ? R : never;
export declare type SendEventFromClient<C extends AnyClient> = C extends {
    send: (e: infer R) => void;
} ? R : never;
export interface ConfigManager<Config> {
    setConfig: (c: Partial<Config>) => Config;
    getConfig: () => Config;
    onChange: (fn: () => void) => void;
    onReady: (fn: () => void) => void;
}
export interface Client<ReportEvent, SendEvent, Builder extends EventBuilder<ReportEvent, SendEvent>, Sender extends EventSender<SendEvent>, InitConfig, UserConfig, Config> {
    getBuilder: () => Builder;
    getSender: () => Sender | undefined;
    getPreStartQueue: () => ReportEvent[];
    /**
     * passing InitConfig, can only be called once
     * @param {InitConfig} c
     */
    init: (c: InitConfig) => void;
    /**
     * update common config, can be called multiple times
     * @param {Partial<UserConfig>} c
     */
    config: ConfigAgent<UserConfig, Config>;
    /**
     * update internal SDKConfig directly without normalization
     * @param {Partial<Config>} c
     */
    set: (c: Partial<Config>) => void;
    /**
     * called when user finishes configuration and ready to send
     */
    start: () => void;
    /**
     * to report any valid event
     * @param {ReportEvent} e
     */
    report: (e: ReportEvent) => void;
    /**
     * build the reported event into server-specific format
     * @param {ReportEvent} e
     */
    build: (e: ReportEvent) => void;
    /**
     * report event in server-specific format
     * @param {SendEvent} e
     */
    send: (e: SendEvent) => void;
    destroy: () => void;
    on: EventToEventHandlerParams<ClientEvent<ReportEvent, SendEvent, Config>>;
    off: EventToEventHandlerParams<ClientEvent<ReportEvent, SendEvent, Config>>;
    /**
     * mount any value onto the client with name, so as to extend the client APIs
     * @param {string} name 挂载属性名
     * @param {any} value 挂载属性值
     */
    provide: (k: string, v: any) => void;
}
export declare type AnyClient = Client<any, any, any, any, any, any, any>;
export declare type ConfigNormalizer<UserConfig, Config> = (c: Partial<UserConfig>) => Partial<Config>;
export declare type ConfigAgent<UserConfig, Config> = {
    (c?: Partial<UserConfig>): Config | undefined;
};
export interface EventBuilder<ReportEvent, SendEvent> {
    build: (d: ReportEvent) => SendEvent | Falsy;
}
export interface EventSender<SendEvent> {
    send: (e: SendEvent) => void;
}
export declare const EVENTS: string[];
export interface ClientEvent<ReportEvent, SendEvent, Config> {
    init: () => void;
    start: () => void;
    config: () => void;
    beforeConfig: Callback<Partial<Config>>;
    beforeDestroy: () => void;
    provide: Callback<string>;
    beforeReport: Processor<ReportEvent>;
    report: Processor<ReportEvent>;
    beforeBuild: Processor<ReportEvent>;
    build: Processor<SendEvent>;
    beforeSend: Processor<SendEvent>;
    send: Callback<SendEvent>;
}
export interface Processor<E> {
    (e: E): E | Falsy;
}
export declare type Falsy = false | null | undefined;
export interface SdkTransport {
    get: (options: any) => void;
    post: (options: any) => void;
}
interface Callback<T> {
    (arg: T): void;
}
export declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
export declare type EventToEventHandlerPair<Event extends ClientEvent<any, any, any>, T extends keyof Event> = T extends any ? (ev: T, handler: Event[T]) => void : never;
declare type EventToEventHandlerParams<Event extends ClientEvent<any, any, any>> = UnionToIntersection<EventToEventHandlerPair<Event, keyof Event>>;
export declare type PartialRecursive<T> = T extends {
    [key: string]: any;
} ? T extends Function ? T : T extends any[] ? T : {
    [K in keyof T]?: PartialRecursive<T[K]>;
} : T;
export {};
