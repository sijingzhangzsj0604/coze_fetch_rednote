export declare type OverloadedReturnType<P, T> = T extends {
    (...args: infer P1): infer R1;
    (...args: infer P2): infer R2;
    (...args: infer P3): infer R3;
    (...args: infer P4): infer R4;
} ? P1 extends P ? R1 : P2 extends P ? R2 : P3 extends P ? R3 : P4 extends P ? R4 : never : T extends {
    (...args: infer P1): infer R1;
    (...args: infer P2): infer R2;
    (...args: infer P3): infer R3;
} ? P3 extends P ? R3 : P2 extends P ? R2 : P1 extends P ? R1 : never : T extends {
    (...args: infer P1): infer R1;
    (...args: infer P2): infer R2;
} ? P2 extends P ? R2 : P1 extends P ? R1 : never : T extends (...args: any[]) => infer R ? R : never;
export declare type OverloadedParams<T> = T extends {
    (...a: infer A1): any;
    (...a: infer A2): any;
    (...a: infer A3): any;
    (...a: infer A4): any;
} ? A1 | A2 | A3 | A4 : T extends {
    (...a: infer A1): any;
    (...a: infer A2): any;
    (...a: infer A3): any;
} ? A1 | A2 | A3 : T extends {
    (...a: infer A1): any;
    (...a: infer A2): any;
} ? A1 | A2 : T extends {
    (...a: infer A1): any;
} ? A1 : never;
