/** ******************************************************************************
 * Copyright (C) 2018 Red Hat, Inc. and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import { URI, Emitter, DisposableCollection, IDisposable } from '@opensumi/ide-utils';
import { IProblemPatternRegistry, ApplyToKind, FileLocationKind, Severity, ProblemPatternContribution, ProblemPattern, WatchingPattern } from './problem-pattern';
export interface WatchingMatcherContribution {
    activeOnStart?: boolean;
    beginsPattern: string | WatchingPattern;
    endsPattern: string | WatchingPattern;
}
export interface ProblemMatcherContribution {
    base?: string;
    name?: string;
    label: string;
    deprecated?: boolean;
    owner: string;
    source?: string;
    applyTo?: string;
    fileLocation?: 'absolute' | 'relative' | string[];
    pattern: string | ProblemPatternContribution | ProblemPatternContribution[];
    severity?: string;
    watching?: WatchingMatcherContribution;
    background?: WatchingMatcherContribution;
}
export interface WatchingMatcher {
    activeOnStart: boolean;
    beginsPattern: WatchingPattern;
    endsPattern: WatchingPattern;
}
export declare namespace WatchingMatcher {
    function fromWatchingMatcherContribution(value: WatchingMatcherContribution | undefined): WatchingMatcher | undefined;
}
export interface ProblemMatcher {
    owner: string;
    source?: string;
    applyTo?: ApplyToKind | string;
    fileLocation: FileLocationKind | string[];
    filePrefix?: string;
    pattern: ProblemPattern | ProblemPattern[];
    severity?: Severity | string;
    watching?: WatchingMatcher;
    uriProvider?: (path: string) => URI;
}
export type ProblemMatcherType = string | ProblemMatcher | Array<string | ProblemMatcher>;
export interface NamedProblemMatcher extends ProblemMatcher {
    /**
     * This name can be used to refer to the
     * problem matcher from within a task.
     */
    name: string;
    /**
     * A human readable label.
     */
    label?: string;
    deprecated?: boolean;
}
export declare const IProblemMatcherRegistry: unique symbol;
export interface IProblemMatcherRegistry {
    register(matcher: ProblemMatcherContribution): IDisposable;
    get(name: string): NamedProblemMatcher | undefined;
    getAll(): NamedProblemMatcher[];
}
export declare class ProblemMatchersRegistryImpl implements IProblemMatcherRegistry {
    problemPattern: IProblemPatternRegistry;
    protected readonly onDidChangeProblemMatcherEmitter: Emitter<void>;
    private readonly matchers;
    constructor();
    private init;
    /**
     * Finds the problem matcher from the registry by its name.
     *
     * @param name the name of the problem matcher
     * @return the problem matcher. If the task definition is not found, `undefined` is returned.
     */
    get: (name: string) => NamedProblemMatcher | undefined;
    /**
     * Returns all registered problem matchers in the registry.
     */
    getAll(): NamedProblemMatcher[];
    /**
     * Add a problem matcher to the registry.
     *
     * @param definition the problem matcher to be added.
     */
    register(matcher: ProblemMatcherContribution): IDisposable;
    protected doRegister(matcher: ProblemMatcherContribution, toDispose: DisposableCollection): Promise<void>;
    private add;
    /**
     * Transforms the `ProblemMatcherContribution` to a `ProblemMatcher`
     *
     * @return the problem matcher
     */
    getProblemMatcherFromContribution(matcher: ProblemMatcherContribution): Promise<ProblemMatcher>;
    private getFileLocationKindAndPrefix;
    private fillDefaults;
}
//# sourceMappingURL=problem-matcher.d.ts.map