"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.URI = exports.UriUtils = exports.Uri = void 0;
const vscode_uri_1 = require("vscode-uri");
const glob_1 = require("./glob");
const path_1 = require("./path");
var vscode_uri_2 = require("vscode-uri");
Object.defineProperty(exports, "Uri", { enumerable: true, get: function () { return vscode_uri_2.URI; } });
Object.defineProperty(exports, "UriUtils", { enumerable: true, get: function () { return vscode_uri_2.Utils; } });
class URI {
    static from(components) {
        return new URI(vscode_uri_1.URI.from(components));
    }
    static file(path) {
        return new URI(vscode_uri_1.URI.file(path));
    }
    static parse(path) {
        return new URI(vscode_uri_1.URI.parse(path));
    }
    static isUri(thing) {
        if (thing instanceof URI) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return vscode_uri_1.URI.isUri(thing);
    }
    static isUriString(str) {
        return !!str && /^[A-Za-z\-\_]+:\/\//.test(str);
    }
    static revive(data) {
        return vscode_uri_1.URI.revive(data);
    }
    constructor(uri = '') {
        if (vscode_uri_1.URI.isUri(uri)) {
            this.codeUri = uri;
        }
        else {
            this.codeUri = vscode_uri_1.URI.parse(uri);
        }
    }
    get displayName() {
        const base = this.path.base;
        if (base) {
            return base;
        }
        if (this.path.isRoot) {
            return this.path.toString();
        }
        return '';
    }
    /**
     * Return all uri from the current to the top most.
     */
    get allLocations() {
        const locations = [];
        let location = this;
        while (!location.path.isRoot) {
            locations.push(location);
            location = location.parent;
        }
        locations.push(location);
        return locations;
    }
    get parent() {
        if (this.path.isRoot) {
            return this;
        }
        return this.withPath(this.path.dir);
    }
    relative(uri) {
        if (this.authority !== uri.authority || this.scheme !== uri.scheme) {
            return undefined;
        }
        return this.path.relative(uri.path);
    }
    resolve(path) {
        return this.withPath(this.path.join(path.toString()));
    }
    /**
     * return a new URI replacing the current with the given scheme
     */
    withScheme(scheme) {
        const newCodeUri = vscode_uri_1.URI.from(Object.assign(Object.assign({}, this.codeUri.toJSON()), { scheme }));
        return new URI(newCodeUri);
    }
    /**
     * @deprecated
     * return this URI without a scheme
     */
    withoutScheme() {
        /**
         * 本方法已废弃
         * 由于 vscode-uri 自 1.0.8 起，内部强制校验和修正 `scheme` 参数
         * 会将 scheme 为空时强制修正为 `file` (不可关闭)
         * 会在不传入 scheme 时报错 (可通过 setUriThrowOnMissingScheme 关闭)
         * 因此这里直接调用 `new Uri` 产生一个不带 scheme 的 Uri 实例
         * ---- !!!!!!! ATTENTION ----
         * 这样做的影响是 Uri 的实例 toJSON 时没有 $mid 参数，会在通信序列化时无法传输
         * ---- !!!!!!! ATTENTION ----
         * 但是 vscode-uri 对 constructor 属性加了 protected 保护，因此增加了 `ts-ignore`
         */
        if (process.env.NODE_ENV !== 'production' && console !== undefined) {
            // eslint-disable-next-line no-console
            console.warn('Warning: `Uri.withoutScheme` is deprecated, ' +
                'If you want to get `fsPath` by `withoutScheme` method, ' +
                "it's recommended to use `uri.path.toString` directly");
        }
        // @ts-ignore
        const newCodeUri = new vscode_uri_1.URI(Object.assign(Object.assign({}, this.codeUri.toJSON()), { scheme: '' }));
        return new URI(newCodeUri);
    }
    /**
     * return a new URI replacing the current with the given authority
     */
    withAuthority(authority) {
        const newCodeUri = vscode_uri_1.URI.from(Object.assign(Object.assign({}, this.codeUri.toJSON()), { scheme: this.codeUri.scheme, authority }));
        return new URI(newCodeUri);
    }
    /**
     * return this URI without a authority
     */
    withoutAuthority() {
        return this.withAuthority('');
    }
    /**
     * return a new URI replacing the current with the given path
     */
    withPath(path) {
        const newCodeUri = vscode_uri_1.URI.from(Object.assign(Object.assign({}, this.codeUri.toJSON()), { scheme: this.codeUri.scheme, path: path.toString() }));
        return new URI(newCodeUri);
    }
    /**
     * return this URI without a path
     */
    withoutPath() {
        return this.withPath('');
    }
    /**
     * return a new URI replacing the current with the given query
     */
    withQuery(query) {
        const newCodeUri = vscode_uri_1.URI.from(Object.assign(Object.assign({}, this.codeUri.toJSON()), { scheme: this.codeUri.scheme, query }));
        return new URI(newCodeUri);
    }
    /**
     * return this URI without a query
     */
    withoutQuery() {
        return this.withQuery('');
    }
    /**
     * return a new URI replacing the current with the given fragment
     */
    withFragment(fragment) {
        const newCodeUri = vscode_uri_1.URI.from(Object.assign(Object.assign({}, this.codeUri.toJSON()), { scheme: this.codeUri.scheme, fragment }));
        return new URI(newCodeUri);
    }
    /**
     * return this URI without a fragment
     */
    withoutFragment() {
        return this.withFragment('');
    }
    get scheme() {
        return this.codeUri.scheme;
    }
    get authority() {
        return this.codeUri.authority;
    }
    get path() {
        if (this._path === undefined) {
            this._path = new path_1.Path(this.codeUri.path);
        }
        return this._path;
    }
    get query() {
        return this.codeUri.query;
    }
    get fragment() {
        return this.codeUri.fragment;
    }
    toString(skipEncoding) {
        return this.codeUri.toString(skipEncoding);
    }
    isEqualOrParent(uri) {
        return this.authority === uri.authority && this.scheme === uri.scheme && this.path.isEqualOrParent(uri.path);
    }
    isEqual(uri) {
        return (this.authority === uri.authority &&
            this.scheme === uri.scheme &&
            this.path.isEqual(uri.path) &&
            this.query === uri.query);
    }
    matchGlobPattern(pattern) {
        return (0, glob_1.match)(pattern, this.path.toString());
    }
    static getDistinctParents(uris) {
        const result = [];
        uris.forEach((uri, i) => {
            if (!uris.some((otherUri, index) => index !== i && otherUri.isEqualOrParent(uri))) {
                result.push(uri);
            }
        });
        return result;
    }
    getParsedQuery() {
        const queryString = this.query;
        const query = {};
        const pairs = (queryString[0] === '?' ? queryString.substr(1) : queryString).split('&');
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (let i = 0; i < pairs.length; i++) {
            const pair = pairs[i].split('=');
            query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
        }
        return query;
    }
    static stringifyQuery(query) {
        const values = [];
        Object.keys(query).forEach((key) => {
            const value = encodeURIComponent(query[key]);
            if (value !== undefined) {
                values.push(encodeURIComponent(key) + '=' + value);
            }
        });
        return values.join('&');
    }
}
exports.URI = URI;
//# sourceMappingURL=uri.js.map