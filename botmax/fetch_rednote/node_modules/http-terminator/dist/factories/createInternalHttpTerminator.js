"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _http = _interopRequireDefault(require("http"));

var _delay = _interopRequireDefault(require("delay"));

var _Logger = _interopRequireDefault(require("../Logger"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = _Logger.default.child({
  namespace: 'createHttpTerminator'
});

const configurationDefaults = {
  gracefulTerminationTimeout: 1000
};

const createInternalHttpTerminator = configurationInput => {
  const configuration = { ...configurationDefaults,
    ...configurationInput
  };
  const server = configuration.server;
  const sockets = new Set();
  const secureSockets = new Set();
  let terminating;
  server.on('connection', socket => {
    if (terminating) {
      socket.destroy();
    } else {
      sockets.add(socket);
      socket.once('close', () => {
        sockets.delete(socket);
      });
    }
  });
  server.on('secureConnection', socket => {
    if (terminating) {
      socket.destroy();
    } else {
      secureSockets.add(socket);
      socket.once('close', () => {
        secureSockets.delete(socket);
      });
    }
  });
  /**
   * Evaluate whether additional steps are required to destroy the socket.
   *
   * @see https://github.com/nodejs/node/blob/57bd715d527aba8dae56b975056961b0e429e91e/lib/_http_client.js#L363-L413
   */

  const destroySocket = socket => {
    socket.destroy();

    if (socket.server instanceof _http.default.Server) {
      sockets.delete(socket);
    } else {
      secureSockets.delete(socket);
    }
  };

  const terminate = async () => {
    if (terminating) {
      log.warn('already terminating HTTP server');
      return terminating;
    }

    let resolveTerminating;
    let rejectTerminating;
    terminating = new Promise((resolve, reject) => {
      resolveTerminating = resolve;
      rejectTerminating = reject;
    });
    server.on('request', (incomingMessage, outgoingMessage) => {
      if (!outgoingMessage.headersSent) {
        outgoingMessage.setHeader('connection', 'close');
      }
    });

    for (const socket of sockets) {
      // This is the HTTP CONNECT request socket.
      if (!(socket.server instanceof _http.default.Server)) {
        continue;
      } // $FlowFixMe


      const serverResponse = socket._httpMessage;

      if (serverResponse) {
        if (!serverResponse.headersSent) {
          serverResponse.setHeader('connection', 'close');
        }

        continue;
      }

      destroySocket(socket);
    }

    for (const socket of secureSockets) {
      // $FlowFixMe
      const serverResponse = socket._httpMessage;

      if (serverResponse) {
        if (!serverResponse.headersSent) {
          serverResponse.setHeader('connection', 'close');
        }

        continue;
      }

      destroySocket(socket);
    }

    if (sockets.size) {
      await (0, _delay.default)(configuration.gracefulTerminationTimeout);

      for (const socket of sockets) {
        destroySocket(socket);
      }
    }

    if (secureSockets.size) {
      await (0, _delay.default)(configuration.gracefulTerminationTimeout);

      for (const socket of secureSockets) {
        destroySocket(socket);
      }
    }

    server.close(error => {
      if (error) {
        rejectTerminating(error);
      } else {
        resolveTerminating();
      }
    });
    return terminating;
  };

  return {
    secureSockets,
    sockets,
    terminate
  };
};

var _default = createInternalHttpTerminator;
exports.default = _default;
//# sourceMappingURL=createInternalHttpTerminator.js.map