import test from 'ava';
import sinon from 'sinon';
import { isFunction } from '@slardar/sdk-template';
import { DEFAULT_EVENT_TARGET, DEFAULT_TIME_FUNCTION, hookGlobalAsync, xmlHttpRequestProps, } from '../js-error/capture-global';
import { normalizeError, normalizeException } from '../js-error/util';
test('JsErrorMonitor - normalize js error', function (t) {
    var error = new Error('123');
    var v1 = normalizeError({ error: error });
    var v2 = normalizeError({
        error: {
            message: 'some error message',
        },
    });
    var v3 = normalizeError({});
    t.like(v1, {
        message: '123',
    });
    t.deepEqual(v2, {
        message: JSON.stringify({
            message: 'some error message',
        }),
    });
    t.is(v3, undefined);
});
test('JsErrorMonitor - normalize exception', function (t) {
    var v1 = normalizeException({ reason: '1' });
    var v2 = normalizeException({ detail: { reason: '2' } });
    var v3 = normalizeException({});
    t.deepEqual(v1, { message: '1', name: 'UnhandledRejection' });
    t.deepEqual(v2, { message: '2', name: 'UnhandledRejection' });
    t.is(v3, undefined);
});
test('should report all the errors from inside to outside if we use catch global', function (t) {
    // mock env
    var window = {};
    window.setTimeout = function (cb) {
        cb();
    };
    var reportStub = sinon.stub();
    hookGlobalAsync(reportStub, window);
    // test
    var cb = function () {
        throw new Error('test');
    };
    try {
        // auto report firstly
        window.setTimeout(cb);
        t.is(reportStub.callCount, 1);
    }
    catch (error) {
        t.is(reportStub.callCount, 1);
    }
});
test('should time function is hooked and capture error', function (t) {
    // mock env
    var window = {};
    DEFAULT_TIME_FUNCTION.forEach(function (method) {
        return (window[method] = function (cb) {
            cb();
        });
    });
    var reportStub = sinon.stub();
    var restoreFns = hookGlobalAsync(reportStub, window);
    // test
    DEFAULT_TIME_FUNCTION.forEach(function (method) {
        var cb = function () {
            throw new Error('test');
        };
        t.throws(function () { return window[method](cb); });
        var _a = reportStub.getCall(0).args[0], error = _a.error, source = _a.source;
        t.like(error, { message: 'test', name: 'Error' });
        t.deepEqual(source, {
            data: {
                function: method,
            },
            type: 'capture-global',
        });
        t.true(isFunction(cb._w_));
        reportStub.reset();
    });
    // restore time function hook
    restoreFns.forEach(function (fn) { return fn(); });
    DEFAULT_TIME_FUNCTION.forEach(function (method) {
        var cb = function () {
            throw new Error('test');
        };
        t.throws(function () { return window[method](cb); });
        t.false(reportStub.called);
        t.false(isFunction(cb._w_));
    });
});
test('should xhr is hooked and capture error when multiple xhr instances exist ', function (t) {
    // mock env
    var window = {};
    var MockXhr = Function;
    MockXhr.prototype.send = sinon.stub();
    var reportStub = sinon.stub();
    var restoreFns = hookGlobalAsync(reportStub, window, MockXhr);
    // 假设多个 xhr 实例共用一组回调函数
    var cbs = {};
    xmlHttpRequestProps.forEach(function (prop) {
        var cb = function () {
            throw new Error('test');
        };
        cbs[prop] = cb;
    });
    // test once
    var xhr1 = new MockXhr();
    xmlHttpRequestProps.forEach(function (prop) {
        xhr1[prop] = cbs[prop];
    });
    xhr1.send();
    xmlHttpRequestProps.forEach(function (prop) {
        t.throws(function () { return xhr1[prop](); });
        t.true(xhr1[prop]._hook_);
        t.is(reportStub.callCount, 1);
        var _a = reportStub.getCall(0).args[0], error = _a.error, source = _a.source;
        t.like(error, { message: 'test', name: 'Error' });
        t.deepEqual(source, {
            data: {
                function: prop,
            },
            type: 'capture-global',
        });
        reportStub.reset();
    });
    // test twice
    var xhr2 = new MockXhr();
    xmlHttpRequestProps.forEach(function (prop) {
        xhr2[prop] = cbs[prop];
    });
    xhr2.send();
    xmlHttpRequestProps.forEach(function (prop) {
        t.throws(function () { return xhr2[prop](); });
        t.true(xhr2[prop]._hook_);
        t.is(reportStub.callCount, 1);
        var _a = reportStub.getCall(0).args[0], error = _a.error, source = _a.source;
        t.like(error, { message: 'test', name: 'Error' });
        t.deepEqual(source, {
            data: {
                function: prop,
            },
            type: 'capture-global',
        });
        reportStub.reset();
    });
    // 保证回调函数只被 hook 了一次，多次 hook 时直接复用 callback._w_ 内挂载的 hook 函数
    xmlHttpRequestProps.forEach(function (prop) {
        t.is(xhr1[prop], xhr2[prop]);
        t.is(xhr1[prop], cbs[prop]._w_);
        t.true(isFunction(cbs[prop]._w_));
    });
    // restore xhr prototype send
    restoreFns.forEach(function (fn) { return fn(); });
    var xhr3 = new MockXhr();
    xmlHttpRequestProps.forEach(function (prop) {
        xhr3[prop] = cbs[prop];
    });
    xhr3.send();
    xmlHttpRequestProps.forEach(function (prop) {
        t.throws(function () { return xhr3[prop](); });
        t.is(reportStub.callCount, 0);
        reportStub.reset();
    });
    // but never restore xhr instance callback
    xmlHttpRequestProps.forEach(function (prop) {
        t.throws(function () { return xhr2[prop](); });
        t.is(reportStub.callCount, 1);
        reportStub.reset();
    });
});
test('should xhr is hooked and capture error when an instance is reused multiple times', function (t) {
    // mock env
    var window = {};
    var MockXhr = Function;
    MockXhr.prototype.send = sinon.stub();
    var reportStub = sinon.stub();
    hookGlobalAsync(reportStub, window, MockXhr);
    // 1. 假设一个 xhr 被反复使用，但回调函数不变
    var cbs1 = {};
    xmlHttpRequestProps.forEach(function (prop) {
        var cb = function () {
            throw new Error('test');
        };
        cbs1[prop] = cb;
    });
    var xhr1 = new MockXhr();
    xmlHttpRequestProps.forEach(function (prop) {
        xhr1[prop] = cbs1[prop];
    });
    // send once
    xhr1.send();
    xmlHttpRequestProps.forEach(function (prop) {
        t.throws(function () { return xhr1[prop](); });
        t.true(xhr1[prop]._hook_);
        t.is(reportStub.callCount, 1);
        var _a = reportStub.getCall(0).args[0], error = _a.error, source = _a.source;
        t.like(error, { message: 'test', name: 'Error' });
        t.deepEqual(source, {
            data: {
                function: prop,
            },
            type: 'capture-global',
        });
        reportStub.reset();
    });
    // send twice
    xhr1.send();
    xmlHttpRequestProps.forEach(function (prop) {
        t.throws(function () { return xhr1[prop](); });
        t.true(xhr1[prop]._hook_);
        t.is(reportStub.callCount, 1);
        var _a = reportStub.getCall(0).args[0], error = _a.error, source = _a.source;
        t.like(error, { message: 'test', name: 'Error' });
        t.deepEqual(source, {
            data: {
                function: prop,
            },
            type: 'capture-global',
        });
        reportStub.reset();
    });
    // 要求回调函数永远不被反复 hook
    xmlHttpRequestProps.forEach(function (prop) {
        t.is(xhr1[prop], cbs1[prop]._w_);
        t.true(isFunction(cbs1[prop]._w_));
    });
    // 2. 假设一个 xhr 被反复使用，且每次都是新的回调函数
    var xhr2 = new MockXhr();
    // send once
    xmlHttpRequestProps.forEach(function (prop) {
        xhr2[prop] = function () {
            throw new Error('test');
        };
    });
    xhr2.send();
    xmlHttpRequestProps.forEach(function (prop) {
        t.throws(function () { return xhr2[prop](); });
        t.true(xhr2[prop]._hook_);
        t.is(reportStub.callCount, 1);
        var _a = reportStub.getCall(0).args[0], error = _a.error, source = _a.source;
        t.like(error, { message: 'test', name: 'Error' });
        t.deepEqual(source, {
            data: {
                function: prop,
            },
            type: 'capture-global',
        });
        reportStub.reset();
    });
    // send twice
    xmlHttpRequestProps.forEach(function (prop) {
        xhr2[prop] = function () {
            throw new Error('test');
        };
    });
    xhr2.send();
    xmlHttpRequestProps.forEach(function (prop) {
        t.throws(function () { return xhr2[prop](); });
        t.true(xhr2[prop]._hook_);
        t.is(reportStub.callCount, 1);
        var _a = reportStub.getCall(0).args[0], error = _a.error, source = _a.source;
        t.like(error, { message: 'test', name: 'Error' });
        t.deepEqual(source, {
            data: {
                function: prop,
            },
            type: 'capture-global',
        });
        reportStub.reset();
    });
});
test('should addEventListener is hooked and capture error', function (t) {
    // moc env
    var window = {};
    var eventBus = {};
    DEFAULT_EVENT_TARGET.forEach(function (target) {
        window[target] = {};
        window[target].prototype = {
            eventBus: {},
            addEventListener: function (evName, cb) {
                if (!Array.isArray(eventBus[evName])) {
                    eventBus[evName] = [];
                }
                eventBus[evName].push(cb);
            },
            removeEventListener: function (evName, cb) {
                eventBus[evName] = eventBus[evName].filter(function (fn) { return fn !== cb; });
            },
            trigger: function (evName) {
                eventBus[evName].forEach(function (fn) { return fn(); });
            },
        };
    });
    var reportStub = sinon.stub();
    var restoreFns = hookGlobalAsync(reportStub, window);
    // test
    DEFAULT_EVENT_TARGET.forEach(function (target) {
        var cb = function () {
            throw new Error('test');
        };
        var eventName = "ev_" + target;
        window[target].prototype.addEventListener(eventName, cb);
        t.throws(function () { return window[target].prototype.trigger(eventName); });
        var _a = reportStub.getCall(0).args[0], error = _a.error, source = _a.source;
        t.like(error, { message: 'test', name: 'Error' });
        t.deepEqual(source, {
            data: {
                function: 'addEventListener',
                target: target,
            },
            type: 'capture-global',
        });
        t.true(isFunction(cb._w_));
        reportStub.reset();
        window[target].prototype.removeEventListener(eventName, cb);
        window[target].prototype.trigger(eventName);
        t.false(reportStub.called);
    });
    // restore event listener hook
    restoreFns.forEach(function (fn) { return fn(); });
    DEFAULT_EVENT_TARGET.forEach(function (target) {
        var cb = function () {
            throw new Error('test');
        };
        var eventName = "ev_" + target;
        window[target].prototype.addEventListener(eventName, cb);
        t.throws(function () { return window[target].prototype.trigger(eventName); });
        t.false(reportStub.called);
        t.false(isFunction(cb._w_));
        window[target].prototype.removeEventListener(eventName, cb);
        window[target].prototype.trigger(eventName);
        t.false(reportStub.called);
    });
});
test('should capture error if fn.handleEvent is a function', function (t) {
    // moc env
    var window = {};
    var eventBus = {};
    DEFAULT_EVENT_TARGET.forEach(function (target) {
        window[target] = {};
        window[target].prototype = {
            eventBus: {},
            addEventListener: function (evName, cb) {
                if (!Array.isArray(eventBus[evName])) {
                    eventBus[evName] = [];
                }
                eventBus[evName].push(cb);
            },
            removeEventListener: function (evName, cb) {
                eventBus[evName] = eventBus[evName].filter(function (fn) { return fn !== cb; });
            },
            trigger: function (evName) {
                eventBus[evName].forEach(function (fn) { return fn(); });
            },
        };
    });
    var reportStub = sinon.stub();
    var restoreFns = hookGlobalAsync(reportStub, window);
    // test
    DEFAULT_EVENT_TARGET.forEach(function (target) {
        var cb = function () {
            throw new Error('test');
        };
        cb.handleEvent = function cb2() {
            throw Error('test2');
        };
        var eventName = "ev_" + target;
        window[target].prototype.addEventListener(eventName, cb);
        t.throws(function () { return window[target].prototype.trigger(eventName); });
        var _a = reportStub.getCall(0).args[0], error = _a.error, source = _a.source;
        t.like(error, { message: 'test2', name: 'Error' });
        t.deepEqual(source, {
            data: {
                function: 'handleEvent',
                target: target,
            },
            type: 'capture-global',
        });
        t.true(isFunction(cb._w_));
        t.false(isFunction(cb.handleEvent._w_));
        reportStub.reset();
        window[target].prototype.removeEventListener(eventName, cb);
        window[target].prototype.trigger(eventName);
        t.false(reportStub.called);
    });
    // restore event listener hook
    restoreFns.forEach(function (fn) { return fn(); });
    DEFAULT_EVENT_TARGET.forEach(function (target) {
        var cb = function () {
            throw new Error('test');
        };
        var eventName = "ev_" + target;
        window[target].prototype.addEventListener(eventName, cb);
        t.throws(function () { return window[target].prototype.trigger(eventName); });
        t.false(reportStub.called);
        t.false(isFunction(cb._w_));
        window[target].prototype.removeEventListener(eventName, cb);
        window[target].prototype.trigger(eventName);
        t.false(reportStub.called);
    });
});
//# sourceMappingURL=js-error.spec.js.map