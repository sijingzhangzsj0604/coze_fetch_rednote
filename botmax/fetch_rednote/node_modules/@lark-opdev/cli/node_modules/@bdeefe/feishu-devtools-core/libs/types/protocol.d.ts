export declare enum ModuleName {
    storage = "Storage",
    ui = "UI",
    simulator = "Simulator",
    devtools = "Devtools",
    account = "Account",
    compile = "Compile",
    creator = "Creator",
    jssdk = "JsSdk",
    performance = "Performance",
    preview = "Preview",
    upload = "Upload",
    service = "Service",
    feedback = "Feedback",
    eventTracker = "EventTracker",
    sniffer = "sniffer",
    auto = "auto",
    debugger = "debugger",
    debuggerBlock = "debuggerBlock",
    static = "static"
}
export declare type CommonModule = 'Common';
export declare type EventType = '';
export interface EventData {
    type: EventType;
    params: any;
}
export declare type ModuleEventMap<K extends string = never> = {
    [k in K]: EventData;
};
export declare type EventParam<E extends ModuleEventMap, N extends keyof E, K extends keyof EventData> = E[N] extends EventData ? E[N][K] : never;
export declare type ModuleCmdMap<K extends string = never> = {
    [k in K]: (...args: any[]) => any;
};
export declare type CmdFun<T extends (...args: any[]) => any> = T extends (m: ModuleName, c: any, ...args: infer P) => infer R ? (...args: P) => R : never;
export declare type CmdParam<F extends (...args: any[]) => any> = Parameters<CmdFun<F>>;
export declare type CmdReturn<F extends (...args: any[]) => any> = ReturnType<CmdFun<F>>;
export declare type CmdInput<N extends string | number | symbol, F extends ModuleCmdMap> = F extends {
    [k in N]: (...args: infer P) => any;
} ? P : never;
export declare type CmdOutput<N extends string | number | symbol, F extends ModuleCmdMap> = F extends {
    [k in N]: (...args: any[]) => infer R;
} ? R : never;
export interface ModuleDesc<E extends ModuleEventMap = {}, C extends ModuleCmdMap = {}, D extends ModuleName = never> {
    eventNames: (keyof E)[];
    commandNames: (keyof C)[];
    dependencies: D[];
}
