"use strict";
/* ---------------------------------------------------------------------------------------------
 * MIT License Copyright (c) 2020 Dani All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * https://github.com/Daninet/hash-wasm
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.WASMInterface = exports.MAX_HEAP = void 0;
// copy and modified from https://github.com/Daninet/hash-wasm/blob/bd3a205ca5603fc80adf71d0966fc72e8d4fa0ef/lib/WASMInterface.ts
const mutex_1 = require("./mutex");
const util_1 = require("./util");
exports.MAX_HEAP = 16 * 1024;
const WASM_FUNC_HASH_LENGTH = 4;
const wasmMutex = new mutex_1.Mutex();
const wasmModuleCache = new Map();
async function WASMInterface(binary, hashLength) {
    let wasmInstance = null;
    let memoryView = null;
    let initialized = false;
    if (typeof WebAssembly === 'undefined') {
        throw new Error('WebAssembly is not supported in this environment!');
    }
    const writeMemory = (data, offset = 0) => {
        memoryView === null || memoryView === void 0 ? void 0 : memoryView.set(data, offset);
    };
    const getMemory = () => memoryView;
    const getExports = () => wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports;
    const setMemorySize = (totalSize) => {
        (wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports).Hash_SetMemorySize(totalSize);
        const arrayOffset = (wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports).Hash_GetBuffer();
        const memoryBuffer = (wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports).memory.buffer;
        memoryView = new Uint8Array(memoryBuffer, arrayOffset, totalSize);
    };
    const getStateSize = () => {
        const view = new DataView((wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports).memory.buffer);
        const stateSize = view.getUint32((wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports).STATE_SIZE, true);
        return stateSize;
    };
    const loadWASMPromise = wasmMutex.dispatch(async () => {
        if (!wasmModuleCache.has(binary.name)) {
            const asm = (0, util_1.decodeBase64)(binary.data);
            const promise = WebAssembly.compile(asm);
            wasmModuleCache.set(binary.name, promise);
        }
        const module = await wasmModuleCache.get(binary.name);
        wasmInstance = await WebAssembly.instantiate(module);
    });
    const setupInterface = async () => {
        if (!wasmInstance) {
            await loadWASMPromise;
        }
        const arrayOffset = (wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports).Hash_GetBuffer();
        const memoryBuffer = (wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports).memory.buffer;
        memoryView = new Uint8Array(memoryBuffer, arrayOffset, exports.MAX_HEAP);
    };
    const init = (bits = null) => {
        initialized = true;
        (wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports).Hash_Init(bits);
    };
    const updateUInt8Array = (data) => {
        let read = 0;
        while (read < data.length) {
            const chunk = data.subarray(read, read + exports.MAX_HEAP);
            read += chunk.length;
            memoryView === null || memoryView === void 0 ? void 0 : memoryView.set(chunk);
            (wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports).Hash_Update(chunk.length);
        }
    };
    const update = (data) => {
        if (!initialized) {
            throw new Error('update() called before init()');
        }
        const Uint8Buffer = (0, util_1.getUInt8Buffer)(data);
        updateUInt8Array(Uint8Buffer);
    };
    const digestChars = new Uint8Array(hashLength * 2);
    const digest = (outputType, padding = null) => {
        if (!initialized) {
            throw new Error('digest() called before init()');
        }
        initialized = false;
        (wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports).Hash_Final(padding);
        if (outputType === 'binary') {
            // the data is copied to allow GC of the original memory object
            return memoryView.slice(0, hashLength);
        }
        return (0, util_1.getDigestHex)(digestChars, memoryView, hashLength);
    };
    const save = () => {
        if (!initialized) {
            throw new Error('save() can only be called after init() and before digest()');
        }
        const stateOffset = (wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports).Hash_GetState();
        const stateLength = getStateSize();
        const memoryBuffer = (wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports).memory.buffer;
        const internalState = new Uint8Array(memoryBuffer, stateOffset, stateLength);
        // prefix is 4 bytes from SHA1 hash of the WASM binary
        // it is used to detect incompatible internal states between different versions of hash-wasm
        const prefixedState = new Uint8Array(WASM_FUNC_HASH_LENGTH + stateLength);
        (0, util_1.writeHexToUInt8)(prefixedState, binary.hash);
        prefixedState.set(internalState, WASM_FUNC_HASH_LENGTH);
        return prefixedState;
    };
    const load = (state) => {
        if (!(state instanceof Uint8Array)) {
            throw new Error('load() expects an Uint8Array generated by save()');
        }
        const stateOffset = (wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports).Hash_GetState();
        const stateLength = getStateSize();
        const overallLength = WASM_FUNC_HASH_LENGTH + stateLength;
        const memoryBuffer = (wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports).memory.buffer;
        if (state.length !== overallLength) {
            throw new Error(`Bad state length (expected ${overallLength} bytes, got ${state.length})`);
        }
        if (!(0, util_1.hexStringEqualsUInt8)(binary.hash, state.subarray(0, WASM_FUNC_HASH_LENGTH))) {
            throw new Error('This state was written by an incompatible hash implementation');
        }
        const internalState = state.subarray(WASM_FUNC_HASH_LENGTH);
        new Uint8Array(memoryBuffer, stateOffset, stateLength).set(internalState);
        initialized = true;
    };
    const isDataShort = (data) => {
        if (typeof data === 'string') {
            // worst case is 4 bytes / char
            return data.length < exports.MAX_HEAP / 4;
        }
        return data.byteLength < exports.MAX_HEAP;
    };
    let canSimplify = isDataShort;
    switch (binary.name) {
        case 'argon2':
        case 'scrypt':
            canSimplify = () => true;
            break;
        case 'blake2b':
        case 'blake2s':
            // if there is a key at blake2 then cannot simplify
            canSimplify = (data, initParam) => initParam <= 512 && isDataShort(data);
            break;
        case 'blake3':
            // if there is a key at blake3 then cannot simplify
            canSimplify = (data, initParam) => initParam === 0 && isDataShort(data);
            break;
        case 'xxhash64': // cannot simplify
        case 'xxhash3':
        case 'xxhash128':
            canSimplify = () => false;
            break;
        default:
            break;
    }
    // shorthand for (init + update + digest) for better performance
    const calculate = (data, initParam = null, digestParam = null) => {
        if (!canSimplify(data, initParam)) {
            init(initParam);
            update(data);
            return digest('hex', digestParam);
        }
        const buffer = (0, util_1.getUInt8Buffer)(data);
        memoryView === null || memoryView === void 0 ? void 0 : memoryView.set(buffer);
        (wasmInstance === null || wasmInstance === void 0 ? void 0 : wasmInstance.exports).Hash_Calculate(buffer.length, initParam, digestParam);
        return (0, util_1.getDigestHex)(digestChars, memoryView, hashLength);
    };
    await setupInterface();
    return {
        getMemory,
        writeMemory,
        getExports,
        setMemorySize,
        init,
        update,
        digest,
        save,
        load,
        calculate,
        hashLength,
    };
}
exports.WASMInterface = WASMInterface;
//# sourceMappingURL=WASMInterface.js.map