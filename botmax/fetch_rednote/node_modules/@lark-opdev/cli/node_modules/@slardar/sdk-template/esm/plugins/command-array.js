import { __read, __spreadArray } from "tslib";
import { hookObjectProperty, log, safeCall } from '../utils';
export var withCommandArray = function (client, captureContext, applyArgsWithContext) {
    // 缓存需要异步插件来消费的命令
    var cache = {};
    var newClient = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var methodPath = args[0];
        if (!methodPath)
            return;
        var method = methodPath.split('.')[0];
        // 捕获上下文，等异步插件加载后传入
        if (!(method in newClient)) {
            var cachedCommands = cache[method] || [];
            // 区分预收集来的上下文与普通上下文
            var capturedContext = (_a = captureContext === null || captureContext === void 0 ? void 0 : captureContext(client)) !== null && _a !== void 0 ? _a : {};
            cachedCommands.push(__spreadArray([capturedContext], __read(args), false));
            cache[method] = cachedCommands;
            return;
        }
        return safeCall(newClient, methodPath, [].slice.call(args, 1));
    };
    hookObjectProperty(client, 'provide', function (origin) {
        return function (name, value) {
            newClient[name] = value;
            origin.call(client, name, value);
        };
    })();
    for (var nextKey in client) {
        // Avoid bugs when hasOwnProperty is shadowed
        if (Object.prototype.hasOwnProperty.call(client, nextKey)) {
            newClient[nextKey] = client[nextKey];
        }
    }
    client.on('provide', function (name) {
        if (cache[name]) {
            cache[name].forEach(function (cachedCommands) {
                var _a = __read(cachedCommands), capturedContext = _a[0], args = _a.slice(1);
                applyArgsWithContext === null || applyArgsWithContext === void 0 ? void 0 : applyArgsWithContext(client, capturedContext, args);
            });
            cache[name] = null;
        }
    });
    return newClient;
};
//# sourceMappingURL=command-array.js.map