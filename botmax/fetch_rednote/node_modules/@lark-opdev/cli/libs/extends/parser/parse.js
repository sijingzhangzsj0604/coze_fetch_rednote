"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const parse_1 = require("@oclif/parser/lib/parse");
const deps_1 = __importDefault(require("@oclif/parser/lib/deps"));
const m = (0, deps_1.default)()
    .add('errors', () => require('@oclif/parser/lib/errors'))
    .add('util', () => require('@oclif/parser/lib/util'));
__exportStar(require("@oclif/parser/lib/parse"), exports);
class Parser extends parse_1.Parser {
    parse() {
        this._debugInput();
        const findLongFlag = (arg) => {
            const name = arg.slice(2);
            if (this.input.flags[name]) {
                return name;
            }
            if (arg.startsWith('--no-')) {
                const flag = this.booleanFlags[arg.slice(5)];
                if (flag && flag.allowNo) {
                    return flag.name;
                }
            }
        };
        const findShortFlag = (arg) => {
            return Object.keys(this.input.flags).find(k => this.input.flags[k].char === arg[1]);
        };
        const parseFlag = (arg) => {
            const long = arg.startsWith('--');
            const name = long ? findLongFlag(arg) : findShortFlag(arg);
            if (!name) {
                const i = arg.indexOf('=');
                if (i !== -1) {
                    const sliced = arg.slice(i + 1);
                    this.argv.unshift(sliced);
                    const equalsParsed = parseFlag(arg.slice(0, i));
                    if (!equalsParsed) {
                        this.argv.shift();
                    }
                    return equalsParsed;
                }
                return false;
            }
            const flag = this.input.flags[name];
            if (flag.type === 'option') {
                this.currentFlag = flag;
                let input;
                if (long || arg.length < 3) {
                    input = this.argv.shift();
                }
                else {
                    input = arg.slice(arg[2] === '=' ? 3 : 2);
                }
                if (typeof input !== 'string' && !!input) {
                    throw new m.errors.CLIError(`Flag --${name} expects a value`);
                }
                this.raw.push({ type: 'flag', flag: flag.name, input });
            }
            else {
                this.raw.push({ type: 'flag', flag: flag.name, input: arg });
                if (!long && arg.length > 2) {
                    this.argv.unshift(`-${arg.slice(2)}`);
                }
            }
            return true;
        };
        let parsingFlags = true;
        while (this.argv.length) {
            const input = this.argv.shift();
            if (parsingFlags && input.startsWith('-') && input !== '-') {
                if (this.input['--'] !== false && input === '--') {
                    parsingFlags = false;
                    continue;
                }
                if (parseFlag(input)) {
                    continue;
                }
            }
            if (parsingFlags && this.currentFlag && this.currentFlag.multiple) {
                this.raw.push({ type: 'flag', flag: this.currentFlag.name, input });
                continue;
            }
            const arg = this.input.args[this._argTokens.length];
            if (arg) {
                arg.input = input;
            }
            this.raw.push({ type: 'arg', input });
        }
        const argv = this._argv();
        const args = this._args(argv);
        const flags = this._flags();
        this._debugOutput(argv, args, flags);
        return {
            args,
            argv,
            flags,
            raw: this.raw,
            metadata: this.metaData,
        };
    }
    _flags() {
        const flags = {};
        this.metaData.flags = {};
        for (const token of this._flagTokens) {
            const flag = this.input.flags[token.flag];
            if (!flag) {
                throw new m.errors.CLIError(`Unexpected flag ${token.flag}`);
            }
            if (flag.type === 'boolean') {
                if (token.input === `--no-${flag.name}`) {
                    flags[token.flag] = false;
                }
                else {
                    flags[token.flag] = true;
                }
                flags[token.flag] = flag.parse(flags[token.flag], this.context);
            }
            else {
                if (flag.options && !!token.input) {
                    token.input = token.input.toLowerCase();
                }
                const input = token.input;
                if (flag.options && !flag.options.includes(input) && !!input) {
                    throw new m.errors.FlagInvalidOptionError(flag, input);
                }
                const value = flag.parse ? flag.parse(input, this.context) : input;
                if (flag.multiple) {
                    flags[token.flag] = flags[token.flag] || [];
                    flags[token.flag].push(value);
                }
                else {
                    flags[token.flag] = value;
                }
            }
        }
        for (const k of Object.keys(this.input.flags)) {
            const flag = this.input.flags[k];
            if (flags[k]) {
                continue;
            }
            if (flag.type === 'option' && flag.env) {
                const input = process.env[flag.env];
                if (input) {
                    flags[k] = flag.parse(input, this.context);
                }
            }
            if (!(k in flags) && flag.default !== undefined) {
                this.metaData.flags[k] = { setFromDefault: true };
                if (typeof flag.default === 'function') {
                    flags[k] = flag.default(Object.assign({ options: flag, flags }, this.context));
                }
                else {
                    flags[k] = flag.default;
                }
            }
        }
        return flags;
    }
}
exports.Parser = Parser;
