import 'reflect-metadata';
import { Token, InstanceOpts, MethodName, IBeforeAspectHookFunction, IAfterAspectHookFunction, IAroundAspectHookFunction, IHookOptions, IAfterReturningAspectHookFunction, IAfterThrowingAspectHookFunction, IAroundHookOptions } from './declare';
/**
 * 装饰一个 Class 是否是可以被依赖注入
 * @param opts
 */
export declare function Injectable(opts?: InstanceOpts): ClassDecorator;
interface InjectOpts {
    /**
     * 默认值
     */
    default?: any;
}
/**
 * 把构造函数的参数和一个特定的注入标记关联起来
 * @param token
 */
export declare function Inject(token: Token, opts?: InjectOpts): ParameterDecorator;
/**
 * 构造函数可选依赖的装饰器
 * @param token
 */
export declare function Optional(token?: Token): ParameterDecorator;
/**
 * 装饰一个类的属性，当这个属性被访问的时候，才开始使用注射器创建实例
 * @param token
 */
export declare function Autowired(token?: Token, opts?: InstanceOpts): PropertyDecorator;
/**
 * 声明这是一个包含了 Hook 的 Class
 *
 * @description
 *    典型用法
 *
 *    const AToken = Symbol('AToken');
 *
 *    interface AToken {
 *      add(a: number): number
 *    }
 *
 *    @Injectable()
 *    Class AImpl {
 *
 *       private sum = 0;
 *
 *       add(a: number) {
 *          this.sum += a;
 *          return this.sum;
 *       }
 *
 *    }
 *
 *    @Aspect()
 *    @Injectable()
 *    Class OneAspectOfA {
 *
 *       // 拦截 AToken 实现 class 的 add 方法，在 add 方法执行前，将它的参数乘以2
 *       @Before(AToken, 'add')
 *       beforeAdd(joinPoint: IBeforeJoinPoint<AToken, [number], number>) {
 *          const [a] = joinPoint.getArgs();
 *          joinPoint.setArgs([a * 2]);
 *       }
 *
 *       @After(AToken, 'add')
 *       afterAdd(joinPoint: IAfterJoinPoint<AToken, [number], number>) {
 *          const ret = joinPoint.getResult();
 *          joinPoint.setResult(ret * 5); // 将返回值乘以5
 *       }
 *    }
 *
 *    // 必须添加 Aspect 的 class
 *    injector.addProviders(OneAspectOfA);
 *
 *    这种情况下，第一次调用 const hookedSum = injector.get(AToken).add(2) 后,
 *    AImpl 中的 sum 为 4, hookedSum 为 20
 */
export declare function Aspect(): (target: any) => void;
/**
 * 在方法执行前进行 hook
 *    @Before(AToken, 'add')
 *    beforeAdd(joinPoint: IBeforeJoinPoint<AToken, [number, number], number>) {
 *      const [a, b] = joinPoint.getArgs();
 *      joinPoint.setArgs([a * 10, b * 10]);
 *    }
 * hook 的顺序遵循洋葱模型
 * @param token
 * @param method
 */
export declare function Before<ThisType = any, Args extends any[] = any, Result = any>(token: Token, method: MethodName, options?: IHookOptions): <T extends Record<K, IBeforeAspectHookFunction<ThisType, Args, Result>>, K extends MethodName>(target: T, property: K) => void;
/**
 * 在方法结束后进行 hook
 *    @After(AToken, 'add')
 *    afterAdd(joinPoint: IAfterJoinPoint<AToken, [number, number], number>) {
 *      const ret = joinPoint.getResult();
 *      joinPoint.setResult(ret * 10); // 将返回值乘以10
 *    }
 * hook 的顺序遵循洋葱模型
 * @param token
 * @param method
 */
export declare function After<ThisType = any, Args extends any[] = any, Result = any>(token: Token, method: MethodName, options?: IHookOptions): <T extends Record<K, IAfterAspectHookFunction<ThisType, Args, Result>>, K extends MethodName>(target: T, property: K) => void;
/**
 * 环绕型 Hook
 *    @Around(AToken, 'add')
 *    aroundAdd(joinPoint: IAroundJoinPoint<AToken, [number, number], number>) {
 *      const [a, b] = joinPoint.getArgs();
 *      if (a === b) {
 *        console.log('adding two same numbers');
 *      }
 *      joinPoint.proceed();
 *      const result = joinPoint.getResult();
 *      if (result === 10) {
 *         joinPoint.setResult(result * 10);
 *      }
 *    }
 * around 型 hook 是先来的被后来的包裹
 * @param token
 * @param method
 * @description
 */
export declare function Around<ThisType = any, Args extends any[] = any, Result = any>(token: Token, method: MethodName, options?: IAroundHookOptions): <T extends Record<K, IAroundAspectHookFunction<ThisType, Args, Result>>, K extends MethodName>(target: T, property: K) => void;
/**
 * 在方法结束（并且回调给外层之后）后进行 hook
 *    @AfterReturning(AToken, 'add')
 *    afterReturningAdd(joinPoint: IAfterReturningJoinPoint<AToken, [number, number], number>) {
 *      const ret = joinPoint.getResult();
 *      console.log('the return value is ' + ret);
 *    }
 * hook 全都会执行, 即使出错
 * @param token
 * @param method
 * @param options
 */
export declare function AfterReturning<ThisType = any, Args extends any[] = any, Result = any>(token: Token, method: MethodName, options?: IHookOptions): <T extends Record<K, IAfterReturningAspectHookFunction<ThisType, Args, Result>>, K extends MethodName>(target: T, property: K) => void;
/**
 * 在方法抛出异常（或者PromiseRejection）后进行 hook
 *    @AfterThrowing(AToken, 'add')
 *    afterThrowingAdd(joinPoint: IAfterReturningJoinPoint<AToken, [number, number], number>) {
 *      const error = joinPoint.getError();
 *      console.error('产生了一个错误', error);
 *    }
 * hook 全都会执行, 即使出错
 * @param token
 * @param method
 * @param options
 */
export declare function AfterThrowing<ThisType = any, Args extends any[] = any, Result = any>(token: Token, method: MethodName, options?: IHookOptions): <T extends Record<K, IAfterThrowingAspectHookFunction<ThisType, Args, Result>>, K extends MethodName>(target: T, property: K) => void;
export {};
