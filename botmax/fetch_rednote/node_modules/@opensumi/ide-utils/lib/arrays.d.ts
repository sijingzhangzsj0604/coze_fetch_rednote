import { IDisposable } from './disposable';
import { ISplice } from './sequence';
export declare function asStringArray(array: unknown, defaultValue: string[]): string[];
export declare function isNonEmptyArray<T>(obj: ReadonlyArray<T> | undefined | null): obj is Array<T>;
/**
 * 移除给定数组中的重复值
 * keyFn函数支持指定校验逻辑
 */
export declare function distinct<T>(array: ReadonlyArray<T>, keyFn?: (t: T) => string): T[];
/**
 * Diffs two *sorted* arrays and computes the splices which apply the diff.
 */
export declare function sortedDiff<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): ISplice<T>[];
export declare function equals<T>(one: ReadonlyArray<T> | undefined, other: ReadonlyArray<T> | undefined, itemEquals?: (a: T, b: T) => boolean): boolean;
export declare function asArray<T>(x: T | T[]): T[];
export declare function asArray<T>(x: T | readonly T[]): readonly T[];
/**
 * 获取非空数组
 * @param array
 */
export declare function coalesce<T>(array: ReadonlyArray<T | undefined | null>): T[];
export declare function addElement<T>(array: Array<T>, element: T, unshift?: boolean): IDisposable;
export declare function addMapElement<K, T>(map: Map<K, T>, key: K, element: T): IDisposable;
type NonFunctional<T> = T extends Function ? never : T;
export declare function enumValueToArray<T extends object>(enumeration: T): NonFunctional<T[keyof T]>[];
/**
 * @returns false if the provided object is an array and not empty.
 */
export declare function isFalsyOrEmpty(obj: any): boolean;
export declare function flatten<T>(arr: T[][]): T[];
export declare function range(to: number): number[];
export declare function fill<T>(num: number, value: T, arr?: T[]): T[];
/**
 * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false
 * are located before all elements where p(x) is true.
 * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.
 */
export declare function findFirstInSorted<T>(array: ReadonlyArray<T>, p: (x: T) => boolean): number;
type Compare<T> = (a: T, b: T) => number;
/**
 * Like `Array#sort` but always stable. Usually runs a little slower `than Array#sort`
 * so only use this when actually needing stable sort.
 */
export declare function mergeSort<T>(data: T[], compare: Compare<T>): T[];
/**
 * Returns the first mapped value of the array which is not undefined.
 */
export declare function mapFind<T, R>(array: Iterable<T>, mapFn: (value: T) => R | undefined): R | undefined;
export declare function groupBy<T>(data: ReadonlyArray<T>, compare: (a: T, b: T) => number): T[][];
export {};
//# sourceMappingURL=arrays.d.ts.map