"use strict";
/* ---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Some code copied and modified from https://github.com/microsoft/vscode/blob/1.44.0/src/vs/base/common/linkedText.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseLinkedText = exports.LinkedText = void 0;
const tslib_1 = require("tslib");
const decorators_1 = require("./decorators");
class LinkedText {
    constructor(nodes) {
        this.nodes = nodes;
    }
    toString() {
        return this.nodes.map((node) => (typeof node === 'string' ? node : node.label)).join('');
    }
}
tslib_1.__decorate([
    decorators_1.memoize,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", String)
], LinkedText.prototype, "toString", null);
exports.LinkedText = LinkedText;
const LINK_REGEX = /\[([^\]]+)\]\(((?:https?:\/\/|command:)[^\)\s]+)(?: ("|')([^\3]+)(\3))?\)/gi;
function parseLinkedText(text) {
    const result = [];
    let index = 0;
    let match;
    while ((match = LINK_REGEX.exec(text))) {
        if (match.index - index > 0) {
            result.push(text.substring(index, match.index));
        }
        const [, label, href, , title] = match;
        if (title) {
            result.push({ label, href, title });
        }
        else {
            result.push({ label, href });
        }
        index = match.index + match[0].length;
    }
    if (index < text.length) {
        result.push(text.substring(index));
    }
    return new LinkedText(result);
}
exports.parseLinkedText = parseLinkedText;
//# sourceMappingURL=linked-text.js.map