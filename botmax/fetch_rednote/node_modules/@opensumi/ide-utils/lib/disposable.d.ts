import { Event, Emitter } from './event';
export declare class DisposableStore implements IDisposable {
    private toDispose;
    private _isDisposed;
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    dispose(): void;
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    clear(): void;
    add<T extends IDisposable>(t: T): T;
}
export interface IDisposable {
    /**
     * Dispose this object.
     */
    dispose(): void;
}
export declare function isDisposable<E extends object>(thing: E): thing is E & IDisposable;
export declare function dispose<T extends IDisposable>(disposable: T): T;
export declare function dispose<T extends IDisposable>(...disposables: Array<T | undefined>): T[];
export declare function dispose<T extends IDisposable>(disposables: T[]): T[];
export declare function combinedDisposable(disposables: IDisposable[]): IDisposable;
export declare function toDisposable(fn: () => void): IDisposable;
export declare class Disposable implements IDisposable {
    protected readonly disposables: IDisposable[];
    protected readonly onDisposeEmitter: Emitter<void>;
    constructor(...toDispose: IDisposable[]);
    static create(func: () => void): IDisposable;
    static NULL: IDisposable;
    static None: Readonly<IDisposable>;
    get onDispose(): Event<void>;
    protected checkDisposed(): void;
    get disposed(): boolean;
    private disposingElements;
    dispose(): void;
    addDispose(disposable: IDisposable): IDisposable;
    addDispose(disposable: IDisposable[]): IDisposable[];
    protected registerDispose<T extends IDisposable>(disposable: T): T;
    private add;
}
export declare class DisposableCollection implements IDisposable {
    protected readonly disposables: IDisposable[];
    protected readonly onDisposeEmitter: Emitter<void>;
    constructor(...toDispose: IDisposable[]);
    get onDispose(): Event<void>;
    protected checkDisposed(): void;
    get disposed(): boolean;
    private disposingElements;
    dispose(): void;
    push(disposable: IDisposable): IDisposable;
    pushAll(disposables: IDisposable[]): IDisposable[];
}
/**
 * Manages the lifecycle of a disposable value that may be changed.
 *
 * This ensures that when the the disposable value is changed, the previously held disposable is disposed of. You can
 * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.
 */
export declare class MutableDisposable<T extends IDisposable> implements IDisposable {
    private _value?;
    private _isDisposed;
    constructor();
    get value(): T | undefined;
    set value(value: T | undefined);
    clear(): void;
    dispose(): void;
}
export declare class RefCountedDisposable {
    private readonly _disposable;
    private _counter;
    constructor(_disposable: IDisposable);
    acquire(): this;
    release(): this;
}
export declare class DisposableMap extends Map<string, IDisposable> implements IDisposable {
    disposeKey(key: string): void;
    dispose(): void;
}
//# sourceMappingURL=disposable.d.ts.map