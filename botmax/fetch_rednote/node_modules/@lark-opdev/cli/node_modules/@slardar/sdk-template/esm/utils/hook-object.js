import { __read, __spreadArray } from "tslib";
import { isFunction } from './is';
import { noop } from './misc';
// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * You can feel free to restore when you hook a function.
 * But you ought to restore 「in order」 if you hooked a value reference or a real obj reference.Because we not store the last value referent for now.
 * eg: obj.a = 1;
 * const r_1 = hookObjectProperty(obj, 'a',() =>2)()
 * const r_2 = hookObjectProperty(obj, 'a',() =>3)()
 * r_2() // obj.a === 2
 * r_1() // obj.a === 1
 *
 * @template T
 * @template K
 * @template P
 * @param {T} obj
 * @param {K} key
 * @param {(origin: T[K], ...params: P) => T[K]} hookFunc
 * @param {boolean} isCatchError When an error occurs after calling a hooked function, we want to suppress the errors and try to call the original function by default.
 * @return {*}
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export var hookObjectProperty = function (obj, key, hookFunc, isCatchError) {
    if (isCatchError === void 0) { isCatchError = true; }
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, __spreadArray([origin], __read(params), false));
        var hooked = hookedUnsafe;
        // 给所有 hook 之后的方法包一层 try catch
        if (isFunction(hooked) && isCatchError) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                try {
                    return hookedUnsafe.apply(this, args);
                }
                catch (_a) {
                    return isFunction(origin) && origin.apply(this, args);
                }
            };
        }
        obj[key] = hooked;
        // strict: is break
        return function (strict) {
            if (!strict) {
                hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
            }
        };
    };
};
/**
 * 劫持对象方法
 * 必须记得给 hookFunc 劫持的方法包 try catch ！
 * 不在本方法里包是为了避免对象原方法被调用两次
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export var hookMethodDangerously = function (obj, key, hookFunc) {
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, __spreadArray([origin], __read(params), false));
        var hooked = hookedUnsafe;
        if (isFunction(hooked)) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return hookedUnsafe.apply(this, args);
            };
        }
        obj[key] = hooked;
        return function () {
            hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
        };
    };
};
//# sourceMappingURL=hook-object.js.map