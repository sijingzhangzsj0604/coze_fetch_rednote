import { __read } from "tslib";
/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
/* eslint-disable @typescript-eslint/prefer-optional-chain */
import { isFunction, noop } from '@slardar/sdk-template';
import { getDefaultDocument, getDefaultMutationObserver, getDefaultPerformanceTiming, applyMutationObserver, applyAnimationFrame, applyMonitor, invokeCallbackOnce, getDefaultRaf, getDefaultCaf, now, } from '../../../utils';
import { PaintMonitor, FCP_ENTRY_NAME } from '../paint-monitor';
import { initMetric, buildSingleMetricPayload } from '../util';
var FMPMonitorMetricName = 'fmp';
var RENDER_TYPR_SSR = 'SSR';
var DEFAULT_IGNORE_TAGS = ['SCRIPT', 'STYLE', 'META', 'HEAD'];
var getScore = function (element, depth, exist, ignoreTags) {
    if (!element || ignoreTags.indexOf(element.tagName) > -1) {
        return 0;
    }
    var _a = element.children, children = _a === void 0 ? [] : _a;
    var score = [].slice
        .call(children)
        .reduceRight(function (sum, child) { return sum + getScore(child, depth + 1, sum > 0, ignoreTags); }, 0);
    if (score <= 0 && !exist) {
        if (!isFunction(element.getBoundingClientRect)) {
            return 0;
        }
        var _b = element.getBoundingClientRect() || {}, top_1 = _b.top, height = _b.height;
        if (top_1 > window.innerHeight || height <= 0) {
            return 0;
        }
    }
    return score + 1 + 0.5 * depth;
};
var getFMPInternal = function (_a) {
    var _b = _a === void 0 ? [] : _a, _c = __read(_b), first = _c[0], rest = _c.slice(1);
    return ((rest &&
        rest.reduce(function (_a, cur) {
            var _b = __read(_a, 2), prev = _b[0], target = _b[1];
            var diff = cur.score - prev.score;
            return [cur, cur.time >= prev.time && target.rate < diff ? { time: cur.time, rate: diff } : target];
        }, [first, { time: first === null || first === void 0 ? void 0 : first.time, rate: 0 }])[1].time) ||
        0);
};
export var FMPMonitor = function (document, MutationObserver, navigationStart, raf, caf) {
    var _a;
    if (document === void 0) { document = getDefaultDocument(); }
    if (MutationObserver === void 0) { MutationObserver = getDefaultMutationObserver(); }
    if (navigationStart === void 0) { navigationStart = (_a = getDefaultPerformanceTiming()) === null || _a === void 0 ? void 0 : _a.navigationStart; }
    if (raf === void 0) { raf = getDefaultRaf(); }
    if (caf === void 0) { caf = getDefaultCaf(); }
    return function (props, cb) {
        var renderType = props.renderType;
        var metric = initMetric(FMPMonitorMetricName, 0);
        var buildFMPAndCb = function (_metric) {
            var payload = buildSingleMetricPayload(_metric);
            cb && cb(payload);
        };
        if (renderType === RENDER_TYPR_SSR) {
            applyMonitor(PaintMonitor, { metricName: FMPMonitorMetricName, entryName: FCP_ENTRY_NAME }, buildFMPAndCb);
            return [noop];
        }
        var _a = __read(invokeCallbackOnce(buildFMPAndCb), 1), buildAndInvokeCbOnce = _a[0];
        if (!document || !MutationObserver || !navigationStart) {
            metric.isSupport = false;
            buildAndInvokeCbOnce(metric);
            return [noop];
        }
        var startTime = now();
        var list = [];
        var record = function () {
            return list.push({
                time: now() - startTime,
                // eslint-disable-next-line compat/compat
                score: getScore(document && document.body, 1, false, DEFAULT_IGNORE_TAGS),
            });
        };
        var _b = __read(applyAnimationFrame(document, raf, caf, true), 1), scheduleAF = _b[0];
        // 持续监听 dom 变化，记录下时间和得分
        // 这边放在 animationFrame 中计算一是为了避免强制回流
        // 二是因为 Mutation callback 是作为 microTask 触发，在下一帧之前的任何 dom 变更不会立刻渲染在视图上，而真正渲染是在 animationFrame 中，
        var _c = __read(applyMutationObserver(MutationObserver, function () { return scheduleAF(record); }), 2), observe = _c[0], disconnect = _c[1];
        /**
         * 停止监听，并从当前记录下的数据中计算出得分变化最大的时间点，作为 fmp
         * 此方法在 performance monitor 的 perfLog 中调用
         */
        var tirggerFMP = function (timeGap) {
            if (timeGap === void 0) { timeGap = 0; }
            disconnect();
            var fmp = getFMPInternal(list);
            metric.value = fmp ? fmp + timeGap : 0;
            buildAndInvokeCbOnce(metric);
        };
        var timeGap = startTime - (navigationStart || 0);
        observe(document, { subtree: true, childList: true });
        return [tirggerFMP.bind(null, timeGap)];
    };
};
//# sourceMappingURL=index.js.map