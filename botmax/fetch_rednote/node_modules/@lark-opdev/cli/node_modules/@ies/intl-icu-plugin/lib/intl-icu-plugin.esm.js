import IntlMessageFormat from 'intl-messageformat';
export { default as IntlMessageFormat } from 'intl-messageformat';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function getLastOfPath(object, path, Empty) {
    if (Empty === void 0) { Empty = null; }
    function cleanKey(key) {
        return (key && key.indexOf('###') > -1) ? key.replace(/###/g, '.') : key;
    }
    function canNotTraverseDeeper() {
        return !object || typeof object === 'string';
    }
    var stack = (typeof path !== 'string') ? [].concat(path) : path.split('.');
    while (stack.length > 1) {
        if (canNotTraverseDeeper())
            return {};
        var key = cleanKey(stack.shift());
        if (!object[key] && Empty)
            object[key] = new Empty();
        object = object[key];
    }
    if (canNotTraverseDeeper())
        return {};
    return {
        obj: object,
        k: cleanKey(stack.shift())
    };
}
function setPath(object, path, newValue) {
    var _a = getLastOfPath(object, path, Object), obj = _a.obj, k = _a.k;
    obj[k] = newValue;
}
function getPath(object, path) {
    var _a = getLastOfPath(object, path), obj = _a.obj, k = _a.k;
    if (!obj)
        return undefined;
    return obj[k];
}

var ON_PARSE_ERROR_STRATEGY;
(function (ON_PARSE_ERROR_STRATEGY) {
    ON_PARSE_ERROR_STRATEGY["keepRaw"] = "keepRaw";
    ON_PARSE_ERROR_STRATEGY["replaceAnyway"] = "replaceAnyway"; // 保留部分插值
})(ON_PARSE_ERROR_STRATEGY || (ON_PARSE_ERROR_STRATEGY = {}));
var DEFAULT_ON_PARSE_ERROR_STRATEGY = ON_PARSE_ERROR_STRATEGY.replaceAnyway;
var DEFAULT_OPTIONS = {
    memoize: false,
    memoizeFallback: false,
    bindI18n: false,
    bindI18nStore: false,
    onParseError: ON_PARSE_ERROR_STRATEGY.replaceAnyway
};
var IES_INTL_ICU_PLUGIN = /** @class */ (function () {
    function IES_INTL_ICU_PLUGIN() {
        this.mem = {};
    }
    IES_INTL_ICU_PLUGIN.staticInit = function (i18next) {
        IES_INTL_ICU_PLUGIN._i18nextInstance = i18next;
    };
    IES_INTL_ICU_PLUGIN.prototype.init = function (i18next, options) {
        var _this = this;
        if (i18next === void 0) { i18next = IES_INTL_ICU_PLUGIN._i18nextInstance; }
        var i18nextOptions = {};
        if (!!(i18next === null || i18next === void 0 ? void 0 : i18next.options)) {
            if (!!i18next.options.i18nFormat) {
                i18nextOptions = i18next.options.i18nFormat;
            }
            i18nextOptions.onParseError = i18next.options.onParseError;
            i18nextOptions.missingInterpolationHandler = i18next.options.missingInterpolationHandler;
            i18nextOptions.icuConfig = i18next.options.icuConfig;
            i18nextOptions.ignoreWarning = !!i18next.options.ignoreWarning;
        }
        this.options = Object.assign(DEFAULT_OPTIONS, options, i18nextOptions);
        this.formats = this.options.formats;
        if (i18next) {
            var _a = this.options, bindI18n = _a.bindI18n, bindI18nStore = _a.bindI18nStore, memoize = _a.memoize;
            i18next.IntlMessageFormat = IntlMessageFormat;
            this.IntlMessageFormat = IntlMessageFormat;
            i18next.ICU = this;
            if (memoize) {
                if (bindI18n) {
                    i18next.on(bindI18n, function () { return _this.clearCache(); });
                }
                if (bindI18nStore) {
                    i18next.store.on(bindI18nStore, function () { return _this.clearCache(); });
                }
            }
        }
        if (this.options.localeData) {
            if (Object.prototype.toString.apply(this.options.localeData) === '[object Array]') {
                this.options.localeData.forEach(function (ld) { return _this.addLocaleData(ld); });
            }
            else {
                this.addLocaleData(this.options.localeData);
            }
        }
    };
    IES_INTL_ICU_PLUGIN.prototype.addLocaleData = function (data) {
        var locales = Object.prototype.toString.apply(data) === '[object Array]' ? data : [data];
        locales.forEach(function (localeData) {
            if (localeData && localeData.locale) {
                IntlMessageFormat.__addLocaleData(localeData);
                // IntlRelativeFormat.__addLocaleData(localeData);
            }
        });
    };
    IES_INTL_ICU_PLUGIN.prototype.addUserDefinedFormats = function (formats) {
        this.formats = this.formats ? __assign(__assign({}, this.formats), formats) : formats;
    };
    IES_INTL_ICU_PLUGIN.prototype.checkMissingInterpolation = function (icuAST, messageText, options, lng, key) {
        // ICU Config Strict 为 false，不检查插值缺失
        if ((this.options.icuConfig || {}).strict === false) {
            return options;
        }
        // 记录所有丢失的插值参数
        var missingInterpolations = {};
        for (var _i = 0, icuAST_1 = icuAST; _i < icuAST_1.length; _i++) {
            var element = icuAST_1[_i];
            // if (element.type !== TYPE.argument) {
            //   continue;
            // }
            // 1 === argument，没必要因为这个引入隐式依赖
            if (element.type !== 1) {
                continue;
            }
            // 这个节点是参数表达式
            var value = element.value; // id 就是插值参数名
            if (options[value] !== null && options[value] !== undefined) {
                continue;
            }
            if (typeof this.options.missingInterpolationHandler === 'function') {
                // 权重最高
                var ans = this.options.missingInterpolationHandler({
                    key: key,
                    text: messageText,
                    locale: lng,
                    interpolation: {
                        key: value,
                        val: options[value]
                    }
                });
                if (typeof ans === 'string') {
                    missingInterpolations[value] = ans;
                    continue;
                }
            }
            switch (this.options.onParseError) {
                // 插值参数丢失策略：保留全部翻译文案，不进行任何插值替换
                case ON_PARSE_ERROR_STRATEGY.keepRaw:
                    throw new Error();
                // 插值参数丢失策略：替换丢失的这个文案为 Key 值
                case ON_PARSE_ERROR_STRATEGY.replaceAnyway:
                    missingInterpolations[value] = "{" + value + "}";
                    continue;
            }
            if (typeof this.options.onParseError === 'function') {
                // deprecated
                // 业务配置了 onParseError callback
                console.warn("[DEPRECATED] onParseError is deprecated, please use 'missingInterpolationHandler' instead of");
                var callbackReturns = this.options.onParseError(messageText, value, lng, this.IntlMessageFormat);
                if (callbackReturns === true) {
                    // 业务期望保留全部翻译文案，不进行插值替换
                    throw new Error();
                }
                missingInterpolations[value] =
                    typeof callbackReturns === 'string' ? callbackReturns : "{" + value + "}";
            }
            else {
                // 默认兜底
                if (!this.options.ignoreWarning) {
                    // 发生了插值参数丢失
                    console.warn("[Starling ICU Warning] The interpolation parameter \"{" + value + "}\" is missing in the translation text \"" + messageText + "\" for the key \"" + key + "\"\nSuggestions: check whether the value is null or undefined. Try using empty string '' as fallback! e.g I18n.t('key', { apple: count || '' })");
                }
                missingInterpolations[value] = "{" + value + "}";
            }
        }
        return Object.assign({}, options, missingInterpolations);
    };
    IES_INTL_ICU_PLUGIN.prototype.parse = function (res, options, lng, ns, key, info) {
        var hadSuccessfulLookup = info && info.resolved && info.resolved.res;
        var memKey = this.options.memoize && lng + "." + ns + "." + key.replace(/\./g, '###');
        if (!hadSuccessfulLookup && options.thirdParamFallback && options.fallbackText) {
            res = options.fallbackText;
        }
        var fc;
        if (this.options.memoize) {
            fc = getPath(this.mem, memKey);
        }
        try {
            if (!fc) {
                fc = new this.IntlMessageFormat(res, lng, this.formats, (this.options.icuConfig || {}).formatOptions);
                if (this.options.memoize &&
                    (this.options.memoizeFallback || !info || hadSuccessfulLookup)) {
                    setPath(this.mem, memKey, fc);
                }
            }
            return fc.format(this.checkMissingInterpolation(fc.getAst(), res, options || {}, lng, key));
        }
        catch (err) {
            // if (!this.options.ignoreWarning) {
            //   console.log(err);
            // }
            return res;
        }
    };
    IES_INTL_ICU_PLUGIN.prototype.addLookupKeys = function (finalKeys, key, code, ns, options) {
        // no additional keys needed for select or plural
        // so there is no need to add keys to that finalKeys array
        return finalKeys;
    };
    IES_INTL_ICU_PLUGIN.prototype.clearCache = function () {
        this.mem = {};
    };
    IES_INTL_ICU_PLUGIN.type = 'i18nFormat';
    IES_INTL_ICU_PLUGIN._i18nextInstance = null;
    return IES_INTL_ICU_PLUGIN;
}());
var pluginName = IES_INTL_ICU_PLUGIN.name;

export { DEFAULT_ON_PARSE_ERROR_STRATEGY, DEFAULT_OPTIONS, ON_PARSE_ERROR_STRATEGY, IES_INTL_ICU_PLUGIN as default, pluginName };
