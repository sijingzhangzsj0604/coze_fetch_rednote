import { __read } from "tslib";
import { applyPerformance, applyPerformanceObserver, getDefaultPerformance, getDefaultPerformanceObserver, onPageUnload, onceHidden, invokeCallbackOnce, } from '../../../utils';
import { initMetric } from '../util';
export var FCP_ENTRY_NAME = 'first-contentful-paint';
export var FP_ENTRY_NAME = 'first-paint';
var Paint_Type = 'paint';
export var PaintMonitor = function (PerformanceObserver, performance) {
    if (PerformanceObserver === void 0) { PerformanceObserver = getDefaultPerformanceObserver(); }
    if (performance === void 0) { performance = getDefaultPerformance(); }
    return function (props, cb) {
        var metricName = props.metricName, entryName = props.entryName;
        var metric = initMetric(metricName, 0);
        var _a = __read(invokeCallbackOnce(cb), 1), invokeCbOnce = _a[0];
        if (!performance || !PerformanceObserver) {
            metric.isSupport = false;
            invokeCbOnce(metric);
            return;
        }
        var invokeCb = function (_a) {
            var startTime = _a.startTime;
            metric.value = startTime;
            invokeCbOnce(metric);
        };
        var _b = __read(applyPerformance(performance), 5), getEntriesByName = _b[4];
        var paint = getEntriesByName(entryName)[0];
        // 先从 performance 里拿一下，拿不到则用 PerformanceObserver 监听
        if (paint) {
            invokeCb(paint);
        }
        else {
            var invokeCbWithDisconnect = function (entry) {
                if (entry.name === entryName) {
                    invokeCb(entry);
                    disconnect_1();
                }
            };
            var _c = __read(applyPerformanceObserver(PerformanceObserver, invokeCbWithDisconnect), 2), observe = _c[0], disconnect_1 = _c[1];
            observe(Paint_Type);
            var handleOnceHidden = function () {
                metric.isSupport = false;
                invokeCbOnce(metric);
                disconnect_1();
            };
            onceHidden(handleOnceHidden);
            // 跳出率支持
            var handlePageUnload = function () {
                metric.isBounced = true;
                invokeCbOnce(metric);
                disconnect_1();
            };
            onPageUnload(handlePageUnload);
        }
    };
};
//# sourceMappingURL=index.js.map