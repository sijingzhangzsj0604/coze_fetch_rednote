"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AfterThrowing = exports.AfterReturning = exports.Around = exports.After = exports.Before = exports.Aspect = exports.Autowired = exports.Optional = exports.Inject = exports.Injectable = void 0;
require("reflect-metadata");
var Helper = __importStar(require("./helper"));
var Error = __importStar(require("./error"));
var declare_1 = require("./declare");
var helper_1 = require("./helper");
/**
 * 装饰一个 Class 是否是可以被依赖注入
 * @param opts
 */
function Injectable(opts) {
    return function (target) {
        Helper.markInjectable(target, opts);
        var params = Reflect.getMetadata('design:paramtypes', target);
        if (Array.isArray(params)) {
            Helper.setParameters(target, params);
            // 如果支持多例创建，就不检查构造函数依赖的可注入性
            if (opts && opts.multiple) {
                return;
            }
            // 检查依赖的可注入性
            var depTokens = Helper.getParameterDeps(target);
            depTokens.forEach(function (item, index) {
                if (!Helper.isToken(item)) {
                    throw Error.notInjectError(target, index);
                }
            });
        }
    };
}
exports.Injectable = Injectable;
/**
 * 把构造函数的参数和一个特定的注入标记关联起来
 * @param token
 */
function Inject(token, opts) {
    if (opts === void 0) { opts = {}; }
    return function (target, _, index) {
        Helper.setParameterIn(target, __assign(__assign({}, opts), { token: token }), index);
    };
}
exports.Inject = Inject;
/**
 * 构造函数可选依赖的装饰器
 * @param token
 */
function Optional(token) {
    if (token === void 0) { token = Symbol(); }
    return function (target, _, index) {
        Helper.setParameterIn(target, { default: undefined, token: token }, index);
    };
}
exports.Optional = Optional;
/**
 * 装饰一个类的属性，当这个属性被访问的时候，才开始使用注射器创建实例
 * @param token
 */
function Autowired(token, opts) {
    return function (target, propertyKey) {
        var INSTANCE_KEY = Symbol('INSTANCE_KEY');
        var realToken = token;
        if (realToken === undefined) {
            realToken = Reflect.getMetadata('design:type', target, propertyKey);
        }
        if (!Helper.isToken(realToken)) {
            throw Error.tokenInvalidError(target, propertyKey, realToken);
        }
        // 添加构造函数的依赖
        Helper.addDeps(target, realToken);
        var descriptor = {
            configurable: true,
            enumerable: true,
            get: function () {
                var _this = this;
                if (!this[INSTANCE_KEY]) {
                    var injector = Helper.getInjectorOfInstance(this);
                    if (!injector) {
                        throw Error.noInjectorError(this);
                    }
                    this[INSTANCE_KEY] = injector.get(realToken, opts);
                    injector.onceInstanceDisposed(this[INSTANCE_KEY], function () {
                        _this[INSTANCE_KEY] = undefined;
                    });
                }
                return this[INSTANCE_KEY];
            },
        };
        // 返回 descriptor，编译工具会自动进行 define
        return descriptor;
    };
}
exports.Autowired = Autowired;
// hooks start
/**
 * 声明这是一个包含了 Hook 的 Class
 *
 * @description
 *    典型用法
 *
 *    const AToken = Symbol('AToken');
 *
 *    interface AToken {
 *      add(a: number): number
 *    }
 *
 *    @Injectable()
 *    Class AImpl {
 *
 *       private sum = 0;
 *
 *       add(a: number) {
 *          this.sum += a;
 *          return this.sum;
 *       }
 *
 *    }
 *
 *    @Aspect()
 *    @Injectable()
 *    Class OneAspectOfA {
 *
 *       // 拦截 AToken 实现 class 的 add 方法，在 add 方法执行前，将它的参数乘以2
 *       @Before(AToken, 'add')
 *       beforeAdd(joinPoint: IBeforeJoinPoint<AToken, [number], number>) {
 *          const [a] = joinPoint.getArgs();
 *          joinPoint.setArgs([a * 2]);
 *       }
 *
 *       @After(AToken, 'add')
 *       afterAdd(joinPoint: IAfterJoinPoint<AToken, [number], number>) {
 *          const ret = joinPoint.getResult();
 *          joinPoint.setResult(ret * 5); // 将返回值乘以5
 *       }
 *    }
 *
 *    // 必须添加 Aspect 的 class
 *    injector.addProviders(OneAspectOfA);
 *
 *    这种情况下，第一次调用 const hookedSum = injector.get(AToken).add(2) 后,
 *    AImpl 中的 sum 为 4, hookedSum 为 20
 */
function Aspect() {
    return function (target) {
        (0, helper_1.markAsAspect)(target);
    };
}
exports.Aspect = Aspect;
/**
 * 在方法执行前进行 hook
 *    @Before(AToken, 'add')
 *    beforeAdd(joinPoint: IBeforeJoinPoint<AToken, [number, number], number>) {
 *      const [a, b] = joinPoint.getArgs();
 *      joinPoint.setArgs([a * 10, b * 10]);
 *    }
 * hook 的顺序遵循洋葱模型
 * @param token
 * @param method
 */
function Before(token, method, options) {
    if (options === void 0) { options = {}; }
    return function (target, property) {
        (0, helper_1.markAsHook)(target, property, declare_1.HookType.Before, token, method, options);
    };
}
exports.Before = Before;
/**
 * 在方法结束后进行 hook
 *    @After(AToken, 'add')
 *    afterAdd(joinPoint: IAfterJoinPoint<AToken, [number, number], number>) {
 *      const ret = joinPoint.getResult();
 *      joinPoint.setResult(ret * 10); // 将返回值乘以10
 *    }
 * hook 的顺序遵循洋葱模型
 * @param token
 * @param method
 */
function After(token, method, options) {
    if (options === void 0) { options = {}; }
    return function (target, property) {
        (0, helper_1.markAsHook)(target, property, declare_1.HookType.After, token, method, options);
    };
}
exports.After = After;
/**
 * 环绕型 Hook
 *    @Around(AToken, 'add')
 *    aroundAdd(joinPoint: IAroundJoinPoint<AToken, [number, number], number>) {
 *      const [a, b] = joinPoint.getArgs();
 *      if (a === b) {
 *        console.log('adding two same numbers');
 *      }
 *      joinPoint.proceed();
 *      const result = joinPoint.getResult();
 *      if (result === 10) {
 *         joinPoint.setResult(result * 10);
 *      }
 *    }
 * around 型 hook 是先来的被后来的包裹
 * @param token
 * @param method
 * @description
 */
function Around(token, method, options) {
    if (options === void 0) { options = {}; }
    return function (target, property) {
        (0, helper_1.markAsHook)(target, property, declare_1.HookType.Around, token, method, options);
    };
}
exports.Around = Around;
/**
 * 在方法结束（并且回调给外层之后）后进行 hook
 *    @AfterReturning(AToken, 'add')
 *    afterReturningAdd(joinPoint: IAfterReturningJoinPoint<AToken, [number, number], number>) {
 *      const ret = joinPoint.getResult();
 *      console.log('the return value is ' + ret);
 *    }
 * hook 全都会执行, 即使出错
 * @param token
 * @param method
 * @param options
 */
function AfterReturning(token, method, options) {
    if (options === void 0) { options = {}; }
    return function (target, property) {
        (0, helper_1.markAsHook)(target, property, declare_1.HookType.AfterReturning, token, method, options);
    };
}
exports.AfterReturning = AfterReturning;
/**
 * 在方法抛出异常（或者PromiseRejection）后进行 hook
 *    @AfterThrowing(AToken, 'add')
 *    afterThrowingAdd(joinPoint: IAfterReturningJoinPoint<AToken, [number, number], number>) {
 *      const error = joinPoint.getError();
 *      console.error('产生了一个错误', error);
 *    }
 * hook 全都会执行, 即使出错
 * @param token
 * @param method
 * @param options
 */
function AfterThrowing(token, method, options) {
    if (options === void 0) { options = {}; }
    return function (target, property) {
        (0, helper_1.markAsHook)(target, property, declare_1.HookType.AfterThrowing, token, method, options);
    };
}
exports.AfterThrowing = AfterThrowing;
