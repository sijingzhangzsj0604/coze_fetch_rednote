"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.containsUppercaseCharacter = exports.fuzzyContains = exports.repeat = exports.safeBtoa = exports.stripUTF8BOM = exports.startsWithUTF8BOM = exports.UTF8_BOM_CHARACTER = exports.removeAccents = exports.removeAnsiEscapeCodes = exports.lcut = exports.isFullWidthCharacter = exports.containsFullWidthCharacter = exports.isBasicASCII = exports.containsEmoji = exports.containsRTL = exports.isLowSurrogate = exports.isHighSurrogate = exports.overlap = exports.commonSuffixLength = exports.commonPrefixLength = exports.startsWithIgnoreCase = exports.equalsIgnoreCase = exports.isUpperAsciiLetter = exports.isLowerAsciiLetter = exports.compareIgnoreCase = exports.compare = exports.lastNonWhitespaceIndex = exports.getLeadingWhitespace = exports.firstNonWhitespaceIndex = exports.regExpFlags = exports.regExpContainsBackreference = exports.regExpLeadsToEndlessLoop = exports.createRegExp = exports.endsWith = exports.startsWith = exports.stripWildcards = exports.convertSimple2RegExpPattern = exports.rtrim = exports.multiRightTrim = exports.ltrim = exports.trim = exports.count = exports.escapeRegExpCharacters = exports.escape = exports.mnemonicButtonLabel = exports.format = exports.pad = exports.isFalsyOrWhitespace = exports.stringUtils = exports.empty = void 0;
exports.template = exports.decodeUTF8 = exports.encodeUTF8 = exports.getNextCodePoint = exports.computeCodePoint = exports.getNLines = exports.uppercaseFirstLetter = void 0;
const platform_1 = require("./platform");
/**
 * The empty string.
 */
exports.empty = '';
const hasTextEncoder = typeof TextEncoder !== 'undefined';
const hasTextDecoder = typeof TextDecoder !== 'undefined';
/**
 * 浏览器全局可以直接使用 TextEncoder/TextDecoder
 * Node.js 11+ 才可以全局使用，以下需要 require('util')
 */
var stringUtils;
(function (stringUtils) {
    stringUtils.StringTextEncoder = hasTextEncoder ? TextEncoder : require('util').TextEncoder;
    stringUtils.StringTextDecoder = hasTextDecoder ? TextDecoder : require('util').TextDecoder;
})(stringUtils = exports.stringUtils || (exports.stringUtils = {}));
function isFalsyOrWhitespace(str) {
    if (!str || typeof str !== 'string') {
        return true;
    }
    return str.trim().length === 0;
}
exports.isFalsyOrWhitespace = isFalsyOrWhitespace;
/**
 * @returns the provided number with the given number of preceding zeros.
 */
function pad(n, l, char = '0') {
    const str = '' + n;
    const r = [str];
    for (let i = str.length; i < l; i++) {
        r.push(char);
    }
    return r.reverse().join('');
}
exports.pad = pad;
const _formatRegexp = /{(\d+)}/g;
/**
 * Helper to produce a string with a variable number of arguments. Insert variable segments
 * into the string using the {n} notation where N is the index of the argument following the string.
 * @param value string to which formatting is applied
 * @param args replacements for {n}-entries
 */
function format(value, ...args) {
    if (args.length === 0) {
        return value;
    }
    return value.replace(_formatRegexp, function (match, group) {
        const idx = parseInt(group, 10);
        return isNaN(idx) || idx < 0 || idx >= args.length ? match : args[idx];
    });
}
exports.format = format;
/**
 * Handles mnemonics for buttons. Depending on OS:
 * - Windows: Supported via & character (replace && with & and & with && for escaping)
 * -   Linux: Supported via _ character (replace && with _)
 * -   macOS: Unsupported (replace && with empty string)
 */
function mnemonicButtonLabel(label, forceDisableMnemonics) {
    if (platform_1.isMacintosh || forceDisableMnemonics) {
        return label.replace(/\(&&\w\)|&&/g, '');
    }
    if (platform_1.isWindows) {
        return label.replace(/&&|&/g, (m) => (m === '&' ? '&&' : '&'));
    }
    return label.replace(/&&/g, '_');
}
exports.mnemonicButtonLabel = mnemonicButtonLabel;
/**
 * Converts HTML characters inside the string to use entities instead. Makes the string safe from
 * being used e.g. in HTMLElement.innerHTML.
 */
function escape(html) {
    return html.replace(/[<>&]/g, function (match) {
        switch (match) {
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            case '&':
                return '&amp;';
            default:
                return match;
        }
    });
}
exports.escape = escape;
/**
 * Escapes regular expression characters in a given string
 */
function escapeRegExpCharacters(value) {
    return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, '\\$&');
}
exports.escapeRegExpCharacters = escapeRegExpCharacters;
/**
 * Counts how often `character` occurs inside `value`.
 */
function count(value, character) {
    let result = 0;
    const ch = character.charCodeAt(0);
    for (let i = value.length - 1; i >= 0; i--) {
        if (value.charCodeAt(i) === ch) {
            result++;
        }
    }
    return result;
}
exports.count = count;
/**
 * Removes all occurrences of needle from the beginning and end of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim (default is a blank)
 */
function trim(haystack, needle = ' ') {
    const trimmed = ltrim(haystack, needle);
    return rtrim(trimmed, needle);
}
exports.trim = trim;
/**
 * Removes all occurrences of needle from the beginning of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim
 */
function ltrim(haystack, needle) {
    if (!haystack || !needle) {
        return haystack;
    }
    const needleLen = needle.length;
    if (needleLen === 0 || haystack.length === 0) {
        return haystack;
    }
    let offset = 0;
    while (haystack.indexOf(needle, offset) === offset) {
        offset = offset + needleLen;
    }
    return haystack.substring(offset);
}
exports.ltrim = ltrim;
/**
 * Removes all occurrences of needles from the end of haystack.
 * @param source
 * @param needles
 * @example
 * ```ts
 * let source = '/path/to/file.ts,;';
 * const res = multiRightTrim(source, [`,`, ';']);
 * // res === '/path/to/file.ts';
 *  ```
 */
function multiRightTrim(source, needles) {
    let result = decodeURIComponent(source);
    for (const needle of needles) {
        result = rtrim(result, needle);
    }
    return result;
}
exports.multiRightTrim = multiRightTrim;
/**
 * Removes all occurrences of needle from the end of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim
 */
function rtrim(haystack, needle) {
    if (!haystack || !needle) {
        return haystack;
    }
    const needleLen = needle.length;
    const haystackLen = haystack.length;
    if (needleLen === 0 || haystackLen === 0) {
        return haystack;
    }
    let offset = haystackLen;
    let idx = -1;
    while (true) {
        idx = haystack.lastIndexOf(needle, offset - 1);
        if (idx === -1 || idx + needleLen !== offset) {
            break;
        }
        if (idx === 0) {
            return '';
        }
        offset = idx;
    }
    return haystack.substring(0, offset);
}
exports.rtrim = rtrim;
function convertSimple2RegExpPattern(pattern) {
    return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
}
exports.convertSimple2RegExpPattern = convertSimple2RegExpPattern;
function stripWildcards(pattern) {
    return pattern.replace(/\*/g, '');
}
exports.stripWildcards = stripWildcards;
/**
 * Determines if haystack starts with needle.
 */
function startsWith(haystack, needle) {
    if (haystack.length < needle.length) {
        return false;
    }
    if (haystack === needle) {
        return true;
    }
    for (let i = 0; i < needle.length; i++) {
        if (haystack[i] !== needle[i]) {
            return false;
        }
    }
    return true;
}
exports.startsWith = startsWith;
/**
 * Determines if haystack ends with needle.
 */
function endsWith(haystack, needle) {
    const diff = haystack.length - needle.length;
    if (diff > 0) {
        return haystack.indexOf(needle, diff) === diff;
    }
    else if (diff === 0) {
        return haystack === needle;
    }
    else {
        return false;
    }
}
exports.endsWith = endsWith;
function createRegExp(searchString, isRegex, options = {}) {
    if (!searchString) {
        throw new Error('Cannot create regex from empty string');
    }
    if (!isRegex) {
        searchString = escapeRegExpCharacters(searchString);
    }
    if (options.wholeWord) {
        if (!/\B/.test(searchString.charAt(0))) {
            searchString = '\\b' + searchString;
        }
        if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
            searchString = searchString + '\\b';
        }
    }
    let modifiers = '';
    if (options.global) {
        modifiers += 'g';
    }
    if (!options.matchCase) {
        modifiers += 'i';
    }
    if (options.multiline) {
        modifiers += 'm';
    }
    if (options.unicode) {
        modifiers += 'u';
    }
    return new RegExp(searchString, modifiers);
}
exports.createRegExp = createRegExp;
function regExpLeadsToEndlessLoop(regexp) {
    // Exit early if it's one of these special cases which are meant to match
    // against an empty string
    if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\s*$') {
        return false;
    }
    // We check against an empty string. If the regular expression doesn't advance
    // (e.g. ends in an endless loop) it will match an empty string.
    const match = regexp.exec('');
    return !!(match && regexp.lastIndex === 0);
}
exports.regExpLeadsToEndlessLoop = regExpLeadsToEndlessLoop;
function regExpContainsBackreference(regexpValue) {
    return !!regexpValue.match(/([^\\]|^)(\\\\)*\\\d+/);
}
exports.regExpContainsBackreference = regExpContainsBackreference;
function regExpFlags(regexp) {
    return ((regexp.global ? 'g' : '') +
        (regexp.ignoreCase ? 'i' : '') +
        (regexp.multiline ? 'm' : '') +
        (regexp.unicode ? 'u' : ''));
}
exports.regExpFlags = regExpFlags;
/**
 * Returns first index of the string that is not whitespace.
 * If string is empty or contains only whitespaces, returns -1
 */
function firstNonWhitespaceIndex(str) {
    for (let i = 0, len = str.length; i < len; i++) {
        const chCode = str.charCodeAt(i);
        if (chCode !== 32 /* CharCode.Space */ && chCode !== 9 /* CharCode.Tab */) {
            return i;
        }
    }
    return -1;
}
exports.firstNonWhitespaceIndex = firstNonWhitespaceIndex;
/**
 * Returns the leading whitespace of the string.
 * If the string contains only whitespaces, returns entire string
 */
function getLeadingWhitespace(str, start = 0, end = str.length) {
    for (let i = start; i < end; i++) {
        const chCode = str.charCodeAt(i);
        if (chCode !== 32 /* CharCode.Space */ && chCode !== 9 /* CharCode.Tab */) {
            return str.substring(start, i);
        }
    }
    return str.substring(start, end);
}
exports.getLeadingWhitespace = getLeadingWhitespace;
/**
 * Returns last index of the string that is not whitespace.
 * If string is empty or contains only whitespaces, returns -1
 */
function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
    for (let i = startIndex; i >= 0; i--) {
        const chCode = str.charCodeAt(i);
        if (chCode !== 32 /* CharCode.Space */ && chCode !== 9 /* CharCode.Tab */) {
            return i;
        }
    }
    return -1;
}
exports.lastNonWhitespaceIndex = lastNonWhitespaceIndex;
function compare(a, b) {
    if (a < b) {
        return -1;
    }
    else if (a > b) {
        return 1;
    }
    else {
        return 0;
    }
}
exports.compare = compare;
function compareIgnoreCase(a, b) {
    const len = Math.min(a.length, b.length);
    for (let i = 0; i < len; i++) {
        let codeA = a.charCodeAt(i);
        let codeB = b.charCodeAt(i);
        if (codeA === codeB) {
            // equal
            continue;
        }
        if (isUpperAsciiLetter(codeA)) {
            codeA += 32;
        }
        if (isUpperAsciiLetter(codeB)) {
            codeB += 32;
        }
        const diff = codeA - codeB;
        if (diff === 0) {
            // equal -> ignoreCase
            continue;
        }
        else if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {
            //
            return diff;
        }
        else {
            return compare(a.toLowerCase(), b.toLowerCase());
        }
    }
    if (a.length < b.length) {
        return -1;
    }
    else if (a.length > b.length) {
        return 1;
    }
    else {
        return 0;
    }
}
exports.compareIgnoreCase = compareIgnoreCase;
function isLowerAsciiLetter(code) {
    return code >= 97 /* CharCode.a */ && code <= 122 /* CharCode.z */;
}
exports.isLowerAsciiLetter = isLowerAsciiLetter;
function isUpperAsciiLetter(code) {
    return code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */;
}
exports.isUpperAsciiLetter = isUpperAsciiLetter;
function isAsciiLetter(code) {
    return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);
}
function equalsIgnoreCase(a, b) {
    const len1 = a ? a.length : 0;
    const len2 = b ? b.length : 0;
    if (len1 !== len2) {
        return false;
    }
    return doEqualsIgnoreCase(a, b);
}
exports.equalsIgnoreCase = equalsIgnoreCase;
function doEqualsIgnoreCase(a, b, stopAt = a.length) {
    if (typeof a !== 'string' || typeof b !== 'string') {
        return false;
    }
    for (let i = 0; i < stopAt; i++) {
        const codeA = a.charCodeAt(i);
        const codeB = b.charCodeAt(i);
        if (codeA === codeB) {
            continue;
        }
        // a-z A-Z
        if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {
            const diff = Math.abs(codeA - codeB);
            if (diff !== 0 && diff !== 32) {
                return false;
            }
        }
        else {
            // Any other charcode
            if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {
                return false;
            }
        }
    }
    return true;
}
function startsWithIgnoreCase(str, candidate) {
    const candidateLength = candidate.length;
    if (candidate.length > str.length) {
        return false;
    }
    return doEqualsIgnoreCase(str, candidate, candidateLength);
}
exports.startsWithIgnoreCase = startsWithIgnoreCase;
/**
 * @returns the length of the common prefix of the two strings.
 */
function commonPrefixLength(a, b) {
    let i;
    const len = Math.min(a.length, b.length);
    for (i = 0; i < len; i++) {
        if (a.charCodeAt(i) !== b.charCodeAt(i)) {
            return i;
        }
    }
    return len;
}
exports.commonPrefixLength = commonPrefixLength;
/**
 * @returns the length of the common suffix of the two strings.
 */
function commonSuffixLength(a, b) {
    let i;
    const len = Math.min(a.length, b.length);
    const aLastIndex = a.length - 1;
    const bLastIndex = b.length - 1;
    for (i = 0; i < len; i++) {
        if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
            return i;
        }
    }
    return len;
}
exports.commonSuffixLength = commonSuffixLength;
function substrEquals(a, aStart, aEnd, b, bStart, bEnd) {
    while (aStart < aEnd && bStart < bEnd) {
        if (a[aStart] !== b[bStart]) {
            return false;
        }
        aStart += 1;
        bStart += 1;
    }
    return true;
}
/**
 * Return the overlap between the suffix of `a` and the prefix of `b`.
 * For instance `overlap("foobar", "arr, I'm a pirate") === 2`.
 */
function overlap(a, b) {
    const aEnd = a.length;
    let bEnd = b.length;
    let aStart = aEnd - bEnd;
    if (aStart === 0) {
        return a === b ? aEnd : 0;
    }
    else if (aStart < 0) {
        bEnd += aStart;
        aStart = 0;
    }
    while (aStart < aEnd && bEnd > 0) {
        if (substrEquals(a, aStart, aEnd, b, 0, bEnd)) {
            return bEnd;
        }
        bEnd -= 1;
        aStart += 1;
    }
    return 0;
}
exports.overlap = overlap;
// --- unicode
// http://en.wikipedia.org/wiki/Surrogate_pair
// Returns the code point starting at a specified index in a string
// Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character
// Code points U+10000 to U+10FFFF are represented on two consecutive characters
// export function getUnicodePoint(str:string, index:number, len:number):number {
//	const chrCode = str.charCodeAt(index);
//	if (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {
//		const nextChrCode = str.charCodeAt(index + 1);
//		if (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {
//			return (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;
//		}
//	}
//	return chrCode;
// }
function isHighSurrogate(charCode) {
    return 0xd800 <= charCode && charCode <= 0xdbff;
}
exports.isHighSurrogate = isHighSurrogate;
function isLowSurrogate(charCode) {
    return 0xdc00 <= charCode && charCode <= 0xdfff;
}
exports.isLowSurrogate = isLowSurrogate;
/**
 * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js
 */
const CONTAINS_RTL = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u08BD\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE33\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDCFF]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD50-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
/**
 * Returns true if `str` contains any Unicode character that is classified as "R" or "AL".
 */
function containsRTL(str) {
    return CONTAINS_RTL.test(str);
}
exports.containsRTL = containsRTL;
/**
 * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js
 */
const CONTAINS_EMOJI = /(?:[\u231A\u231B\u23F0\u23F3\u2600-\u27BF\u2B50\u2B55]|\uD83C[\uDDE6-\uDDFF\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F\uDE80-\uDEF8]|\uD83E[\uDD00-\uDDE6])/;
function containsEmoji(str) {
    return CONTAINS_EMOJI.test(str);
}
exports.containsEmoji = containsEmoji;
const IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
/**
 * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \n, \r, \t
 */
function isBasicASCII(str) {
    return IS_BASIC_ASCII.test(str);
}
exports.isBasicASCII = isBasicASCII;
function containsFullWidthCharacter(str) {
    for (let i = 0, len = str.length; i < len; i++) {
        if (isFullWidthCharacter(str.charCodeAt(i))) {
            return true;
        }
    }
    return false;
}
exports.containsFullWidthCharacter = containsFullWidthCharacter;
function isFullWidthCharacter(charCode) {
    // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns
    // http://jrgraphix.net/research/unicode_blocks.php
    //          2E80 — 2EFF   CJK Radicals Supplement
    //          2F00 — 2FDF   Kangxi Radicals
    //          2FF0 — 2FFF   Ideographic Description Characters
    //          3000 — 303F   CJK Symbols and Punctuation
    //          3040 — 309F   Hiragana
    //          30A0 — 30FF   Katakana
    //          3100 — 312F   Bopomofo
    //          3130 — 318F   Hangul Compatibility Jamo
    //          3190 — 319F   Kanbun
    //          31A0 — 31BF   Bopomofo Extended
    //          31F0 — 31FF   Katakana Phonetic Extensions
    //          3200 — 32FF   Enclosed CJK Letters and Months
    //          3300 — 33FF   CJK Compatibility
    //          3400 — 4DBF   CJK Unified Ideographs Extension A
    //          4DC0 — 4DFF   Yijing Hexagram Symbols
    //          4E00 — 9FFF   CJK Unified Ideographs
    //          A000 — A48F   Yi Syllables
    //          A490 — A4CF   Yi Radicals
    //          AC00 — D7AF   Hangul Syllables
    // [IGNORE] D800 — DB7F   High Surrogates
    // [IGNORE] DB80 — DBFF   High Private Use Surrogates
    // [IGNORE] DC00 — DFFF   Low Surrogates
    // [IGNORE] E000 — F8FF   Private Use Area
    //          F900 — FAFF   CJK Compatibility Ideographs
    // [IGNORE] FB00 — FB4F   Alphabetic Presentation Forms
    // [IGNORE] FB50 — FDFF   Arabic Presentation Forms-A
    // [IGNORE] FE00 — FE0F   Variation Selectors
    // [IGNORE] FE20 — FE2F   Combining Half Marks
    // [IGNORE] FE30 — FE4F   CJK Compatibility Forms
    // [IGNORE] FE50 — FE6F   Small Form Variants
    // [IGNORE] FE70 — FEFF   Arabic Presentation Forms-B
    //          FF00 — FFEF   Halfwidth and Fullwidth Forms
    //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]
    //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E
    // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul
    // [IGNORE] FFF0 — FFFF   Specials
    charCode = +charCode; // @perf
    return ((charCode >= 0x2e80 && charCode <= 0xd7af) ||
        (charCode >= 0xf900 && charCode <= 0xfaff) ||
        (charCode >= 0xff01 && charCode <= 0xff5e));
}
exports.isFullWidthCharacter = isFullWidthCharacter;
/**
 * Given a string and a max length returns a shorted version. Shorting
 * happens at favorable positions - such as whitespace or punctuation characters.
 */
function lcut(text, n) {
    if (text.length < n) {
        return text;
    }
    const re = /\b/g;
    let i = 0;
    while (re.test(text)) {
        if (text.length - re.lastIndex < n) {
            break;
        }
        i = re.lastIndex;
        re.lastIndex += 1;
    }
    return text.substring(i).replace(/^\s/, exports.empty);
}
exports.lcut = lcut;
// Escape codes
// http://en.wikipedia.org/wiki/ANSI_escape_code
const EL = /\x1B\x5B[12]?K/g; // Erase in line
const COLOR_START = /\x1b\[\d+m/g; // Color
const COLOR_END = /\x1b\[0?m/g; // Color
function removeAnsiEscapeCodes(str) {
    if (str) {
        str = str.replace(EL, '');
        str = str.replace(COLOR_START, '');
        str = str.replace(COLOR_END, '');
    }
    return str;
}
exports.removeAnsiEscapeCodes = removeAnsiEscapeCodes;
exports.removeAccents = (function () {
    if (typeof String.prototype.normalize !== 'function') {
        // ☹️ no ES6 features...
        return function (str) {
            return str;
        };
    }
    else {
        // transform into NFD form and remove accents
        // see: https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript/37511463#37511463
        const regex = /[\u0300-\u036f]/g;
        return function (str) {
            return str.normalize('NFD').replace(regex, exports.empty);
        };
    }
})();
// -- UTF-8 BOM
exports.UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* CharCode.UTF8_BOM */);
function startsWithUTF8BOM(str) {
    return !!(str && str.length > 0 && str.charCodeAt(0) === 65279 /* CharCode.UTF8_BOM */);
}
exports.startsWithUTF8BOM = startsWithUTF8BOM;
function stripUTF8BOM(str) {
    return startsWithUTF8BOM(str) ? str.substr(1) : str;
}
exports.stripUTF8BOM = stripUTF8BOM;
function safeBtoa(str) {
    return btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values
}
exports.safeBtoa = safeBtoa;
function repeat(s, count) {
    let result = '';
    for (let i = 0; i < count; i++) {
        result += s;
    }
    return result;
}
exports.repeat = repeat;
/**
 * Checks if the characters of the provided query string are included in the
 * target string. The characters do not have to be contiguous within the string.
 */
function fuzzyContains(target, query) {
    if (!target || !query) {
        return false; // return early if target or query are undefined
    }
    if (target.length < query.length) {
        return false; // impossible for query to be contained in target
    }
    const queryLen = query.length;
    const targetLower = target.toLowerCase();
    let index = 0;
    let lastIndexOf = -1;
    while (index < queryLen) {
        const indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);
        if (indexOf < 0) {
            return false;
        }
        lastIndexOf = indexOf;
        index++;
    }
    return true;
}
exports.fuzzyContains = fuzzyContains;
function containsUppercaseCharacter(target, ignoreEscapedChars = false) {
    if (!target) {
        return false;
    }
    if (ignoreEscapedChars) {
        target = target.replace(/\\./g, '');
    }
    return target.toLowerCase() !== target;
}
exports.containsUppercaseCharacter = containsUppercaseCharacter;
function uppercaseFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
exports.uppercaseFirstLetter = uppercaseFirstLetter;
function getNLines(str, n = 1) {
    if (n === 0) {
        return '';
    }
    let idx = -1;
    do {
        idx = str.indexOf('\n', idx + 1);
        n--;
    } while (n > 0 && idx >= 0);
    return idx >= 0 ? str.substr(0, idx) : str;
}
exports.getNLines = getNLines;
/**
 * See http://en.wikipedia.org/wiki/Surrogate_pair
 */
function computeCodePoint(highSurrogate, lowSurrogate) {
    return ((highSurrogate - 0xd800) << 10) + (lowSurrogate - 0xdc00) + 0x10000;
}
exports.computeCodePoint = computeCodePoint;
/**
 * get the code point that begins at offset `offset`
 */
function getNextCodePoint(str, len, offset) {
    const charCode = str.charCodeAt(offset);
    if (isHighSurrogate(charCode) && offset + 1 < len) {
        const nextCharCode = str.charCodeAt(offset + 1);
        if (isLowSurrogate(nextCharCode)) {
            return computeCodePoint(charCode, nextCharCode);
        }
    }
    return charCode;
}
exports.getNextCodePoint = getNextCodePoint;
/**
 * A manual encoding of `str` to UTF8.
 * Use only in environments which do not offer native conversion methods!
 */
function encodeUTF8(str) {
    const strLen = str.length;
    // See https://en.wikipedia.org/wiki/UTF-8
    // first loop to establish needed buffer size
    let neededSize = 0;
    let strOffset = 0;
    while (strOffset < strLen) {
        const codePoint = getNextCodePoint(str, strLen, strOffset);
        strOffset += codePoint >= 65536 /* Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1;
        if (codePoint < 0x0080) {
            neededSize += 1;
        }
        else if (codePoint < 0x0800) {
            neededSize += 2;
        }
        else if (codePoint < 0x10000) {
            neededSize += 3;
        }
        else {
            neededSize += 4;
        }
    }
    // second loop to actually encode
    const arr = new Uint8Array(neededSize);
    strOffset = 0;
    let arrOffset = 0;
    while (strOffset < strLen) {
        const codePoint = getNextCodePoint(str, strLen, strOffset);
        strOffset += codePoint >= 65536 /* Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1;
        if (codePoint < 0x0080) {
            arr[arrOffset++] = codePoint;
        }
        else if (codePoint < 0x0800) {
            arr[arrOffset++] = 0b11000000 | ((codePoint & 0b00000000000000000000011111000000) >>> 6);
            arr[arrOffset++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);
        }
        else if (codePoint < 0x10000) {
            arr[arrOffset++] = 0b11100000 | ((codePoint & 0b00000000000000001111000000000000) >>> 12);
            arr[arrOffset++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);
            arr[arrOffset++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);
        }
        else {
            arr[arrOffset++] = 0b11110000 | ((codePoint & 0b00000000000111000000000000000000) >>> 18);
            arr[arrOffset++] = 0b10000000 | ((codePoint & 0b00000000000000111111000000000000) >>> 12);
            arr[arrOffset++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);
            arr[arrOffset++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);
        }
    }
    return arr;
}
exports.encodeUTF8 = encodeUTF8;
/**
 * A manual decoding of a UTF8 string.
 * Use only in environments which do not offer native conversion methods!
 */
function decodeUTF8(buffer) {
    // https://en.wikipedia.org/wiki/UTF-8
    const len = buffer.byteLength;
    const result = [];
    let offset = 0;
    while (offset < len) {
        const v0 = buffer[offset];
        let codePoint;
        if (v0 >= 0b11110000 && offset + 3 < len) {
            // 4 bytes
            codePoint =
                (((buffer[offset++] & 0b00000111) << 18) >>> 0) |
                    (((buffer[offset++] & 0b00111111) << 12) >>> 0) |
                    (((buffer[offset++] & 0b00111111) << 6) >>> 0) |
                    (((buffer[offset++] & 0b00111111) << 0) >>> 0);
        }
        else if (v0 >= 0b11100000 && offset + 2 < len) {
            // 3 bytes
            codePoint =
                (((buffer[offset++] & 0b00001111) << 12) >>> 0) |
                    (((buffer[offset++] & 0b00111111) << 6) >>> 0) |
                    (((buffer[offset++] & 0b00111111) << 0) >>> 0);
        }
        else if (v0 >= 0b11000000 && offset + 1 < len) {
            // 2 bytes
            codePoint = (((buffer[offset++] & 0b00011111) << 6) >>> 0) | (((buffer[offset++] & 0b00111111) << 0) >>> 0);
        }
        else {
            // 1 byte
            codePoint = buffer[offset++];
        }
        if ((codePoint >= 0 && codePoint <= 0xd7ff) || (codePoint >= 0xe000 && codePoint <= 0xffff)) {
            // Basic Multilingual Plane
            result.push(String.fromCharCode(codePoint));
        }
        else if (codePoint >= 0x010000 && codePoint <= 0x10ffff) {
            // Supplementary Planes
            const uPrime = codePoint - 0x10000;
            const w1 = 0xd800 + ((uPrime & 0b11111111110000000000) >>> 10);
            const w2 = 0xdc00 + ((uPrime & 0b00000000001111111111) >>> 0);
            result.push(String.fromCharCode(w1));
            result.push(String.fromCharCode(w2));
        }
        else {
            // illegal code point
            result.push(String.fromCharCode(0xfffd));
        }
    }
    return result.join('');
}
exports.decodeUTF8 = decodeUTF8;
/**
 * 插值表达式的标记使用的是 ${}
 * 该函数会对 options 中的 separator 会有特殊处理，
 */
function template(tpl, variables, options) {
    const result = [];
    let placeHolderStack = [];
    for (let idx = 0; idx < tpl.length; idx++) {
        const char = tpl[idx];
        const nextChar = tpl[idx + 1];
        // 往后多看一位
        if (char === '$' && nextChar === '{') {
            // 往后的可能是占位符了，注入进栈标志位（即 $）
            // 如果 placeHolder 栈已经有值了，现在不支持嵌套 ${}，直接吐出所有值放到 result 中即可
            if (placeHolderStack.length > 0) {
                result.push(...placeHolderStack);
                placeHolderStack = [];
            }
            placeHolderStack.push(char);
            placeHolderStack.push(nextChar);
            idx++;
            continue;
        }
        // 如果当前 placeHolder 栈有字符，一直将字符入栈，直到匹配到 }
        if (placeHolderStack.length > 0) {
            if (char === '}') {
                // 占位符匹配结束
                // 拿出占位符进行值替换
                const placeholder = placeHolderStack.slice(2).join('');
                let v;
                if (placeholder === 'separator') {
                    if (result[result.length - 1] === options.separator) {
                        // 不需要重复 separator
                        placeHolderStack = [];
                        continue;
                    }
                    // 分隔符有单独的优化
                    v = options.separator;
                }
                else {
                    v = variables[placeholder];
                }
                const toPush = v !== null && v !== void 0 ? v : options.defaultValue;
                if (toPush) {
                    result.push(toPush);
                }
                placeHolderStack = [];
            }
            else {
                placeHolderStack.push(char);
            }
            continue;
        }
        result.push(tpl[idx]);
    }
    // 去除前面和后面的 sep
    // 这些 sep 也是不需要的
    while (result[result.length - 1] === options.separator) {
        result.pop();
    }
    while (result[0] === options.separator) {
        result.shift();
    }
    return result.join('');
}
exports.template = template;
//# sourceMappingURL=strings.js.map