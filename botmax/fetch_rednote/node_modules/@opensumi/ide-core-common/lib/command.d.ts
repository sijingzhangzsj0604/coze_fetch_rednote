import { Disposable, Event, IDisposable, MaybePromise } from '@opensumi/ide-utils';
import { ContributionProvider } from './contribution-provider';
import { ILocalizedStr } from './localize';
import { IExtensionInfo } from './types';
export interface Command {
    /**
     * 命令 id，全局唯一
     */
    id: string;
    /**
     * 要在命令面板显示的文案
     * 支持国际化占位符，例如 %evenEditorGroups%
     */
    label?: string;
    labelLocalized?: ILocalizedStr;
    /**
     * 要在命令面板显示的较短的文案
     * 支持国际化占位符，例如 %evenEditorGroups%
     */
    shortLabel?: string;
    shortLabelLocalized?: ILocalizedStr;
    /**
     * 要在命令面板显示的分组
     * 支持国际化占位符，例如 %evenEditorGroups%
     */
    category?: string;
    categoryLocalized?: ILocalizedStr;
    /**
     * 要在命令面板显示的图标
     */
    iconClass?: string;
    /**
     * 代理执行的命令
     */
    delegate?: string;
    /**
     * 是否启用该命令，值为 when 表达式
     * 这个值只影响 UI 是否展示 （命令面板或者菜单）
     */
    enablement?: string;
}
/**
 * Command 的工具方法
 */
export declare namespace Command {
    /**
     * 判断是否是命令
     * @param arg 要判断的对象
     */
    function is(arg: Command | any): arg is Command;
    /**
     * 比较两个命令是否相等
     * 用于命令面板的排序
     * @param a 待比较的命令
     * @param b 待比较的命令
     */
    function compareCommands(a: Command, b: Command): number;
}
/**
 * 命令处理函数接口
 */
export interface CommandHandler<T = any> {
    /**
     * 命令执行函数
     * @param args 传递的参数
     */
    execute: T;
    /**
     * 命令是否启用
     * 若为否，则不会被执行到
     * 并且命令面板也不会显示
     * @param args 传递的参数
     */
    isEnabled?(...args: any[]): boolean;
    /**
     * 命令是否可见
     * 若为否，则不会再命令面板显示
     * 但是可以被外部执行
     * @param args 传递的参数
     */
    isVisible?(...args: any[]): boolean;
    /**
     * 是否可切换
     * 主要给菜单使用
     * @param args
     */
    isToggled?(...args: any[]): boolean;
    /**
     * 获取鉴过权的命令处理函数
     * @param commandId 命令 id
     * @param extensionInfo 插件的主要属性
     * @param args 命令其他参数
     */
    isPermitted?(extensionInfo: IExtensionInfo, ...args: any[]): boolean;
}
export declare const CommandContribution: unique symbol;
/**
 * 命令贡献 Contribution
 * 其他模块如果要注册命令需要实现该接口，并且把 Symbol 定义加入 Domain
 */
export interface CommandContribution {
    /**
     * 注册命令
     */
    registerCommands(commands: CommandRegistry): void;
}
type PostInterceptorFunction = (result: any) => MaybePromise<any>;
type PreInterceptorFunction = (args: any[]) => MaybePromise<any[] | boolean>;
export type PreCommandInterceptor = (command: string, args: any[]) => MaybePromise<any[] | boolean>;
export type PostCommandInterceptor = (command: string, result: any) => MaybePromise<any>;
export declare const CommandService: unique symbol;
export declare const CommandRegistry: unique symbol;
export declare const HANDLER_NOT_FOUND = "HANDLER_NOT_FOUND";
export interface ICommandEvent {
    commandId: string;
    args: any[];
}
/**
 * 命令执行模块
 */
export interface CommandService {
    executeCommand<T>(commandId: string, ...args: any[]): Promise<T | undefined>;
    /**
     * 执行命令将报错 catch 并 log 输出
     */
    tryExecuteCommand<T>(commandId: string, ...args: any[]): Promise<T | undefined>;
    onWillExecuteCommand: Event<ICommandEvent>;
    onDidExecuteCommand: Event<ICommandEvent>;
}
/**
 * 命令注册和管理模块
 */
interface CoreCommandRegistry {
    /**
     * 注册命令
     * @param command 要注册的命令
     * @param handler 要绑定的执行函数，可延后添加
     * @returns 销毁命令的方法
     */
    registerCommand<T = any>(command: Command, handler?: CommandHandler<T>): IDisposable;
    updateCommandDetailById(id: string, command: Partial<Command>): void;
    /**
     * 解绑命令
     * @param commandOrId 要解绑命令或命令 id
     */
    unregisterCommand(commandOrId: Command | string): void;
    /**
     * 给命令注册处理函数
     * 可以给命令加多个处理函数
     * @param commandId 要添加的命令 id
     * @param handler 要添加的处理函数
     */
    registerHandler<T = any>(commandId: string, handler: CommandHandler<T>): IDisposable;
    /**
     * 通过命令 id 获取命令
     * @param commandId 命令 id
     */
    getCommand(commandId: string): Command | undefined;
    getRawCommand(commandId: string): Command | undefined;
    /**
     * 获取所有命令
     */
    getCommands(): Command[];
    /**
     * 判断命令是否启用
     * @param commandId 命令 id
     * @param args 传递参数
     */
    isEnabled(commandId: string, ...args: any[]): boolean;
    /**
     * 判断命令是否可见
     * @param commandId 命令 id
     * @param args 传递参数
     */
    isVisible(commandId: string, ...args: any[]): boolean;
    /**
     * 判断命令是否可切换
     * @param commandId 命令 id
     */
    isToggled(commandId: string, ...args: any[]): boolean;
    /**
     * 判断命令是否启用
     * @param commandId 命令 id
     * @param args
     */
    getActiveHandler(commandId: string, ...args: any[]): CommandHandler | undefined;
    /**
     * 获取最近使用的命令列表
     */
    getRecentCommands(): Command[];
    /**
     * 设置最近使用的命令列表
     */
    setRecentCommands(commands: Command[]): Command[];
    /**
     * 为特定的命令注册前置拦截器
     *
     * 拦截器的入参是该命令的参数数组，请返回修改后的参数数组或者返回 false 来拦截本次执行
     */
    beforeExecuteCommand(commandId: string, interceptorFunc: PreInterceptorFunction): IDisposable;
    /**
     * 可以为命令添加拦截器
     * 拦截器的入参是该命令的参数数组，请返回修改后的参数数组或者返回 false 来拦截本次执行
     * @param interceptor 每个 command 都会执行一遍
     */
    beforeExecuteCommand(interceptor: PreCommandInterceptor): IDisposable;
    afterExecuteCommand(commandId: string, interceptorFunc: PostInterceptorFunction): IDisposable;
    afterExecuteCommand(interceptor: PostCommandInterceptor): IDisposable;
    /**
     * 是否是通过鉴过权的命令
     * @param commandId
     * @param extensionInfo
     * @param args
     */
    isPermittedCommand(commandId: string, extensionInfo: IExtensionInfo, ...args: any[]): boolean;
}
export interface CommandRegistry extends CoreCommandRegistry {
    /**
     * 从 ContributionProvide 中拿到执行命令 Contribution
     * 执行注册操作
     */
    initialize(): void;
}
export declare class CoreCommandRegistryImpl implements CoreCommandRegistry {
    protected readonly _commands: {
        [id: string]: Command;
    };
    protected readonly _handlers: {
        [id: string]: CommandHandler[];
    };
    protected readonly unregisterCommands: Map<string, Disposable>;
    protected readonly _recent: Command[];
    readonly preCommandInterceptors: PreCommandInterceptor[];
    readonly postCommandInterceptors: PostCommandInterceptor[];
    private readonly preCommandInterceptorMap;
    private readonly postCommandInterceptor;
    private readonly logger;
    /**
     * 命令执行方法
     * @param commandId 命令执行方法
     * @param args
     */
    executeCommand<T>(commandId: string, ...args: any[]): Promise<T | undefined>;
    /**
     * 获取所有命令
     */
    getCommands(): Command[];
    /**
     * 注册命令，命令不能重复注册
     * @param command
     * @param handler
     * @returns 命令销毁函数
     */
    registerCommand<T>(command: Command, handler?: CommandHandler<T>): IDisposable;
    /**
     * 有时候我们需要在命令注册后才更新其描述。
     *
     * 比如说我们会为所有的 ContainerId 注册 Toggle Panel 的命令，但我们不想在 QuickOpen 中展示所有 ContainerId 对应的命令
     * 这个时候我们可以先注册所有命令，然后再更新所有 Command 的描述
     * @param id 命令 ID
     * @param command
     */
    updateCommandDetailById(id: string, command: Partial<Command>): void;
    /**
     * 解绑命令
     * @param command 命令
     */
    unregisterCommand(command: Command): void;
    /**
     * 给命令注册处理函数
     * 可以给命令加多个处理函数
     * 默认后面注册的优先级更高
     * @param commandId 要添加的命令 id
     * @param handler 要添加的处理函数
     * @returns 销毁函数
     */
    registerHandler<T>(commandId: string, handler: CommandHandler<T>): IDisposable;
    /**
     * 判断命令是否启用
     * @param commandId 命令 id
     * @param args 传递参数
     */
    isEnabled(command: string, ...args: any[]): boolean;
    /**
     * 判断命令是否可见
     * @param commandId 命令 id
     * @param args 传递参数
     */
    isVisible(command: string, ...args: any[]): boolean;
    /**
     * 是否可切换
     * 主要给菜单使用
     * @param commandId 命令 id
     * @param args 传递参数
     */
    isToggled(command: string, ...args: any[]): boolean;
    /**
     * 获取可见的命令处理函数
     * @param commandId 命令 id
     * @param args 传递参数
     */
    protected getVisibleHandler(commandId: string, ...args: any[]): CommandHandler | undefined;
    /**
     * 获取启用的命令处理函数
     * @param commandId 命令 id
     * @param args
     */
    getActiveHandler(commandId: string, ...args: any[]): CommandHandler | undefined;
    /**
     * 获取鉴过权的命令处理函数
     * @param commandId 命令 id
     * @param extensionInfo 插件的主要属性
     * @param args 命令其他参数
     */
    isPermittedCommand(commandId: string, extensionInfo: IExtensionInfo, ...args: any[]): boolean;
    /**
     * 获取可切换的命令处理函数
     * @param commandId 命令 id
     */
    protected getToggledHandler(commandId: string): CommandHandler | undefined;
    /**
     * 解决语言包未加载时注册命令时没有 label/category 的场景
     * 使用方需要自定处理 i18n 问题
     */
    getRawCommand(id: string): Command | undefined;
    /**
     * 通过命令 id 获取命令
     * @param commandId 命令 id
     */
    getCommand(id: string): Command | undefined;
    protected localizeCommand(command: Command): Command;
    /**
     * 给命令添加销毁函数
     * @param command 要添加销毁函数的命令
     */
    protected doRegisterCommand(command: Command): IDisposable;
    beforeExecuteCommand(commandId: string, interceptorFunc: PreInterceptorFunction): IDisposable;
    beforeExecuteCommand(interceptor: PreCommandInterceptor): IDisposable;
    afterExecuteCommand(commandId: string, interceptorFunc: PostInterceptorFunction): IDisposable;
    afterExecuteCommand(interceptor: PostCommandInterceptor): IDisposable;
    /**
     * 获取最近使用的命令列表
     */
    getRecentCommands(): Command[];
    /**
     * 获取最近使用的命令列表
     */
    setRecentCommands(commands: Command[]): Command[];
    /**
     * 添加一个命令到最近使用列表中
     * @param recent 待添加的命令
     */
    protected addRecentCommand(recent: Command): void;
}
export declare class CommandRegistryImpl extends CoreCommandRegistryImpl implements CommandRegistry {
    protected readonly contributionProvider: ContributionProvider<CommandContribution>;
    /**
     * 执行 CommandContribution 的注册方法
     */
    initialize(): void;
}
export declare class CommandServiceImpl implements CommandService {
    private commandRegistry;
    private readonly _onWillExecuteCommand;
    readonly onWillExecuteCommand: Event<ICommandEvent>;
    private readonly _onDidExecuteCommand;
    readonly onDidExecuteCommand: Event<ICommandEvent>;
    executeCommand<T>(commandId: string, ...args: any[]): Promise<T | undefined>;
    tryExecuteCommand<T>(commandId: string, ...args: any[]): Promise<T | undefined>;
}
export {};
//# sourceMappingURL=command.d.ts.map