"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Injector = void 0;
var Helper = __importStar(require("./helper"));
var InjectorError = __importStar(require("./error"));
var declare_1 = require("./declare");
var helper_1 = require("./helper");
var event_1 = require("./helper/event");
var Injector = /** @class */ (function () {
    function Injector(providers, opts, parent) {
        if (providers === void 0) { providers = []; }
        if (opts === void 0) { opts = {}; }
        this.opts = opts;
        this.id = Helper.createId('Injector');
        this.instanceIdGenerator = Helper.createIdFactory('Instance_' + this.id.slice(9));
        this.depth = 0;
        this.tagMatrix = new Map();
        this.domainMap = new Map();
        this.creatorMap = new Map();
        this.instanceRefMap = new Map();
        this.instanceDisposedEmitter = new event_1.EventEmitter();
        this.tag = opts.tag;
        if (parent) {
            this.parent = parent;
            this.depth = parent.depth + 1;
            this.hookStore = new helper_1.HookStore(this.parent.hookStore);
        }
        else {
            this.hookStore = new helper_1.HookStore();
        }
        this.addProviders.apply(this, __spreadArray([{
                token: declare_1.INJECTOR_TOKEN,
                useValue: this,
            }], __read(providers), false));
    }
    Injector.prototype.createChild = function (providers, opts) {
        var e_1, _a, e_2, _b;
        if (providers === void 0) { providers = []; }
        if (opts === void 0) { opts = {}; }
        var injector = new this.constructor(providers, __assign(__assign({}, this.opts), opts), this);
        if (opts.dropdownForTag) {
            try {
                for (var _c = __values(this.creatorMap.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var _e = __read(_d.value, 2), token = _e[0], creator = _e[1];
                    if (creator.dropdownForTag && creator.tag && opts.tag === creator.tag && !injector.creatorMap.has(token)) {
                        injector.creatorMap.set(token, creator);
                        var targetTokenMap = injector.tagMatrix.get(creator.tag) || new Map();
                        var currentTokenMap = this.tagMatrix.get(creator.tag);
                        if (currentTokenMap) {
                            try {
                                for (var _f = (e_2 = void 0, __values(currentTokenMap.entries())), _g = _f.next(); !_g.done; _g = _f.next()) {
                                    var _h = __read(_g.value, 2), key = _h[0], value = _h[1];
                                    targetTokenMap.set(key, value);
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        }
                        injector.tagMatrix.set(creator.tag, targetTokenMap);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return injector;
    };
    Injector.prototype.get = function (token, args, opts) {
        var _a, _b, _c, _d;
        if (!Array.isArray(args)) {
            opts = args;
            args = undefined;
        }
        var creator = null;
        var injector = this;
        // If user passed the args parameter, he want to instantiate the class
        if (args) {
            // At this time, it must not be singleton
            opts = __assign(__assign({}, opts), { multiple: true });
            // here we do not use the parsed injector(the second return value of `getCreator`)
            _a = __read(this.getCreator(token), 1), creator = _a[0];
            if (!creator) {
                // if there is no specific Creator, then:
                // 1. if token is a Class, we also allow the not-Injectable Class as Token, we just instantiate this Class
                if ((0, helper_1.isTypeProvider)(token)) {
                    creator = {
                        opts: {},
                        parameters: [],
                        useClass: token,
                    };
                }
                else {
                    throw InjectorError.noProviderError(token);
                }
            }
        }
        else {
            // firstly, use tag to exchange token
            if (opts && Helper.hasTag(opts)) {
                var tagToken = this.exchangeToken(token, opts.tag);
                _b = __read(this.getCreator(tagToken), 2), creator = _b[0], injector = _b[1];
            }
            // if there is no Creator, then use the token to find the Creator
            if (!creator) {
                _c = __read(this.getCreator(token), 2), creator = _c[0], injector = _c[1];
            }
            // if in non-strict mode, parse dependencies and providers automatically when get
            if ((0, helper_1.isTypeProvider)(token) && !creator && !this.opts.strict) {
                this.parseDependencies(token);
                _d = __read(this.getCreator(token), 2), creator = _d[0], injector = _d[1];
            }
        }
        if (!creator) {
            throw InjectorError.noProviderError(token);
        }
        var ctx = {
            token: token,
            creator: creator,
            injector: injector,
        };
        return this.createInstance(ctx, opts, args);
    };
    Injector.prototype.getTokenForDomain = function (domain) {
        var tokens = this.domainMap.get(domain) || [];
        if (this.parent) {
            tokens = tokens.concat(this.parent.getTokenForDomain(domain));
        }
        return tokens;
    };
    Injector.prototype.getFromDomain = function () {
        var e_3, _a;
        var _this = this;
        var domains = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            domains[_i] = arguments[_i];
        }
        var tokenSet = new Set();
        try {
            for (var domains_1 = __values(domains), domains_1_1 = domains_1.next(); !domains_1_1.done; domains_1_1 = domains_1.next()) {
                var domain = domains_1_1.value;
                var arr = this.getTokenForDomain(domain);
                arr.forEach(function (item) { return tokenSet.add(item); });
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (domains_1_1 && !domains_1_1.done && (_a = domains_1.return)) _a.call(domains_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        var tokens = Array.from(tokenSet);
        return tokens.map(function (token) { return _this.get(token); });
    };
    /**
     * Only check this injector whether has the singleton instance.
     */
    Injector.prototype.hasInstance = function (instance) {
        var e_4, _a;
        try {
            for (var _b = __values(this.creatorMap.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var creator = _c.value;
                if (creator.instance === instance) {
                    return true;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return false;
    };
    Injector.prototype.addProviders = function () {
        var providers = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            providers[_i] = arguments[_i];
        }
        this.setProviders(providers);
    };
    Injector.prototype.overrideProviders = function () {
        var providers = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            providers[_i] = arguments[_i];
        }
        this.setProviders(providers, { override: true });
    };
    Injector.prototype.parseDependencies = function () {
        var _this = this;
        var targets = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            targets[_i] = arguments[_i];
        }
        var deepDeps = Helper.getAllDeps.apply(Helper, __spreadArray([], __read(targets), false));
        var allDeps = targets.concat(deepDeps);
        var providers = Helper.uniq(allDeps.filter(Helper.isInjectableToken));
        this.setProviders(providers, { deep: true });
        var defaultProviders = Helper.flatten(providers.map(function (p) {
            return Helper.getParameterOpts(p);
        }))
            .filter(function (opt) {
            return Object.prototype.hasOwnProperty.call(opt, 'default');
        })
            .map(function (opt) { return ({
            isDefault: true,
            token: opt.token,
            useValue: opt.default,
        }); });
        this.setProviders(defaultProviders, { deep: true });
        // make sure all dependencies have corresponding providers
        var notProvidedDeps = allDeps.filter(function (d) { return !_this.getCreator(d)[0]; });
        if (notProvidedDeps.length) {
            throw InjectorError.noProviderError.apply(InjectorError, __spreadArray([], __read(notProvidedDeps), false));
        }
    };
    Injector.prototype.exchangeToken = function (token, tag) {
        var current = this.getTagToken(token, tag);
        if (current) {
            return current;
        }
        var tokenMap = this.tagMatrix.get(tag) || new Map();
        var tagToken = Symbol(tag);
        tokenMap.set(token, tagToken);
        this.tagMatrix.set(tag, tokenMap);
        return tagToken;
    };
    Injector.prototype.createHooks = function (hooks) {
        return this.hookStore.createHooks(hooks);
    };
    Injector.prototype.createHook = function (hook) {
        return this.hookStore.createOneHook(hook);
    };
    Injector.prototype.onceInstanceDisposed = function (instance, cb) {
        var instanceId = this.getInstanceId(instance);
        if (!instanceId) {
            return;
        }
        return this.instanceDisposedEmitter.once(instanceId, cb);
    };
    Injector.prototype.disposeOne = function (token, key) {
        var _this = this;
        if (key === void 0) { key = 'dispose'; }
        var _a = __read(this.getCreator(token), 1), creator = _a[0];
        if (!creator || creator.status === declare_1.CreatorStatus.init) {
            return;
        }
        var instance = creator.instance;
        var instanceId = this.getInstanceId(instance);
        this.instanceRefMap.delete(instance);
        var maybePromise;
        if (instance && typeof instance[key] === 'function') {
            maybePromise = instance[key]();
        }
        creator.instance = undefined;
        creator.status = declare_1.CreatorStatus.init;
        if (maybePromise && Helper.isPromiseLike(maybePromise)) {
            maybePromise = maybePromise.then(function () {
                instanceId && _this.instanceDisposedEmitter.emit(instanceId);
            });
        }
        else {
            instanceId && this.instanceDisposedEmitter.emit(instanceId);
        }
        return maybePromise;
    };
    Injector.prototype.disposeAll = function (key) {
        var e_5, _a;
        var _this = this;
        if (key === void 0) { key = 'dispose'; }
        var creatorMap = this.creatorMap;
        var promises = [];
        try {
            for (var _b = __values(creatorMap.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var token = _c.value;
                promises.push(this.disposeOne(token, key));
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return Promise.all(promises).finally(function () {
            _this.instanceDisposedEmitter.dispose();
        });
    };
    Injector.prototype.getTagToken = function (token, tag) {
        var tokenMap = this.tagMatrix.get(tag);
        if (tokenMap && tokenMap.has(token)) {
            return tokenMap.get(token);
        }
        else if (this.parent) {
            return this.parent.getTagToken(token, tag);
        }
        return null;
    };
    Injector.prototype.setProviders = function (providers, opts) {
        var e_6, _a;
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var _loop_1 = function (provider) {
            var originToken = Helper.parseTokenFromProvider(provider);
            var token = Helper.hasTag(provider) ? this_1.exchangeToken(originToken, provider.tag) : originToken;
            var current = opts.deep ? this_1.getCreator(token)[0] : this_1.resolveToken(token)[1];
            var shouldBeSet = [
                // use provider's override attribute.
                Helper.isTypeProvider(provider) ? false : provider.override,
                // use opts.override. The user explicitly call `overrideProviders`.
                opts.override,
                // if this token do not have corresponding creator, use override
                // if the creator is default(it is a fallback value), it means we can override it.
                !current || current.isDefault,
            ].some(Boolean);
            if (shouldBeSet) {
                var creator_1 = Helper.parseCreatorFromProvider(provider);
                this_1.creatorMap.set(token, creator_1);
                // use effect to Make sure there are no cycles
                void this_1.resolveToken(token);
                if ((0, helper_1.isClassCreator)(creator_1)) {
                    var domain = creator_1.opts.domain;
                    if (domain) {
                        var domains = Array.isArray(domain) ? domain : [domain];
                        this_1.addToDomain(domains, token);
                    }
                    if ((0, helper_1.isAspectCreator)(creator_1)) {
                        var hookMetadata = (0, helper_1.getHookMeta)(creator_1.useClass);
                        var toDispose_1;
                        var instance_1;
                        var getInstance_1 = function () {
                            if (!instance_1) {
                                instance_1 = _this.get(token);
                                _this.onceInstanceDisposed(instance_1, function () {
                                    if (toDispose_1) {
                                        toDispose_1.dispose();
                                        toDispose_1 = undefined;
                                    }
                                    instance_1 = undefined;
                                    // remove the aspect creator when the instance is disposed
                                    _this.creatorMap.delete(creator_1.useClass);
                                });
                            }
                            return instance_1;
                        };
                        var preprocessedHooks = hookMetadata.map(function (metadata) {
                            var wrapped = function () {
                                var _a;
                                var args = [];
                                for (var _i = 0; _i < arguments.length; _i++) {
                                    args[_i] = arguments[_i];
                                }
                                var instance = getInstance_1();
                                return (_a = instance[metadata.prop]).call.apply(_a, __spreadArray([instance], __read(args), false));
                            };
                            return {
                                awaitPromise: metadata.options.await,
                                hook: wrapped,
                                method: metadata.targetMethod,
                                target: metadata.target,
                                type: metadata.type,
                            };
                        });
                        toDispose_1 = this_1.hookStore.createHooks(preprocessedHooks);
                    }
                }
            }
        };
        var this_1 = this;
        try {
            for (var providers_1 = __values(providers), providers_1_1 = providers_1.next(); !providers_1_1.done; providers_1_1 = providers_1.next()) {
                var provider = providers_1_1.value;
                _loop_1(provider);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (providers_1_1 && !providers_1_1.done && (_a = providers_1.return)) _a.call(providers_1);
            }
            finally { if (e_6) throw e_6.error; }
        }
    };
    Injector.prototype.addToDomain = function (domains, token) {
        var e_7, _a;
        try {
            for (var domains_2 = __values(domains), domains_2_1 = domains_2.next(); !domains_2_1.done; domains_2_1 = domains_2.next()) {
                var domain = domains_2_1.value;
                var tokens = this.domainMap.get(domain) || [];
                tokens.push(token);
                this.domainMap.set(domain, tokens);
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (domains_2_1 && !domains_2_1.done && (_a = domains_2.return)) _a.call(domains_2);
            }
            finally { if (e_7) throw e_7.error; }
        }
    };
    Injector.prototype.getNextInstanceId = function () {
        return this.instanceIdGenerator.create();
    };
    Injector.prototype.resolveToken = function (token) {
        var creator = this.creatorMap.get(token);
        var paths = [token];
        while (creator && (0, helper_1.isAliasCreator)(creator)) {
            token = creator.useAlias;
            if (paths.includes(token)) {
                throw InjectorError.aliasCircularError(paths, token);
            }
            paths.push(token);
            creator = this.creatorMap.get(token);
        }
        return [token, creator];
    };
    Injector.prototype.getCreator = function (token) {
        var creator = this.resolveToken(token)[1];
        if (creator) {
            return [creator, this];
        }
        if (this.parent) {
            return this.parent.getCreator(token);
        }
        return [null, this];
    };
    Injector.prototype.getOrSaveInstanceId = function (instance, id) {
        if (this.instanceRefMap.has(instance)) {
            return this.instanceRefMap.get(instance);
        }
        this.instanceRefMap.set(instance, id);
        return id;
    };
    Injector.prototype.createInstance = function (ctx, defaultOpts, args) {
        var creator = ctx.creator, token = ctx.token;
        if (creator.dropdownForTag && creator.tag !== this.tag) {
            throw InjectorError.tagOnlyError(String(creator.tag), String(this.tag));
        }
        if (Helper.isClassCreator(creator)) {
            var opts = defaultOpts !== null && defaultOpts !== void 0 ? defaultOpts : creator.opts;
            // if a class creator is singleton, and the instance is already created, return the instance.
            if (!opts.multiple && creator.status === declare_1.CreatorStatus.done) {
                return creator.instance;
            }
            return this.createInstanceFromClassCreator(ctx, opts, args);
        }
        if (Helper.isFactoryCreator(creator)) {
            return (0, helper_1.applyHooks)(creator.useFactory(this), token, this.hookStore);
        }
        // must be ValueCreator, no need to hook.
        return creator.instance;
    };
    Injector.prototype.createInstanceFromClassCreator = function (ctx, opts, defaultArgs) {
        var creator = ctx.creator, token = ctx.token, injector = ctx.injector;
        var cls = creator.useClass;
        var currentStatus = creator.status;
        // If you try to create an instance whose status is creating, it must be caused by circular dependencies.
        if (currentStatus === declare_1.CreatorStatus.creating) {
            throw InjectorError.circularError(cls, ctx);
        }
        creator.status = declare_1.CreatorStatus.creating;
        try {
            var args = defaultArgs !== null && defaultArgs !== void 0 ? defaultArgs : this.getParameters(creator.parameters, ctx);
            var nextId = this.getNextInstanceId();
            var instance = this.createInstanceWithInjector(cls, token, injector, args, nextId);
            void this.getOrSaveInstanceId(instance, nextId);
            creator.status = declare_1.CreatorStatus.init;
            // if not allow multiple, save the instance in creator.
            if (!opts.multiple) {
                creator.status = declare_1.CreatorStatus.done;
                creator.instance = instance;
            }
            return instance;
        }
        catch (e) {
            // rollback the status if exception occurs
            creator.status = currentStatus;
            throw e;
        }
    };
    Injector.prototype.getParameters = function (parameters, state) {
        var _this = this;
        return parameters.map(function (opts) {
            var _a = __read(_this.getCreator(opts.token), 2), creator = _a[0], injector = _a[1];
            if (creator) {
                return _this.createInstance({
                    injector: injector,
                    creator: creator,
                    token: opts.token,
                    parent: state,
                }, undefined, undefined);
            }
            if (!creator && Object.prototype.hasOwnProperty.call(opts, 'default')) {
                return opts.default;
            }
            throw InjectorError.noProviderError(opts.token);
        });
    };
    Injector.prototype.createInstanceWithInjector = function (cls, token, injector, args, id) {
        // when creating an instance, set injector to prototype, so that the constructor can access it.
        // after creating the instance, remove the injector from prototype to prevent memory leaks.
        (0, helper_1.setInjector)(cls.prototype, injector);
        var ret = new (cls.bind.apply(cls, __spreadArray([void 0], __read(args), false)))();
        (0, helper_1.removeInjector)(cls.prototype);
        // mount injector on the instance, so that the inner object can access the injector in the future.
        (0, helper_1.setInjector)(ret, injector);
        Object.assign(ret, {
            __id: id,
            __injectorId: injector.id,
        });
        return (0, helper_1.applyHooks)(ret, token, this.hookStore);
    };
    Injector.prototype.getInstanceId = function (instance) {
        return this.instanceRefMap.get(instance);
    };
    return Injector;
}());
exports.Injector = Injector;
