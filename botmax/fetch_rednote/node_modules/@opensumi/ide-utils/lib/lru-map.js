"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaleLRUMap = exports.LRUMap = void 0;
const event_1 = require("./event");
/**
 * 自带LRU清理的Map
 * 双向链表 + Map
 */
class LRUMap extends Map {
    constructor(hardLimit, softLimit) {
        super();
        this.hardLimit = hardLimit;
        this.softLimit = softLimit;
        this._onDidDelete = new event_1.Emitter();
        this.onDidDelete = this._onDidDelete.event;
        this.onKeyDidDelete = (key, ...args) => event_1.Event.filter(this.onDidDelete, (e) => e.key === key)(...args);
        this.head = { key: undefined, prev: undefined, next: undefined };
        this.tail = { key: undefined, prev: undefined, next: undefined };
        this.map = new Map();
        if (hardLimit < softLimit) {
            throw new Error('hardLimit must be greater equal than softLimit.');
        }
        this.head.next = this.tail;
        this.tail.prev = this.head;
    }
    markRecentUsed(key) {
        if (!this.map.get(key)) {
            this.map.set(key, { key, prev: undefined, next: undefined });
        }
        this.putHead(this.map.get(key));
    }
    get(key) {
        const v = super.get(key);
        if (v) {
            this.markRecentUsed(key);
        }
        return v;
    }
    set(key, value) {
        this.markRecentUsed(key);
        super.set(key, value);
        if (this.size > this.hardLimit) {
            this.shrink();
        }
        return this;
    }
    putHead(node) {
        this.deleteNodeFromList(node);
        const lastHead = this.head.next;
        this.head.next = node;
        node.next = lastHead;
        node.prev = undefined;
        if (lastHead) {
            lastHead.prev = node;
        }
    }
    deleteNodeFromList(node) {
        if (node.prev) {
            node.prev.next = node.next;
        }
        if (node.next) {
            node.next.prev = node.prev;
        }
    }
    delete(key) {
        const node = this.map.get(key);
        if (node) {
            this.deleteNodeFromList(node);
        }
        const value = super.get(key);
        this._onDidDelete.fire({
            key,
            value: value,
        });
        return super.delete(key);
    }
    shrink() {
        const toDelete = this.size - this.softLimit;
        let toDeleteNode = this.tail;
        for (let i = 0; i < toDelete; i++) {
            toDeleteNode = this.tail.prev;
            if (!toDeleteNode || toDeleteNode === this.head) {
                break;
            }
            else {
                this.delete(toDeleteNode.key);
            }
        }
    }
}
exports.LRUMap = LRUMap;
const NOW = Symbol('now');
/**
 * 支持过期时间
 */
class StaleLRUMap extends LRUMap {
    constructor(hardLimit, softLimit, maxAge) {
        super(hardLimit, softLimit);
        this.maxAge = maxAge;
    }
    get(key) {
        const v = super.get(key);
        if (v) {
            if (!this._isStale(v)) {
                return v;
            }
            // 过期则删除该条记录
            this.delete(key);
        }
        return undefined;
    }
    set(key, value) {
        value[NOW] = Date.now();
        return super.set(key, value);
    }
    _isStale(value) {
        return value[NOW] + this.maxAge <= Date.now();
    }
}
exports.StaleLRUMap = StaleLRUMap;
//# sourceMappingURL=lru-map.js.map