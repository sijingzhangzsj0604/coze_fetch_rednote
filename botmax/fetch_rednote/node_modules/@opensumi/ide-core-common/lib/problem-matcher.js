"use strict";
/** ******************************************************************************
 * Copyright (C) 2018 Red Hat, Inc. and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
// Some code copied and modified from https://github.com/eclipse-theia/theia/tree/v1.14.0/packages/task/src/browser/task-problem-matcher-registry.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProblemMatchersRegistryImpl = exports.IProblemMatcherRegistry = exports.WatchingMatcher = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@opensumi/di");
const ide_utils_1 = require("@opensumi/ide-utils");
const problem_pattern_1 = require("./problem-pattern");
var WatchingMatcher;
(function (WatchingMatcher) {
    function fromWatchingMatcherContribution(value) {
        if (!value) {
            return undefined;
        }
        return {
            activeOnStart: !!value.activeOnStart,
            beginsPattern: typeof value.beginsPattern === 'string' ? { regexp: value.beginsPattern } : value.beginsPattern,
            endsPattern: typeof value.endsPattern === 'string' ? { regexp: value.endsPattern } : value.endsPattern,
        };
    }
    WatchingMatcher.fromWatchingMatcherContribution = fromWatchingMatcherContribution;
})(WatchingMatcher = exports.WatchingMatcher || (exports.WatchingMatcher = {}));
exports.IProblemMatcherRegistry = Symbol('IProblemMatcherRegistry');
let ProblemMatchersRegistryImpl = class ProblemMatchersRegistryImpl {
    constructor() {
        this.onDidChangeProblemMatcherEmitter = new ide_utils_1.Emitter();
        this.matchers = new Map();
        /**
         * Finds the problem matcher from the registry by its name.
         *
         * @param name the name of the problem matcher
         * @return the problem matcher. If the task definition is not found, `undefined` is returned.
         */
        this.get = (name) => {
            if (name.startsWith('$')) {
                return this.matchers.get(name.slice(1));
            }
            return this.matchers.get(name);
        };
        this.init();
    }
    init() {
        this.fillDefaults();
    }
    /**
     * Returns all registered problem matchers in the registry.
     */
    getAll() {
        const all = [];
        for (const matcherName of this.matchers.keys()) {
            all.push(this.get(matcherName));
        }
        all.sort((one, other) => one.name.localeCompare(other.name));
        return all;
    }
    /**
     * Add a problem matcher to the registry.
     *
     * @param definition the problem matcher to be added.
     */
    register(matcher) {
        if (!matcher.name) {
            // eslint-disable-next-line no-console
            console.error('Only named Problem Matchers can be registered.');
            return ide_utils_1.Disposable.NULL;
        }
        const toDispose = new ide_utils_1.DisposableCollection(ide_utils_1.Disposable.create(() => {
            /* mark as not disposed */
            this.onDidChangeProblemMatcherEmitter.fire(undefined);
        }));
        this.doRegister(matcher, toDispose).then(() => this.onDidChangeProblemMatcherEmitter.fire(undefined));
        return toDispose;
    }
    async doRegister(matcher, toDispose) {
        const problemMatcher = await this.getProblemMatcherFromContribution(matcher);
        if (toDispose.disposed) {
            return;
        }
        toDispose.push(this.add(problemMatcher));
    }
    add(matcher) {
        this.matchers.set(matcher.name, matcher);
        return ide_utils_1.Disposable.create(() => this.matchers.delete(matcher.name));
    }
    /**
     * Transforms the `ProblemMatcherContribution` to a `ProblemMatcher`
     *
     * @return the problem matcher
     */
    async getProblemMatcherFromContribution(matcher) {
        let baseMatcher;
        if (matcher.base) {
            baseMatcher = this.get(matcher.base);
        }
        let fileLocation;
        let filePrefix;
        if (matcher.fileLocation === undefined) {
            fileLocation = baseMatcher ? baseMatcher.fileLocation : problem_pattern_1.FileLocationKind.Relative;
            filePrefix = baseMatcher ? baseMatcher.filePrefix : '${workspaceFolder}';
        }
        else {
            const locationAndPrefix = this.getFileLocationKindAndPrefix(matcher);
            fileLocation = locationAndPrefix.fileLocation;
            filePrefix = locationAndPrefix.filePrefix;
        }
        const patterns = [];
        if (matcher.pattern) {
            if (typeof matcher.pattern === 'string') {
                await this.problemPattern.onReady();
                const registeredPattern = this.problemPattern.get(matcher.pattern);
                if (Array.isArray(registeredPattern)) {
                    patterns.push(...registeredPattern);
                }
                else if (registeredPattern) {
                    patterns.push(registeredPattern);
                }
            }
            else if (Array.isArray(matcher.pattern)) {
                patterns.push(...matcher.pattern.map((p) => problem_pattern_1.ProblemPattern.fromProblemPatternContribution(p)));
            }
            else {
                patterns.push(problem_pattern_1.ProblemPattern.fromProblemPatternContribution(matcher.pattern));
            }
        }
        else if (baseMatcher) {
            patterns.push(...baseMatcher.pattern);
        }
        let deprecated = matcher.deprecated;
        if (deprecated === undefined && baseMatcher) {
            deprecated = baseMatcher.deprecated;
        }
        let applyTo;
        if (matcher.applyTo === undefined) {
            applyTo = baseMatcher ? baseMatcher.applyTo : problem_pattern_1.ApplyToKind.allDocuments;
        }
        else {
            applyTo = problem_pattern_1.ApplyToKind.fromString(matcher.applyTo) || problem_pattern_1.ApplyToKind.allDocuments;
        }
        let severity = problem_pattern_1.Severity.fromValue(matcher.severity);
        if (matcher.severity === undefined && baseMatcher && baseMatcher.severity !== undefined) {
            severity = baseMatcher.severity;
        }
        let watching = WatchingMatcher.fromWatchingMatcherContribution(matcher.background || matcher.watching);
        if (watching === undefined && baseMatcher) {
            watching = baseMatcher.watching;
        }
        const problemMatcher = {
            name: matcher.name || (baseMatcher ? baseMatcher.name : undefined),
            label: matcher.label || (baseMatcher ? baseMatcher.label : undefined),
            deprecated,
            owner: matcher.owner || (baseMatcher ? baseMatcher.owner : ''),
            source: matcher.source || (baseMatcher ? baseMatcher.source : undefined),
            applyTo,
            fileLocation,
            filePrefix,
            pattern: patterns,
            severity,
            watching,
        };
        return problemMatcher;
    }
    getFileLocationKindAndPrefix(matcher) {
        let fileLocation = problem_pattern_1.FileLocationKind.Relative;
        let filePrefix = '${workspaceFolder}';
        if (matcher.fileLocation !== undefined) {
            if (Array.isArray(matcher.fileLocation)) {
                if (matcher.fileLocation.length > 0) {
                    const locationKind = problem_pattern_1.FileLocationKind.fromString(matcher.fileLocation[0]);
                    if (matcher.fileLocation.length === 1 && locationKind === problem_pattern_1.FileLocationKind.Absolute) {
                        fileLocation = locationKind;
                    }
                    else if (matcher.fileLocation.length === 2 &&
                        locationKind === problem_pattern_1.FileLocationKind.Relative &&
                        matcher.fileLocation[1]) {
                        fileLocation = locationKind;
                        filePrefix = matcher.fileLocation[1];
                    }
                }
            }
            else {
                const locationKind = problem_pattern_1.FileLocationKind.fromString(matcher.fileLocation);
                if (locationKind) {
                    fileLocation = locationKind;
                    if (locationKind === problem_pattern_1.FileLocationKind.Relative) {
                        filePrefix = '${workspaceFolder}';
                    }
                }
            }
        }
        return { fileLocation, filePrefix };
    }
    // copied from https://github.com/Microsoft/vscode/blob/1.33.1/src/vs/workbench/contrib/tasks/common/problemMatcher.ts
    fillDefaults() {
        this.add({
            name: 'msCompile',
            label: 'Microsoft compiler problems',
            owner: 'msCompile',
            applyTo: problem_pattern_1.ApplyToKind.allDocuments,
            fileLocation: problem_pattern_1.FileLocationKind.Absolute,
            pattern: this.problemPattern.get('msCompile'),
        });
        this.add({
            name: 'lessCompile',
            label: 'Less problems',
            deprecated: true,
            owner: 'lessCompile',
            source: 'less',
            applyTo: problem_pattern_1.ApplyToKind.allDocuments,
            fileLocation: problem_pattern_1.FileLocationKind.Absolute,
            pattern: this.problemPattern.get('lessCompile'),
            severity: problem_pattern_1.Severity.Error,
        });
        this.add({
            name: 'gulp-tsc',
            label: 'Gulp TSC Problems',
            owner: 'typescript',
            source: 'ts',
            applyTo: problem_pattern_1.ApplyToKind.closedDocuments,
            fileLocation: problem_pattern_1.FileLocationKind.Relative,
            filePrefix: '${workspaceFolder}',
            pattern: this.problemPattern.get('gulp-tsc'),
        });
        this.add({
            name: 'jshint',
            label: 'JSHint problems',
            owner: 'jshint',
            source: 'jshint',
            applyTo: problem_pattern_1.ApplyToKind.allDocuments,
            fileLocation: problem_pattern_1.FileLocationKind.Absolute,
            pattern: this.problemPattern.get('jshint'),
        });
        this.add({
            name: 'jshint-stylish',
            label: 'JSHint stylish problems',
            owner: 'jshint',
            source: 'jshint',
            applyTo: problem_pattern_1.ApplyToKind.allDocuments,
            fileLocation: problem_pattern_1.FileLocationKind.Absolute,
            pattern: this.problemPattern.get('jshint-stylish'),
        });
        this.add({
            name: 'eslint-compact',
            label: 'ESLint compact problems',
            owner: 'eslint',
            source: 'eslint',
            applyTo: problem_pattern_1.ApplyToKind.allDocuments,
            fileLocation: problem_pattern_1.FileLocationKind.Absolute,
            filePrefix: '${workspaceFolder}',
            pattern: this.problemPattern.get('eslint-compact'),
        });
        this.add({
            name: 'eslint-stylish',
            label: 'ESLint stylish problems',
            owner: 'eslint',
            source: 'eslint',
            applyTo: problem_pattern_1.ApplyToKind.allDocuments,
            fileLocation: problem_pattern_1.FileLocationKind.Absolute,
            pattern: this.problemPattern.get('eslint-stylish'),
        });
        this.add({
            name: 'go',
            label: 'Go problems',
            owner: 'go',
            source: 'go',
            applyTo: problem_pattern_1.ApplyToKind.allDocuments,
            fileLocation: problem_pattern_1.FileLocationKind.Relative,
            filePrefix: '${workspaceFolder}',
            pattern: this.problemPattern.get('go'),
        });
    }
};
tslib_1.__decorate([
    (0, di_1.Autowired)(problem_pattern_1.IProblemPatternRegistry),
    tslib_1.__metadata("design:type", Object)
], ProblemMatchersRegistryImpl.prototype, "problemPattern", void 0);
ProblemMatchersRegistryImpl = tslib_1.__decorate([
    (0, di_1.Injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], ProblemMatchersRegistryImpl);
exports.ProblemMatchersRegistryImpl = ProblemMatchersRegistryImpl;
//# sourceMappingURL=problem-matcher.js.map