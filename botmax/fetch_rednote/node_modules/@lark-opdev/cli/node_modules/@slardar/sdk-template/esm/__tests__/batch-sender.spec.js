import ava from 'ava';
import sinon from 'sinon';
import { createBatchSender } from '../batch-sender';
import { noop } from '../utils';
var test = ava;
test.beforeEach(function (t) {
    t.context.clock = sinon.useFakeTimers();
});
test.afterEach(function (t) {
    t.context.clock.restore();
});
test('batchSender - flush', function (t) {
    var post = sinon.fake();
    var sender = createBatchSender({
        endpoint: 'end',
        transport: {
            get: noop,
            post: post,
        },
        wait: 1000,
    });
    sender.flush();
    t.assert(post.notCalled);
    sender.send(1);
    sender.send(2);
    t.assert(post.notCalled);
    sender.flush();
    t.assert(post.calledOnce);
    t.is(post.args[0][0].url, 'end');
    t.deepEqual(JSON.parse(post.args[0][0].data), {
        ev_type: 'batch',
        list: [1, 2],
    });
});
test('batchSender - size', function (t) {
    var post = sinon.fake();
    var sender = createBatchSender({
        endpoint: 'end',
        transport: {
            get: noop,
            post: post,
        },
        size: 3,
        wait: 1000,
    });
    sender.send(1);
    sender.send(2);
    t.assert(post.notCalled);
    sender.send(3);
    t.assert(post.calledOnce);
    t.is(post.args[0][0].url, 'end');
    t.deepEqual(JSON.parse(post.args[0][0].data), {
        ev_type: 'batch',
        list: [1, 2, 3],
    });
});
test.serial('batchSender - default', function (t) {
    var post = sinon.fake();
    var sender = createBatchSender({
        endpoint: 'end',
        transport: {
            get: noop,
            post: post,
        },
        wait: 1000,
    });
    sender.send(1);
    sender.send(2);
    t.assert(post.notCalled);
    t.deepEqual(JSON.parse(sender.getBatchData()), {
        ev_type: 'batch',
        list: [1, 2],
    });
    t.context.clock.tick(1100);
    t.assert(post.calledOnce);
    t.is(post.args[0][0].url, 'end');
    t.deepEqual(JSON.parse(post.args[0][0].data), {
        ev_type: 'batch',
        list: [1, 2],
    });
});
test.serial('batchSender - wait', function (t) {
    var post = sinon.fake();
    var sender = createBatchSender({
        endpoint: 'end',
        transport: {
            get: noop,
            post: post,
        },
        wait: 10000,
    });
    sender.send(1);
    sender.send(2);
    t.assert(post.notCalled);
    t.deepEqual(JSON.parse(sender.getBatchData()), {
        ev_type: 'batch',
        list: [1, 2],
    });
    t.context.clock.tick(1100);
    t.assert(post.notCalled);
    t.context.clock.tick(8100);
    t.assert(post.notCalled);
    t.context.clock.tick(2000);
    t.assert(post.calledOnce);
    t.is(post.args[0][0].url, 'end');
    t.deepEqual(JSON.parse(post.args[0][0].data), {
        ev_type: 'batch',
        list: [1, 2],
    });
});
test.serial('batchSender - update size and wait', function (t) {
    var post = sinon.fake();
    var sender = createBatchSender({
        endpoint: 'end',
        transport: {
            get: noop,
            post: post,
        },
        wait: 1000,
    });
    sender.send(1);
    sender.send(2);
    t.assert(post.notCalled);
    t.deepEqual(JSON.parse(sender.getBatchData()), {
        ev_type: 'batch',
        list: [1, 2],
    });
    sender.setSize(3);
    sender.send(3);
    t.assert(post.calledOnce);
    t.is(post.args[0][0].url, 'end');
    t.deepEqual(JSON.parse(post.args[0][0].data), {
        ev_type: 'batch',
        list: [1, 2, 3],
    });
    sender.setWait(200);
    sender.send(4);
    t.context.clock.tick(500);
    t.assert(post.calledTwice);
    t.is(post.args[1][0].url, 'end');
    t.deepEqual(JSON.parse(post.args[1][0].data), {
        ev_type: 'batch',
        list: [4],
    });
});
test.serial('batchSender - clear', function (t) {
    var post = sinon.fake();
    var sender = createBatchSender({
        endpoint: 'end',
        transport: {
            get: noop,
            post: post,
        },
        wait: 1000,
    });
    sender.send(1);
    sender.send(2);
    t.assert(post.notCalled);
    t.deepEqual(JSON.parse(sender.getBatchData()), {
        ev_type: 'batch',
        list: [1, 2],
    });
    t.context.clock.tick(500);
    t.assert(post.notCalled);
    sender.clear();
    t.assert(post.notCalled);
    t.is(sender.getBatchData(), '');
    sender.send(3);
    sender.send(4);
    t.assert(post.notCalled);
    t.deepEqual(JSON.parse(sender.getBatchData()), {
        ev_type: 'batch',
        list: [3, 4],
    });
    t.context.clock.tick(500);
    t.assert(post.notCalled);
    t.context.clock.tick(600);
    t.assert(post.calledOnce);
    t.is(post.args[0][0].url, 'end');
    t.deepEqual(JSON.parse(post.args[0][0].data), {
        ev_type: 'batch',
        list: [3, 4],
    });
});
test.serial('batchSender - fail', function (t) {
    var post = sinon.fake();
    var sender = createBatchSender({
        endpoint: 'end',
        transport: {
            get: noop,
            post: post,
        },
        wait: 1000,
    });
    var error = new Error('send error msg');
    sender.fail(function (err, data) {
        t.deepEqual(err, error);
        t.deepEqual(data, JSON.stringify({
            ev_type: 'batch',
            list: [1, 2],
        }));
    });
    sender.send(1);
    sender.send(2);
    t.assert(post.notCalled);
    t.deepEqual(JSON.parse(sender.getBatchData()), {
        ev_type: 'batch',
        list: [1, 2],
    });
    t.context.clock.tick(1000);
    t.assert(post.calledOnce);
    post.args[0][0].fail(error);
});
//# sourceMappingURL=batch-sender.spec.js.map