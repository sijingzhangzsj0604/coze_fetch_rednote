import { __assign, __read, __spreadArray } from 'tslib';

var DEFAULT_SIZE = 10;
var DEFAULT_WAIT = 1000;
var stringifyBatch = function (list) {
    return JSON.stringify({
        ev_type: 'batch',
        list: list,
    });
};
function createBatchSender(config) {
    var transport = config.transport;
    var endpoint = config.endpoint, _a = config.size, size = _a === void 0 ? DEFAULT_SIZE : _a, _b = config.wait, wait = _b === void 0 ? DEFAULT_WAIT : _b;
    var batch = [];
    var tid = 0;
    var fail;
    var sender = {
        getSize: function () {
            return size;
        },
        getWait: function () {
            return wait;
        },
        setSize: function (v) {
            size = v;
        },
        setWait: function (v) {
            wait = v;
        },
        getEndpoint: function () {
            return endpoint;
        },
        setEndpoint: function (v) {
            endpoint = v;
        },
        send: function (e) {
            batch.push(e);
            if (batch.length >= size) {
                sendBatch.call(this);
            }
            clearTimeout(tid);
            tid = setTimeout(sendBatch.bind(this), wait);
        },
        flush: function () {
            clearTimeout(tid);
            sendBatch.call(this);
        },
        getBatchData: function () {
            return batch.length ? stringifyBatch(batch) : '';
        },
        clear: function () {
            clearTimeout(tid);
            batch = [];
        },
        fail: function (cb) {
            fail = cb;
        },
    };
    function sendBatch() {
        if (!batch.length) {
            return;
        }
        var data = this.getBatchData();
        transport.post({
            url: endpoint,
            data: data,
            fail: function (err) {
                fail && fail(err, data);
            },
        });
        batch = [];
    }
    return sender;
}

var noop = function () { return ({}); };
function id(v) {
    return v;
}

// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(o) {
    return typeof o === 'object' && o !== null;
}
function isInstanceOf(wat, base) {
    try {
        return wat instanceof base;
    }
    catch (_e) {
        return false;
    }
}
var objProto = Object.prototype;
// https://stackoverflow.com/a/5878101
function isPlainObject(o) {
    if (isObject(o)) {
        if (typeof Object.getPrototypeOf === 'function') {
            var proto = Object.getPrototypeOf(o);
            return proto === objProto || proto === null;
        }
        // cannot test, requires ES3
        /* istanbul ignore next */
        return objProto.toString.call(o) === '[object Object]';
    }
    return false;
}
function isArray(o) {
    return objProto.toString.call(o) === '[object Array]';
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isFunction(o) {
    return typeof o === 'function';
}
function isBoolean(o) {
    return typeof o === 'boolean';
}
function isNumber(o) {
    return typeof o === 'number';
}
function isString(o) {
    return typeof o === 'string';
}
function isError(wat) {
    switch (Object.prototype.toString.call(wat)) {
        case '[object Error]':
            return true;
        case '[object Exception]':
            /* istanbul ignore next */
            return true;
        case '[object DOMError]':
            return true;
        case '[object DOMException]':
            /* istanbul ignore next */
            return true;
        default:
            /* istanbul ignore next */
            return wat instanceof Error;
    }
}
function isEvent(wat) {
    return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
}
function isErrorEvent(what) {
    return Object.prototype.toString.call(what) === '[object ErrorEvent]';
}
function isPromiseRejectionEvent(what) {
    return Object.prototype.toString.call(what) === '[object PromiseRejectionEvent]';
}

function hasKey(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
}
// 把source对象中的内容深度赋给target, 数组合并
function mergeDeepConcatArray() {
    var source = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        source[_i] = arguments[_i];
    }
    var result = {};
    var k = 0;
    while (k < source.length) {
        result = _mergeDeepMergeArray(result, source[k++]);
    }
    return result;
}
// 递归赋值
function _mergeDeepMergeArray(target, source) {
    var result = __assign({}, target);
    for (var key in source) {
        if (hasKey(source, key) && source[key] !== undefined) {
            if (isObject(source[key]) && isPlainObject(source[key])) {
                result[key] = _mergeDeepMergeArray(isObject(target[key]) ? target[key] : {}, source[key]);
            }
            else if (isArray(source[key]) && isArray(target[key])) {
                result[key] = _mergeDeepArray(target[key], source[key]);
            }
            else {
                result[key] = source[key];
            }
        }
    }
    return result;
}
function _mergeDeepArray(target, source) {
    var _target = isArray(target) ? target : [];
    var _source = isArray(source) ? source : [];
    return Array.prototype.concat.call(_target, _source).map(function (v) {
        if (v instanceof RegExp) {
            return v;
        }
        else if (isObject(v) && isPlainObject(v)) {
            return _mergeDeepMergeArray({}, v);
        }
        else if (isArray(v)) {
            return _mergeDeepArray([], v);
        }
        else {
            return v;
        }
    });
}
// 检查数组中是否有元素
function arrayIncludes(array, value) {
    if (!isArray(array)) {
        return false;
    }
    if (array.length === 0) {
        return false;
    }
    var k = 0;
    while (k < array.length) {
        if (array[k] === value) {
            return true;
        }
        k++;
    }
    return false;
}
var arrayRemove = function (arr, e) {
    if (!isArray(arr)) {
        return arr;
    }
    var i = arr.indexOf(e);
    if (i >= 0) {
        var arr_ = arr.slice();
        arr_.splice(i, 1);
        return arr_;
    }
    return arr;
};
/**
 * 按路径访问对象属性
 * @param target 待访问对象
 * @param property 访问属性路径
 * @param { (target: any, property: string): any } visitor 访问器
 */
var safeVisit = function (target, path, visitor) {
    var _a, _b;
    var paths = path.split('.');
    var _c = __read(paths), method = _c[0], rest = _c.slice(1);
    while (target && rest.length > 0) {
        target = target[method];
        _a = rest, _b = __read(_a), method = _b[0], rest = _b.slice(1);
    }
    if (!target) {
        return undefined;
    }
    return visitor(target, method);
};
var applyRecord = function () {
    var record = {};
    var set = function (key, val) { return (record[key] = val); };
    var del = function (key) { return delete record[key]; };
    return [record, set, del];
};
var pick = function (obj, keys) {
    if (!obj || !isObject(obj))
        return obj;
    return keys.reduce(function (prev, cur) {
        prev[cur] = obj[cur];
        return prev;
    }, {});
};

function getRegexp(ignore) {
    if (!isArray(ignore)) {
        return null;
    }
    return ignore.length ? joinRegExp(ignore) : null;
}
function joinRegExp(patterns) {
    var sources = [];
    var len = patterns.length;
    for (var i = 0; i < len; i++) {
        var pattern = patterns[i];
        if (isString(pattern)) {
            sources.push(pattern.replace(/([.*+?^=!:${}()|[\]/\\])/g, '\\$1'));
        }
        else if (pattern && pattern.source) {
            sources.push(pattern.source);
        }
    }
    return new RegExp(sources.join('|'), 'i');
}
function safeStringify(a) {
    try {
        return isString(a) ? a : JSON.stringify(a);
    }
    catch (err) {
        return '[FAILED_TO_STRINGIFY]:' + String(err);
    }
}

// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * You can feel free to restore when you hook a function.
 * But you ought to restore 「in order」 if you hooked a value reference or a real obj reference.Because we not store the last value referent for now.
 * eg: obj.a = 1;
 * const r_1 = hookObjectProperty(obj, 'a',() =>2)()
 * const r_2 = hookObjectProperty(obj, 'a',() =>3)()
 * r_2() // obj.a === 2
 * r_1() // obj.a === 1
 *
 * @template T
 * @template K
 * @template P
 * @param {T} obj
 * @param {K} key
 * @param {(origin: T[K], ...params: P) => T[K]} hookFunc
 * @param {boolean} isCatchError When an error occurs after calling a hooked function, we want to suppress the errors and try to call the original function by default.
 * @return {*}
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var hookObjectProperty = function (obj, key, hookFunc, isCatchError) {
    if (isCatchError === void 0) { isCatchError = true; }
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, __spreadArray([origin], __read(params), false));
        var hooked = hookedUnsafe;
        // 给所有 hook 之后的方法包一层 try catch
        if (isFunction(hooked) && isCatchError) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                try {
                    return hookedUnsafe.apply(this, args);
                }
                catch (_a) {
                    return isFunction(origin) && origin.apply(this, args);
                }
            };
        }
        obj[key] = hooked;
        // strict: is break
        return function (strict) {
            if (!strict) {
                hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
            }
        };
    };
};
/**
 * 劫持对象方法
 * 必须记得给 hookFunc 劫持的方法包 try catch ！
 * 不在本方法里包是为了避免对象原方法被调用两次
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var hookMethodDangerously = function (obj, key, hookFunc) {
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, __spreadArray([origin], __read(params), false));
        var hooked = hookedUnsafe;
        if (isFunction(hooked)) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return hookedUnsafe.apply(this, args);
            };
        }
        obj[key] = hooked;
        return function () {
            hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
        };
    };
};

var count = 0;
var log = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    // eslint-disable-next-line no-console
    console.log.apply(console, __spreadArray(['[SDK]', Date.now(), ("" + count++).padStart(8, ' ')], __read(args), false));
};

var isHitBySampleRate = function (sampleRate) {
    if (Math.random() < Number(sampleRate)) {
        return true;
    }
    return false;
};
var isHitByRandom = function (random, sampleRate) {
    if (random < Number(sampleRate)) {
        return true;
    }
    return false;
};

/**
 * 生成uuid
 * stolen from https://github.com/kelektiv/node-uuid#readme uuid/v4
 *
 * @returns
 */
function mathRNG() {
    var rnds = new Array(16);
    var r = 0;
    for (var i = 0; i < 16; i++) {
        if ((i & 0x03) === 0) {
            r = Math.random() * 0x100000000;
        }
        rnds[i] = (r >>> ((i & 0x03) << 3)) & 0xff;
    }
    return rnds;
}
function bytesToUuid(buf) {
    var byteToHex = [];
    for (var index = 0; index < 256; ++index) {
        byteToHex[index] = (index + 0x100).toString(16).substr(1);
    }
    var i = 0;
    var bth = byteToHex;
    // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
    return [
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
    ].join('');
}
function uuid() {
    var rnds = mathRNG();
    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    return bytesToUuid(rnds);
}

var BUFFER_TIME = 300000; // 5分钟
var applyBufferTimer = function (checkIfNeedCancel, cb, bufferTime) {
    var tid = 0;
    if (bufferTime === -1)
        return noop;
    return function () {
        if (checkIfNeedCancel()) {
            tid && clearTimeout(tid);
            tid = 0;
            return;
        }
        tid === 0 && (tid = setTimeout(cb, bufferTime));
    };
};

/* eslint-disable @typescript-eslint/no-invalid-void-type */
var nextLink = function (args, cb) {
    var nextCbs = [];
    try {
        nextCbs = cb.reduce(function (sum, s) {
            try {
                var nextCb = s(args);
                typeof nextCb === 'function' && sum.push(nextCb);
            }
            catch (_a) {
                // do nothing
            }
            return sum;
        }, []);
    }
    catch (_a) {
        // do nothing
    }
    return function (nextArgs) { return nextLink(nextArgs, nextCbs); };
};
var toObservable = function (bufferTime) {
    if (bufferTime === void 0) { bufferTime = BUFFER_TIME; }
    var subscribers = [];
    var __complete = [];
    var closed = false;
    var attachCb;
    // 暂缓的自动销毁机制，比如5min 没有人订阅就自动销毁
    var setCloseIfNeed = applyBufferTimer(function () { return !!subscribers.length; }, function () {
        closed = true;
        attachCb && attachCb[0]();
        __complete.forEach(function (e) { return e(); });
        __complete.length = 0;
        attachCb = undefined;
    }, bufferTime);
    var unsubscribe = function (o) {
        subscribers = arrayRemove(subscribers, o);
        !closed && setCloseIfNeed();
    };
    return {
        next: function (args) {
            return nextLink(args, subscribers);
        },
        complete: function (cb) {
            __complete.push(cb);
        },
        attach: function (disconnect, onSubscribe) {
            attachCb = [disconnect, onSubscribe];
        },
        subscribe: function (o) {
            if (closed)
                throw new Error('Observer is closed');
            subscribers.push(o);
            attachCb && attachCb[1] && attachCb[1](o);
            setCloseIfNeed();
            return function () { return unsubscribe(o); };
        },
        unsubscribe: unsubscribe,
    };
};
var createSafeObserver = function (observer, completeCb, bufferTime) {
    var cur = toObservable(bufferTime);
    try {
        observer(cur.next, cur.attach);
        completeCb && cur.complete(completeCb);
    }
    catch (_a) {
        //
    }
    return [cur.subscribe, cur.unsubscribe];
};

/**
 * 由于 Observer 带有自动销毁机制，意味着subject 只支持同步注册并使用
 */
function initSubjectInGlobal(client, args) {
    return client.initSubject(args);
}
/**
 * 此方法不会挂载到全局对象上，同时只支持同步注册并使用
 */
function initPrivateSubject(client, _a, bufferTime) {
    var _b = __read(_a, 2), subjectKey = _b[0], observer = _b[1];
    var subjectMap = client.privateSubject || {};
    if (!subjectMap[subjectKey])
        subjectMap[subjectKey] = createSafeObserver(observer, function () {
            subjectMap[subjectKey] = undefined;
        }, bufferTime);
    return subjectMap[subjectKey];
}

function getDefaultBrowser() {
    if (typeof window === 'object' && isObject(window))
        return window;
}
function getDefaultDocument() {
    if (typeof document === 'object' && isObject(document))
        return document;
}
function getDefaultLocation() {
    return getDefaultBrowser() && window.location;
}
function getDefaultHistory() {
    // eslint-disable-next-line compat/compat
    return getDefaultBrowser() && window.history;
}
function getDefaultPerformance() {
    if (getDefaultBrowser() && isObject(window.performance))
        return window.performance;
}
function getDefaultPromise() {
    if (getDefaultBrowser() && 'Promise' in window)
        return Promise;
}
function getDefaultXMLHttpRequest() {
    if (typeof XMLHttpRequest === 'function' && isFunction(XMLHttpRequest))
        return XMLHttpRequest;
}
function getDefaultFetch() {
    try {
        // eslint-disable-next-line compat/compat
        new Headers();
        // eslint-disable-next-line compat/compat
        new Request('');
        // eslint-disable-next-line compat/compat
        new Response();
        // eslint-disable-next-line compat/compat
        return window.fetch;
    }
    catch (_a) {
        //
    }
}
function getDefaultMutationObserver() {
    if (getDefaultBrowser() && isFunction(window.MutationObserver))
        return window.MutationObserver;
}
function getDefaultPerformanceObserver() {
    if (getDefaultBrowser() && isFunction(window.PerformanceObserver))
        return window.PerformanceObserver;
}
function getDefaultPerformanceTiming() {
    var performance = getDefaultPerformance();
    if (performance && isObject(performance.timing))
        return performance.timing;
}
function getDefaultRaf() {
    if (getDefaultBrowser() && 'requestAnimationFrame' in window) {
        return window.requestAnimationFrame;
    }
}
function getDefaultCaf() {
    if (getDefaultBrowser() && 'cancelAnimationFrame' in window) {
        return window.cancelAnimationFrame;
    }
}
function getDefaultNavigator() {
    if (getDefaultBrowser() && 'navigator' in window) {
        return window.navigator;
    }
}
function getDefaultNetworkInformation() {
    var navigator = getDefaultNavigator();
    if (navigator) {
        return navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    }
}
function getCurrentScript() {
    if (!document)
        return null;
    if (document.currentScript)
        return document.currentScript;
    // IE 8-10 support script readyState
    // IE 11+ support stack trace
    try {
        throw new Error();
    }
    catch (err) {
        // Find the second match for the "at" string to get file src url from stack.
        // Specifically works with the format of stack traces in IE.
        var i = 0;
        var stackDetails = /at\s+(.*)\s+\((.*):(\d*):(\d*)\)/i.exec(err.stack);
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        var scriptLocation = (stackDetails && stackDetails[2]) || false;
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        var line = (stackDetails && stackDetails[3]) || 0;
        var currentLocation = document.location.href.replace(document.location.hash, '');
        var inlineScriptSource = '';
        var scripts = document.getElementsByTagName('script'); // Live NodeList collection
        if (scriptLocation === currentLocation) {
            var pageSource = document.documentElement.outerHTML;
            var inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
            inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
        }
        for (; i < scripts.length; i++) {
            // If ready state is interactive, return the script tag
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            if (scripts[i].readyState === 'interactive') {
                return scripts[i];
            }
            // If src matches, return the script tag
            if (scripts[i].src === scriptLocation) {
                return scripts[i];
            }
            // If inline source matches, return the script tag
            if (scriptLocation === currentLocation &&
                scripts[i].innerHTML &&
                scripts[i].innerHTML.trim() === inlineScriptSource) {
                return scripts[i];
            }
        }
        // If no match, return null
        return null;
    }
}

// 获取全局注册表
var getGlobalRegistry = function (global) {
    if (!global)
        return;
    if (!global.__SLARDAR_REGISTRY__) {
        global.__SLARDAR_REGISTRY__ = {
            Slardar: {
                plugins: [],
                errors: [],
                subject: {},
            },
        };
    }
    return global.__SLARDAR_REGISTRY__.Slardar;
};
var reportSelfError = function () {
    var errorInfo = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        errorInfo[_i] = arguments[_i];
    }
    var registry = getGlobalRegistry(getDefaultBrowser());
    if (!registry)
        return;
    if (!registry.errors) {
        registry.errors = [];
    }
    registry.errors.push(errorInfo);
};

var applyMutationObserver = function (MutationObserver, callback) {
    // eslint-disable-next-line compat/compat
    var observer = MutationObserver && new MutationObserver(callback);
    var observe = function (target, options) {
        observer && target && observer.observe(target, options);
    };
    var disconnect = function () { return observer && observer.disconnect(); };
    return [observe, disconnect];
};
var applyAnimationFrame = function (document, originRAF, originCAF, force) {
    var requestAnimationFrame = 
    // eslint-disable-next-line compat/compat
    !isFunction(originRAF) || (force && document && document.hidden)
        ? function (cb) {
            cb(0);
            return 0;
        }
        : originRAF;
    var cancelAnimationFrame = isFunction(originCAF) ? originCAF : noop;
    /**
     * 以 animationFrame 调用函数，如果一帧内多次调用，则会取消前面的调用
     */
    var af;
    var scheduleAnimationFrame = function (cb) {
        af && cancelAnimationFrame(af);
        af = requestAnimationFrame(cb);
    };
    return [scheduleAnimationFrame, requestAnimationFrame, cancelAnimationFrame];
};
var applyPerformance = function (performance) {
    // eslint-disable-next-line compat/compat
    var timing = (performance && performance.timing) || undefined;
    var now = function () {
        if (performance && performance.now)
            return performance.now();
        var time = Date.now ? Date.now() : +new Date();
        var start = (timing && timing.navigationStart) || 0;
        return time - start;
    };
    var getEntriesByType = function (type) {
        var getEntriesByType = (performance || {}).getEntriesByType;
        return (isFunction(getEntriesByType) && getEntriesByType.call(performance, type)) || [];
    };
    var getEntriesByName = function (name) {
        var getEntriesByName = (performance || {}).getEntriesByName;
        return (isFunction(getEntriesByName) && getEntriesByName.call(performance, name)) || [];
    };
    var clearResourceTiming = function () {
        var clearResourceTimings = (performance || {}).clearResourceTimings;
        isFunction(clearResourceTimings) && clearResourceTimings.call(performance);
    };
    return [timing, now, getEntriesByType, clearResourceTiming, getEntriesByName];
};
var applyPerformanceObserver$1 = function (PerformanceObserver, callback, once, onFail) {
    var observer = PerformanceObserver &&
        // eslint-disable-next-line compat/compat
        new PerformanceObserver(function (list, ob) {
            if (list.getEntries) {
                list.getEntries().forEach(function (val, i, arr) { return callback(val, i, arr, ob); });
            }
            else {
                onFail && onFail();
            }
            once && ob.disconnect();
        });
    var observe = function () {
        var types = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            types[_i] = arguments[_i];
        }
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            types.forEach(function (type) {
                if (PerformanceObserver.supportedEntryTypes.indexOf(type) > -1) {
                    observer.observe({ type: type, buffered: false });
                }
            });
        }
        catch (_a) {
            try {
                observer.observe({ entryTypes: types });
            }
            catch (_b) {
                return onFail && onFail();
            }
        }
    };
    var disconnect = function () { return observer && observer.disconnect(); };
    return [observe, disconnect];
};
// eslint-disable-next-line @typescript-eslint/no-invalid-void-type
var applyMonitor = function (monitorCtor, props, cb, deps) {
    if (props === void 0) { props = {}; }
    if (deps === void 0) { deps = []; }
    try {
        var monitor = monitorCtor.apply(void 0, __spreadArray([], __read(deps), false));
        return (monitor && monitor(props, cb)) || [];
    }
    catch (e) {
        reportSelfError(e);
        return [];
    }
};
// eslint-disable-next-line @typescript-eslint/ban-types
var applyUpdate = function (init) {
    var state = init;
    var result = {};
    var defineGetter = function () {
        return Object.keys(state).forEach(function (key) {
            return !(key in result) &&
                Object.defineProperty(result, key, {
                    get: function () {
                        return state[key];
                    },
                });
        });
    };
    var update = function (newObj) {
        state = mergeDeepConcatArray(state, newObj);
        defineGetter();
    };
    defineGetter();
    return [result, update];
};
var applyRequestIdleCallback = function (win) {
    return (win.requestIdleCallback ||
        function (cb) {
            return win.setTimeout(cb, 1);
        });
};

var now = function () { return Date.now(); };

function getFullUrl(url) {
    var document = getDefaultDocument();
    if (!document || !url)
        return '';
    var a = document.createElement('a');
    a.href = url;
    return a.href;
}
function parseUrl(url) {
    var document = getDefaultDocument();
    if (!document || !url) {
        return {
            url: url,
            protocol: '',
            domain: '',
            query: '',
            path: '',
            hash: '',
        };
    }
    var a = document.createElement('a');
    a.href = url;
    var path = a.pathname || '/';
    /* istanbul ignore next */
    if (path[0] !== '/') {
        path = '/' + path;
    }
    return {
        url: a.href,
        protocol: a.protocol.slice(0, -1),
        domain: a.hostname,
        query: a.search.substring(1),
        path: path,
        hash: a.hash,
    };
}
function getLocationUrl() {
    var location = getDefaultBrowser() && getDefaultLocation();
    return location === null || location === void 0 ? void 0 : location.href;
}

var captureCurrentContext = function (client) {
    var capturedContext = {
        url: getLocationUrl(),
        timestamp: now(),
    };
    var config = client.config();
    if (config === null || config === void 0 ? void 0 : config.pid) {
        capturedContext.pid = config.pid;
    }
    if (client === null || client === void 0 ? void 0 : client['context']) {
        capturedContext.context = client['context'].toString();
    }
    return capturedContext;
};
// only works for sync report
// async report won't trigger 'report' immediately, es.g. sri
var syncReportWithCapturedContext = function (client, ctx) {
    return function (fn) {
        var inject = function (ev) {
            ev.overrides = ctx;
            return ev;
        };
        client.on('report', inject);
        fn();
        client.off('report', inject);
    };
};

/* eslint-disable @typescript-eslint/prefer-for-of */
var getCookieId = function (cookieIdName) {
    var document = getDefaultDocument();
    try {
        if (document === null || document === void 0 ? void 0 : document.cookie) {
            return getValueFromCookieName(document.cookie, cookieIdName);
        }
    }
    catch (_e) {
        // do nothing
    }
    return '';
};
var setCookie = function (key, value) {
    var document = getDefaultDocument();
    if (document && key) {
        try {
            document.cookie = key + "=" + value + ";max-age=" + 90 * 24 * 60 * 60;
        }
        catch (_e) {
            // do nothing
        }
    }
};
function getValueFromCookieName(cookie, name) {
    if (!cookie || !name) {
        return '';
    }
    return parseCookie(cookie)[name] || '';
}
function parseCookie(cookie) {
    var list = cookie.split(';');
    var cookieObj = {};
    for (var i = 0; i < list.length; i++) {
        var pair = list[i].split('=');
        var cookieKey = isString(pair[0]) && pair[0].trim();
        if (cookieKey && isString(pair[1])) {
            cookieObj[cookieKey] = pair[1].trim();
        }
    }
    return cookieObj;
}

/**
 * from sentry https://github.com/getsentry/sentry-javascript/blob/5.30.0/packages/utils/src/browser.ts
 */
var UNKNOWN_PATH = '<unknown>';
/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function htmlTreeAsString(elem) {
    // try/catch both:
    // - accessing event.target (see getsentry/raven-js#838, #768)
    // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
    // - can throw an exception in some circumstances.
    try {
        var currentElem = elem;
        var MAX_TRAVERSE_HEIGHT = 5;
        var MAX_OUTPUT_LEN = 80;
        var out = [];
        var height = 0;
        var len = 0;
        var separator = ' > ';
        var sepLength = separator.length;
        var nextStr = void 0;
        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
            nextStr = _htmlElementAsString(currentElem);
            // bail out if
            // - nextStr is the 'html' element
            // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
            //   (ignore this limit if we are on the first iteration)
            if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {
                break;
            }
            out.push(nextStr);
            len += nextStr.length;
            currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator);
    }
    catch (_oO) {
        return UNKNOWN_PATH;
    }
}
/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function _htmlElementAsString(el) {
    var elem = el;
    var out = [];
    var classes;
    var key;
    var attr;
    var i;
    if (!elem || !elem.tagName) {
        return '';
    }
    out.push(elem.tagName.toLowerCase());
    if (elem.id) {
        out.push("#" + elem.id);
    }
    var className = elem.className;
    if (className && isString(className)) {
        classes = className.split(/\s+/);
        for (i = 0; i < classes.length; i++) {
            out.push("." + classes[i]);
        }
    }
    var attrlist = ['type', 'name', 'title', 'alt'];
    for (i = 0; i < attrlist.length; i++) {
        key = attrlist[i];
        attr = elem.getAttribute(key);
        if (attr) {
            out.push("[" + key + "=\"" + attr + "\"]");
        }
    }
    return out.join('');
}
var applyDomAndKeyPress = function (debounceDuration) {
    var keypressTimeout;
    /**
     * Wraps addEventListener to capture UI breadcrumbs
     * @param name the event name (e.g. "click")
     * @param handler function that will be triggered
     * @param debounce decides whether it should wait till another event loop
     * @returns wrapped breadcrumb events handler
     * @hidden
     */
    var domEventHandler = function (name, handler) {
        var lastCapturedEvent;
        return function (event) {
            // reset keypress timeout; e.g. triggering a 'click' after
            // a 'keypress' will reset the keypress debounce so that a new
            // set of keypresses can be recorded
            keypressTimeout = undefined;
            // It's possible this handler might trigger multiple times for the same
            // event (e.g. event propagation through node ancestors). Ignore if we've
            // already captured the event.
            if (!event || lastCapturedEvent === event) {
                return;
            }
            lastCapturedEvent = event;
            handler({ event: event, name: name });
        };
    };
    /**
     * Wraps addEventListener to capture keypress UI events
     * @param handler function that will be triggered
     * @returns wrapped keypress events handler
     * @hidden
     */
    var keypressEventHandler = function (handler) {
        // TODO: if somehow user switches keypress target before
        //       debounce timeout is triggered, we will only capture
        //       a single breadcrumb from the FIRST target (acceptable?)
        return function (event) {
            var target;
            try {
                target = event.target;
            }
            catch (e) {
                // just accessing event properties can throw an exception in some rare circumstances
                // see: https://github.com/getsentry/raven-js/issues/838
                return;
            }
            var tagName = target && target.tagName;
            // only consider keypress events on actual input elements
            // this will disregard keypresses targeting body (e.g. tabbing
            // through elements, hotkeys, etc)
            if (!tagName || (tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !target.isContentEditable)) {
                return;
            }
            // record first keypress in a series, but ignore subsequent
            // keypresses until debounce clears
            !keypressTimeout && domEventHandler('input', handler)(event);
            clearTimeout(keypressTimeout);
            keypressTimeout = window.setTimeout(function () {
                keypressTimeout = undefined;
            }, debounceDuration);
        };
    };
    return [domEventHandler, keypressEventHandler];
};
var triggerHandlers = function (domBreadcrumb, type) {
    return function (data) {
        if (!type) {
            return;
        }
        try {
            domBreadcrumb(data);
        }
        catch (e) {
            // ignore
        }
    };
};
/**
 * Creates breadcrumbs from DOM API calls
 */
var domBreadcrumb = function (addBreadcrumb) { return function (handlerData) {
    var target;
    // Accessing event.target can throw (see getsentry/raven-js#838, #768)
    try {
        target = handlerData.event.target
            ? htmlTreeAsString(handlerData.event.target)
            : htmlTreeAsString(handlerData.event);
    }
    catch (e) {
        target = '<unknown>';
    }
    if (target.length === 0) {
        return;
    }
    addBreadcrumb({
        type: 'dom',
        category: "ui." + handlerData.name,
        message: target,
    });
}; };

function onPageLoad(callback) {
    var window = getDefaultBrowser();
    var document = getDefaultDocument();
    if (!window || !document)
        return;
    if (document.readyState === 'complete') {
        callback();
        return;
    }
    window.addEventListener('load', function () {
        setTimeout(function () {
            callback();
        }, 0);
    }, false);
}
function onDOMContentLoaded(callback) {
    var window = getDefaultBrowser();
    var document = getDefaultDocument();
    if (!window || !document)
        return;
    if (document.readyState === 'loading') {
        window.addEventListener('DOMContentLoaded', function () {
            setTimeout(function () {
                callback();
            }, 0);
        }, false);
        return;
    }
    callback();
}
var invokeCallbackOnce = function (cb) {
    var hasInvoked = false;
    var invoke = function (params) {
        if (hasInvoked)
            return;
        hasInvoked = true;
        cb && cb(params);
    };
    return [invoke];
};
var onPageUnload = function (cb) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    var _a = __read(invokeCallbackOnce(cb), 1), invokeCbOnce = _a[0];
    ['unload', 'beforeunload', 'pagehide'].forEach(function (ev) {
        window.addEventListener(ev, invokeCbOnce);
    });
};
var onceHidden = function (cb, once) {
    if (once === void 0) { once = true; }
    var document = getDefaultDocument();
    var window = getDefaultBrowser();
    if (!document || !window)
        return;
    if (document.visibilityState === 'hidden') {
        cb();
        return;
    }
    var onVisibilityChange = function () {
        if (document.visibilityState === 'hidden') {
            cb();
            once && removeEventListener('visibilitychange', onVisibilityChange, true);
        }
    };
    window.addEventListener('visibilitychange', onVisibilityChange, true);
};
var loadScript = function (url, callback) {
    var _a;
    /* istanbul ignore next */
    var document = getDefaultDocument();
    // untestable for now
    /* istanbul ignore next */
    if (document) {
        var script = document.createElement('script');
        script.src = url;
        script.crossOrigin = 'anonymous';
        script.onload = callback;
        (_a = document.head) === null || _a === void 0 ? void 0 : _a.appendChild(script);
    }
};
var getConfig = function (c, defaultConfig) {
    if (isObject(c)) {
        return __assign(__assign({}, defaultConfig), c);
    }
    else {
        return c ? defaultConfig : false;
    }
};

/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
var getStorageItem = function (name) {
    try {
        var value = localStorage.getItem(name);
        var ret = value;
        if (value && typeof value === 'string') {
            ret = JSON.parse(value);
        }
        return ret;
    }
    catch (_e) {
        return undefined;
    }
};
var setStorageItem = function (key, value) {
    try {
        var stringValue = typeof value === 'string' ? value : JSON.stringify(value);
        localStorage.setItem(key, stringValue);
    }
    catch (_o) {
        // do nothing
    }
};
var removeStorageItem = function (key) {
    try {
        localStorage.removeItem(key);
    }
    catch (_o) {
        // do nothing
    }
};

var XHR_SUBJECT_NAME = 'xhr_0';
var hookOpen = function (open) {
    return function () {
        var _a;
        var openOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            openOptions[_i] = arguments[_i];
        }
        _a = __read(openOptions, 2), this._method = _a[0], this._url = _a[1];
        return open.apply(this, openOptions);
    };
};
var hookSetHeader = function (setRequestHeader) {
    return function () {
        var setOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            setOptions[_i] = arguments[_i];
        }
        this._reqHeaders = this._reqHeaders || {};
        var _a = __read(setOptions, 2), name = _a[0], value = _a[1];
        this._reqHeaders[name] = value;
        return setRequestHeader && setRequestHeader.apply(this, setOptions);
    };
};
var hookOnreadystatechange = function (xhr, endNext) {
    return hookMethodDangerously(xhr, 'onreadystatechange', function (origin) {
        return function () {
            var ev = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                ev[_i] = arguments[_i];
            }
            // @ts-expect-error
            this.readyState === 4 && endNext(xhr);
            return origin && origin.apply(this, ev);
        };
    });
};
var hookSend = function (send, next) {
    return function () {
        var sendOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sendOptions[_i] = arguments[_i];
        }
        this._start = now();
        this._data = sendOptions === null || sendOptions === void 0 ? void 0 : sendOptions[0];
        var endNext = next([this._method, this._url, this._start, this]);
        hookOnreadystatechange(this, endNext)();
        return send.apply(this, sendOptions);
    };
};
var applyXHR = function (xhr) {
    return function (next, tearDown) {
        if (!xhr)
            return;
        var tearDownGroup = [];
        tearDownGroup.push(hookMethodDangerously(xhr, 'open', hookOpen)());
        tearDownGroup.push(hookMethodDangerously(xhr, 'setRequestHeader', hookSetHeader)());
        tearDownGroup.push(hookMethodDangerously(xhr, 'send', hookSend)(next));
        tearDown(function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
    };
};
var FETCH_SUBJECT_NAME = 'fetch_0';
var hookFetch = function (_fetch, next) {
    return function (req, options) {
        if (options === void 0) { options = {}; }
        var endNext = next([req, options]);
        var fetchPromise = _fetch(req, options);
        fetchPromise.then(function (res) {
            // @ts-expect-error
            endNext(res);
        }, function () {
            // @ts-expect-error
            endNext(undefined);
        });
        return fetchPromise;
    };
};
var observeFetch = function (next, tearDown) {
    var global = getDefaultBrowser();
    if (!global || !fetch)
        return;
    var tearDownGroup = [];
    tearDownGroup.push(hookMethodDangerously(global, 'fetch', hookFetch)(next));
    tearDown(function () {
        tearDownGroup.forEach(function (e) { return e(); });
    });
};
var fetchSubject = [FETCH_SUBJECT_NAME, observeFetch];

var RESOURCE_TYPE = ['resource']; // used by resourceMonitor / resourceErrorMonitor / HttpMonitor
var LONGTASK_TYPE = ['longtask']; // used by ttiMonitor / longtaskMonitor / actionMonitor / mpfidMonitor
var applyPerformanceObserver = function (PerformanceObserver, callback, onFail) {
    var observer = PerformanceObserver &&
        new PerformanceObserver(function (list, ob) {
            if (list.getEntries) {
                list.getEntries().forEach(function (val, i, arr) { return callback(val, i, arr, ob); });
            }
            else {
                onFail && onFail();
            }
        });
    var observe = function (types) {
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            observer.observe({ entryTypes: types });
        }
        catch (_a) {
            return onFail && onFail();
        }
    };
    var bufferedObserver = function (type) {
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            observer.observe({ type: type, buffered: true });
        }
        catch (_a) {
            return onFail && onFail();
        }
        observer.observe({ type: type, buffered: false });
    };
    var disconnect = function () { return observer && observer.disconnect(); };
    return [observe, bufferedObserver, disconnect];
};
var observePerf = function (Ob, pipe, types) {
    var _a = __read(applyPerformanceObserver(Ob, pipe), 3), observe = _a[0], disconnect = _a[2];
    observe(types);
    return disconnect;
};
var observePerfWithBuffer = function (Ob, pipe, type) {
    var _a = __read(applyPerformanceObserver(Ob, pipe), 3), bufferedObserver = _a[1], disconnect = _a[2];
    bufferedObserver(type);
    return disconnect;
};
var LONGTASK_SUBJECT_NAME = 'longtask_0';
var observeLongtask = function (next, tearDown) {
    var PerformanceObserver = getDefaultPerformanceObserver();
    if (!PerformanceObserver)
        return;
    tearDown(observePerf(PerformanceObserver, next, LONGTASK_TYPE));
};
var longtaskSubject = [LONGTASK_SUBJECT_NAME, observeLongtask];
var RESOURCE_SUBJECT_NAME = 'resource_0';
var observeResource = function (next, tearDown) {
    var PerformanceObserver = getDefaultPerformanceObserver();
    if (!PerformanceObserver)
        return;
    tearDown(observePerf(PerformanceObserver, next, RESOURCE_TYPE));
};
var resourceSubject = [RESOURCE_SUBJECT_NAME, observeResource];

var VERSION = '03';
var SAMPLED = '01';
var TRACEPARENT = 'traceparent';
var DEFAULT_TRACE_CONFIG = {
    sampleRate: 1,
    origins: [],
};
var uuid4 = function () {
    var crypto = window.crypto || window.msCrypto;
    if (crypto !== void 0 && crypto.getRandomValues) {
        var arr = new Uint16Array(8);
        crypto.getRandomValues(arr);
        var pad = function (num) {
            var v = num.toString(16);
            while (v.length < 4) {
                v = "0" + v;
            }
            return v;
        };
        return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
    }
    return 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'.replace(/[x]/g, function () {
        var r = (Math.random() * 16) | 0;
        return r.toString(16);
    });
};
var setTraceContext = function (traceConfig) {
    var config = getConfig(traceConfig, DEFAULT_TRACE_CONFIG);
    if (!config)
        return;
    var sampled = isHitBySampleRate(config.sampleRate);
    if (!sampled)
        return;
    return function (url, cb) {
        var origins = config.origins;
        if (origins.length && Boolean(url.match(new RegExp(origins.join('|'))))) {
            cb(TRACEPARENT, VERSION + "-" + uuid4() + "-" + uuid4().substring(16) + "-" + SAMPLED);
        }
    };
};
var setVolTraceContext = function (traceConfig, tracestate) {
    var config = getConfig(traceConfig, DEFAULT_TRACE_CONFIG);
    if (!config)
        return;
    var sampled = isHitBySampleRate(config.sampleRate);
    if (!sampled)
        return;
    return function (url, cb) {
        var origins = config.origins;
        if (origins.length && Boolean(url.match(new RegExp(origins.join('|'))))) {
            cb('x-rum-traceparent', "00-" + uuid4() + "-" + uuid4().substring(16) + "-" + SAMPLED);
            cb('x-rum-tracestate', tracestate);
        }
    };
};

var headerKeyRe = new RegExp('(cookie|auth|jwt|token|key|ticket|secret|credential|session|password)', 'i');
var headerValueRe = new RegExp('(bearer|session)', 'i');
var checkIsIgnored = function (ignoreUrls, url) {
    var ignoreRgx = getRegexp(ignoreUrls || []);
    return !!ignoreRgx && ignoreRgx.test(url);
};
var isSensitiveHeader = function (key, value) {
    if (!key || !value)
        return false;
    return headerKeyRe.test(key) || headerValueRe.test(value);
};
var applySendOnce = function (cb) {
    var hasInvoked = false;
    return function (metric) {
        if (hasInvoked)
            return;
        hasInvoked = true;
        cb(metric);
    };
};

var httpGetterWithXhrObserver = function (report, tearDownGroup, _a, xhrConfig) {
    var _b = __read(_a, 2), xhrObserver = _b[0], getResourceObserver = _b[1];
    var setTraceHeader = xhrConfig.setTraceHeader, ignoreUrls = xhrConfig.ignoreUrls, hookCbAtReq = xhrConfig.hookCbAtReq;
    tearDownGroup.push(xhrObserver[0](function (_a) {
        var _b = __read(_a, 4); _b[0]; var _url = _b[1]; _b[2]; var xhr = _b[3];
        if (checkIsIgnored(ignoreUrls, _url))
            return noop;
        setTraceHeader && setTraceHeader(_url, function (key, value) { return xhr.setRequestHeader(key, value); });
        var reportWithContext = hookCbAtReq(report);
        var fullUrl = getFullUrl(_url);
        var timing = undefined;
        var resourceTearDown = getResourceObserver()[0](function (entry) {
            fullUrl === entry.name && !timing && (timing = entry);
        });
        return function (xhrAfterReady) {
            var payload = getEventParams$1(xhrAfterReady, xhrConfig);
            setTimeout(function () {
                timing && (payload.response.timing = timing);
                reportWithContext && reportWithContext({ ev_type: 'http', payload: payload });
                resourceTearDown();
            }, 100);
        };
    }));
};
function formatXHRAllResponseHeaders(headers) {
    if (isString(headers) && headers) {
        return headers.split('\r\n').reduce(function (result, line) {
            if (isString(line)) {
                var _a = __read(line.split(': '), 2), name_1 = _a[0], value = _a[1];
                !isSensitiveHeader(name_1, value) && (result[name_1.toLowerCase()] = value);
            }
            return result;
        }, {});
    }
    return {};
}
function formatRequestHeaders(headers) {
    return Object.keys(headers).reduce(function (result, name) {
        !isSensitiveHeader(name, headers[name]) && (result[name.toLowerCase()] = headers[name]);
        return result;
    }, {});
}
var getEventParams$1 = function (xhr, props) {
    var _method = xhr._method, _reqHeaders = xhr._reqHeaders, _url = xhr._url, _start = xhr._start, _data = xhr._data;
    var fullUrl = getFullUrl(_url);
    var params = {
        api: 'xhr',
        request: {
            url: fullUrl,
            method: (_method || '').toLowerCase(),
            headers: _reqHeaders && formatRequestHeaders(_reqHeaders),
            timestamp: _start,
        },
        response: {
            status: xhr.status || 0,
            is_custom_error: false,
            timestamp: now(),
        },
        duration: now() - _start,
    };
    if (typeof xhr.getAllResponseHeaders === 'function') {
        params.response.headers = formatXHRAllResponseHeaders(xhr.getAllResponseHeaders());
    }
    var status = params.response.status;
    var collectBodyOnError = props.collectBodyOnError, extraExtractor = props.extraExtractor;
    try {
        var extra = extraExtractor === null || extraExtractor === void 0 ? void 0 : extraExtractor(xhr.response, params);
        extra && (params.extra = extra);
        extra && (params.response.is_custom_error = true);
        // 非 2xx , 3xx 请求，上传request body
        if (collectBodyOnError && status >= 400) {
            params.request.body = _data ? "" + _data : undefined;
            params.response.body = xhr.response ? "" + xhr.response : undefined;
        }
    }
    catch (_o) {
        // do nothing
    }
    return params;
};

function getPluginConfig(client, pluginName, defaultConfig) {
    var _a;
    var c = (_a = client.config()) === null || _a === void 0 ? void 0 : _a.plugins[pluginName];
    return getConfig(c, defaultConfig);
}
var reportOnInitCommonParams = function (client, overrides) {
    var clientConfig = client.config();
    var common = {
        url: getLocationUrl(),
        pid: clientConfig.pid,
        view_id: clientConfig.viewId,
    };
    return function (ev) {
        client.report(__assign(__assign({}, ev), { overrides: __assign(__assign({}, common), ((overrides && overrides(ev)) || {})) }));
    };
};

var AJAX_MONITOR_PLUGIN_NAME = 'ajax';
var defaultConfig$8 = {
    autoWrap: true,
    hookCbAtReq: id,
    ignoreUrls: [],
    collectBodyOnError: false,
};
var getCbHook = function (client) { return function (cb) {
    var _a;
    if (!cb)
        return cb;
    var clientConfig = client.config();
    var common = {
        url: getLocationUrl(),
        pid: clientConfig.pid,
        view_id: clientConfig.viewId,
        context: (_a = client.context) === null || _a === void 0 ? void 0 : _a.toString(),
    };
    return function (ev) {
        cb(__assign(__assign({}, ev), { overrides: __assign(__assign({}, common), { timestamp: ev.payload.request.timestamp }) }));
    };
}; };
function AjaxMonitorPlugin(client) {
    client.on('init', function () {
        var config = getPluginConfig(client, AJAX_MONITOR_PLUGIN_NAME, defaultConfig$8);
        if (!config) {
            return;
        }
        var tearDownGroup = [];
        var xhrConfig = __assign(__assign({}, config), { hookCbAtReq: getCbHook(client), setTraceHeader: setTraceContext(config.trace) });
        var getResourceSubject = function () { return initSubjectInGlobal(client, resourceSubject); };
        xhrConfig.autoWrap &&
            httpGetterWithXhrObserver(client.report.bind(client), tearDownGroup, [
                initSubjectInGlobal(client, [XHR_SUBJECT_NAME, applyXHR(XMLHttpRequest && XMLHttpRequest.prototype)]),
                getResourceSubject,
            ], xhrConfig);
        client.on('beforeDestroy', function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
        client.provide('wrapXhr', function (Xhr) {
            function Ctor() {
                var xhr = new Xhr();
                httpGetterWithXhrObserver(client.report.bind(client), tearDownGroup, [createSafeObserver(applyXHR(xhr)), getResourceSubject], xhrConfig);
                return xhr;
            }
            Ctor.prototype = new Xhr();
            ['DONE', 'HEADERS_RECIEVED', 'LOADING', 'OPENED', 'UNSENT'].forEach(function (key) {
                Ctor[key] = Xhr[key];
            });
            return Ctor;
        });
    });
}
function AjaxMonitorVolPlugin(client) {
    client.on('init', function () {
        var _a;
        var config = getPluginConfig(client, AJAX_MONITOR_PLUGIN_NAME, defaultConfig$8);
        if (!config) {
            return;
        }
        var tearDownGroup = [];
        var xhrConfig = __assign(__assign({}, config), { hookCbAtReq: getCbHook(client), setTraceHeader: setVolTraceContext(config.trace, "app_id=" + ((_a = client.config()) === null || _a === void 0 ? void 0 : _a.aid) + ",origin=web") });
        var getResourceSubject = function () { return initSubjectInGlobal(client, resourceSubject); };
        xhrConfig.autoWrap &&
            httpGetterWithXhrObserver(client.report.bind(client), tearDownGroup, [
                initSubjectInGlobal(client, [XHR_SUBJECT_NAME, applyXHR(XMLHttpRequest && XMLHttpRequest.prototype)]),
                getResourceSubject,
            ], xhrConfig);
        client.on('beforeDestroy', function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
    });
}

var applyBreadcrumb = function (maxBreadcrumbs, onAddBreadcrumb, onMaxBreadcrumbs) {
    if (maxBreadcrumbs === void 0) { maxBreadcrumbs = 20; }
    if (onAddBreadcrumb === void 0) { onAddBreadcrumb = id; }
    if (onMaxBreadcrumbs === void 0) { onMaxBreadcrumbs = function (bs, max) { return bs.slice(-max); }; }
    var breadcrumbs = [];
    var addBreadcrumb = function (breadcrumb) {
        var processed = onAddBreadcrumb(breadcrumb);
        if (processed) {
            var mergedBreadcrumb = __assign(__assign({}, breadcrumb), { timestamp: breadcrumb.timestamp || now() });
            breadcrumbs =
                maxBreadcrumbs >= 0 && breadcrumbs.length + 1 > maxBreadcrumbs
                    ? onMaxBreadcrumbs(__spreadArray(__spreadArray([], __read(breadcrumbs), false), [mergedBreadcrumb], false), maxBreadcrumbs)
                    : __spreadArray(__spreadArray([], __read(breadcrumbs), false), [mergedBreadcrumb], false);
        }
    };
    return [function () { return breadcrumbs; }, addBreadcrumb];
};

var BreadcrumbMonitor = function (document) {
    if (document === void 0) { document = getDefaultDocument(); }
    if (!document) {
        return;
    }
    return function (props, _cb) {
        var maxBreadcrumbs = props.maxBreadcrumbs, onAddBreadcrumb = props.onAddBreadcrumb, onMaxBreadcrumbs = props.onMaxBreadcrumbs, dom = props.dom;
        var _a = __read(applyDomAndKeyPress(100), 2), domEventHandler = _a[0], keypressHandler = _a[1];
        var _b = __read(applyBreadcrumb(maxBreadcrumbs, onAddBreadcrumb, onMaxBreadcrumbs), 2), getBreadcrumbs = _b[0], addBreadcrumb = _b[1];
        var createDomBreadcrumb = domBreadcrumb(addBreadcrumb);
        var handlers = [];
        if (dom) {
            handlers.push(domEventHandler('click', triggerHandlers(createDomBreadcrumb, 'dom')));
            handlers.push(keypressHandler(triggerHandlers(createDomBreadcrumb, 'dom')));
            document.addEventListener('click', handlers[0]);
            document.addEventListener('keypress', handlers[1]);
        }
        var teardown = function () {
            document.removeEventListener('click', handlers[0]);
            document.removeEventListener('keypress', handlers[1]);
        };
        return [getBreadcrumbs, addBreadcrumb, teardown];
    };
};

var BREADCRUMB_MONITOR_PLUGIN_NAME = 'breadcrumb';
var defaultConfig$7 = {
    maxBreadcrumbs: 20,
    dom: true,
};
function BreadcrumbMonitorPlugin(client) {
    client.on('init', function () {
        var config = getPluginConfig(client, BREADCRUMB_MONITOR_PLUGIN_NAME, defaultConfig$7);
        if (!config) {
            return;
        }
        var _a = __read(applyMonitor(BreadcrumbMonitor, config, noop), 3), getBreadcrumbs = _a[0], addBreadcrumb = _a[1], tearDown = _a[2];
        client.on('report', function (ev) {
            if (ev.ev_type === 'http') {
                addBreadcrumb({
                    type: 'http',
                    category: ev.payload.api,
                    message: '',
                    data: {
                        method: ev.payload.request.method,
                        url: ev.payload.request.url,
                        status_code: String(ev.payload.response.status),
                    },
                    timestamp: ev.payload.request.timestamp,
                });
            }
            return ev;
        });
        client.on('beforeDestroy', tearDown);
        client.provide('getBreadcrumbs', getBreadcrumbs);
        client.provide('addBreadcrumb', addBreadcrumb);
    });
}

var httpGetterWithFetchObserver = function (report, tearDownGroup, _a, fetchConfig) {
    var _b = __read(_a, 2), fetchObserver = _b[0], getResourceObserver = _b[1];
    var setTraceHeader = fetchConfig.setTraceHeader, ignoreUrls = fetchConfig.ignoreUrls, hookCbAtReq = fetchConfig.hookCbAtReq;
    // eslint-disable-next-line compat/compat
    var Headers = window.Headers;
    // eslint-disable-next-line compat/compat
    var Request = window.Request;
    if (!Request || !Headers)
        return;
    tearDownGroup.push(fetchObserver[0](function (_a) {
        var _b = __read(_a, 2), req = _b[0], options = _b[1];
        var url = getFullUrl(req instanceof Request ? req.url : req);
        if (!isHttpURL(url) || checkIsIgnored(ignoreUrls, url)) {
            return noop;
        }
        setTraceHeader &&
            setTraceHeader(url, function (key, value) { return addHeader(key, value, req, options, Request, Headers); });
        var reportWithContext = hookCbAtReq(report);
        var _start = now();
        var timing = undefined;
        var resourceTearDown = getResourceObserver()[0](function (entry) {
            url === entry.name && !timing && (timing = entry);
        });
        return function (res) {
            var payload = getEventParams(req, options, res, Request, Headers, fetchConfig, _start);
            var reportFetchData = applySendOnce(function (data) {
                timing && (data.response.timing = timing);
                reportWithContext && reportWithContext({ ev_type: 'http', payload: data });
                resourceTearDown();
            });
            setTimeout(function () {
                reportFetchData(payload);
            }, 1000);
        };
    }));
};
var isHttpURL = function (url) {
    if (!isString(url)) {
        return false;
    }
    var _a = __read(url.split(':'), 2), protocol = _a[0], path = _a[1];
    return !path || protocol === 'http' || protocol === 'https';
};
var isRequest = function (req, Request) {
    return req instanceof Request;
};
var addHeader = function (key, value, req, options, Request, Headers) {
    var _a;
    if (isRequest(req, Request)) {
        req.headers.set(key, value);
    }
    else if (options.headers instanceof Headers) {
        options.headers.set(key, value);
    }
    else {
        options.headers = __assign(__assign({}, options.headers), (_a = {}, _a[key] = value, _a));
    }
};
var getFetchMethod = function (req, options, Request) {
    var method = (options && options.method) || 'get';
    if (isRequest(req, Request)) {
        method = req.method || method;
    }
    return method.toLowerCase();
};
var mergeHeaders = function (Headers) {
    var headers = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        headers[_i - 1] = arguments[_i];
    }
    try {
        return headers.reduce(function (sum, cur) {
            // eslint-disable-next-line compat/compat
            new Headers(cur || {}).forEach(function (val, key) { return !isSensitiveHeader(key, val) && (sum[key] = val); });
            return sum;
        }, {});
    }
    catch (_a) {
        return {};
    }
};
var getFetchBody = function (req, options, Request) {
    if (isRequest(req, Request)) {
        return req.body;
    }
    else {
        return options === null || options === void 0 ? void 0 : options.body;
    }
};
var getEventParams = function (req, options, res, Request, Headers, props, _start) {
    var _a, _b;
    var params = {
        api: 'fetch',
        request: {
            method: getFetchMethod(req, options, Request),
            timestamp: _start,
            url: getFullUrl(req instanceof Request ? req.url : req),
            headers: mergeHeaders(Headers, req.headers, options.headers),
        },
        response: {
            status: (res && res.status) || 0,
            is_custom_error: false,
            timestamp: now(),
        },
        duration: now() - _start,
    };
    var collectBodyOnError = props.collectBodyOnError, extraExtractor = props.extraExtractor;
    if (res) {
        try {
            params.response.headers = mergeHeaders(Headers, res.headers);
            try {
                extraExtractor &&
                    res
                        .clone()
                        .json()
                        .then(function (o) {
                        var extra = extraExtractor(o, params);
                        if (extra) {
                            params.extra = extra;
                            params.response.is_custom_error = true;
                        }
                    })
                        .catch(noop);
            }
            catch (_o) {
                // do nothing
            }
            if (collectBodyOnError && res.status >= 400) {
                params.request.body = (_a = getFetchBody(req, options, Request)) === null || _a === void 0 ? void 0 : _a.toString();
            }
        }
        catch (_c) {
            // do nothing
        }
    }
    else {
        collectBodyOnError && (params.request.body = (_b = getFetchBody(req, options, Request)) === null || _b === void 0 ? void 0 : _b.toString());
    }
    return params;
};

var FETCH_MONITOR_PLUGIN_NAME = 'fetch';
var defaultConfig$6 = {
    autoWrap: true,
    hookCbAtReq: id,
    ignoreUrls: [],
    collectBodyOnError: false,
};
function FetchMonitorPlugin(client) {
    client.on('init', function () {
        var config = getPluginConfig(client, FETCH_MONITOR_PLUGIN_NAME, defaultConfig$6);
        if (!config) {
            return;
        }
        var tearDownGroup = [];
        var fetchConfig = __assign(__assign({}, config), { hookCbAtReq: getCbHook(client), setTraceHeader: setTraceContext(config.trace) });
        var getResourceObserver = function () { return initSubjectInGlobal(client, resourceSubject); };
        fetchConfig.autoWrap &&
            httpGetterWithFetchObserver(client.report.bind(client), tearDownGroup, [initSubjectInGlobal(client, fetchSubject), getResourceObserver], fetchConfig);
        client.on('beforeDestroy', function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
        client.provide('wrapFetch', function (f) {
            var newFetch = undefined;
            httpGetterWithFetchObserver(client.report.bind(client), tearDownGroup, [
                createSafeObserver(function (next) {
                    newFetch = hookFetch(f, next);
                }),
                getResourceObserver,
            ], fetchConfig);
            return newFetch;
        });
    });
}
function FetchMonitorVolPlugin(client) {
    client.on('init', function () {
        var _a;
        var config = getPluginConfig(client, FETCH_MONITOR_PLUGIN_NAME, defaultConfig$6);
        if (!config) {
            return;
        }
        var tearDownGroup = [];
        var fetchConfig = __assign(__assign({}, config), { hookCbAtReq: getCbHook(client), setTraceHeader: setVolTraceContext(config.trace, "app_id=" + ((_a = client.config()) === null || _a === void 0 ? void 0 : _a.aid) + ",origin=web") });
        fetchConfig.autoWrap &&
            httpGetterWithFetchObserver(client.report.bind(client), tearDownGroup, [initSubjectInGlobal(client, fetchSubject), function () { return initSubjectInGlobal(client, resourceSubject); }], fetchConfig);
        client.on('beforeDestroy', function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
    });
}

var ERROR_SUBJECT_NAME = 'err_0';
var observeError = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    window.addEventListener('error', next, true);
    tearDown(function () {
        window.removeEventListener('error', next, true);
    });
};
var errorSubject = [ERROR_SUBJECT_NAME, observeError];
var PROMISE_REJECTION_SUBJECT_NAME = 'perr_0';
var observePromiseRejection = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    window.addEventListener('unhandledrejection', next, true);
    tearDown(function () {
        window.removeEventListener('unhandledrejection', next, true);
    });
};
var promiseRejectionSubject = [
    PROMISE_REJECTION_SUBJECT_NAME,
    observePromiseRejection,
];

var ERROR_FIELDS = ['name', 'message', 'stack', 'filename', 'lineno', 'colno'];
var normalize = function (ex) {
    var error;
    if (!isError(ex)) {
        if (isPlainObject(ex) || isEvent(ex) || isString(ex)) {
            error = {
                message: safeStringify(ex),
            };
        }
    }
    else {
        error = pick(ex, ERROR_FIELDS);
    }
    return error;
};
var normalizeError = function (event) {
    return normalize(event.error);
};
var normalizeException = function (event) {
    var _a;
    // dig the object of the rejection out of known event types
    try {
        var error = void 0;
        // PromiseRejectionEvents store the object of the rejection under 'reason'
        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent
        if ('reason' in event) {
            error = event.reason;
        }
        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents
        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into
        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec
        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and
        // https://github.com/getsentry/sentry-javascript/issues/2380
        else if ('detail' in event && 'reason' in event.detail) {
            error = event.detail.reason;
        }
        if (error) {
            var rejectionError = normalize(error);
            // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
            return __assign(__assign({}, rejectionError), { name: (_a = (rejectionError && rejectionError.name)) !== null && _a !== void 0 ? _a : 'UnhandledRejection' });
        }
    }
    catch (_oO) {
        // no-empty
    }
};
var normalizeUnknownError = function (exception) {
    if (isErrorEvent(exception)) {
        return normalizeError(exception);
    }
    else if (isPromiseRejectionEvent(exception)) {
        return normalizeException(exception);
    }
    else {
        return normalize(exception);
    }
};

var DEFAULT_EVENT_TARGET = [
    'EventTarget',
    'Window',
    'Node',
    'ApplicationCache',
    'ChannelMergerNode',
    'EventSource',
    'FileReader',
    'HTMLUnknownElement',
    'IDBDatabase',
    'IDBRequest',
    'IDBTransaction',
    'MessagePort',
    'Notification',
    'SVGElementInstance',
    'Screen',
    'TextTrack',
    'TextTrackCue',
    'TextTrackList',
    'WebSocket',
    'Worker',
    'XMLHttpRequest',
    'XMLHttpRequestEventTarget',
    'XMLHttpRequestUpload',
];
var DEFAULT_TIME_FUNCTION = [
    'setTimeout',
    'setInterval',
    'requestAnimationFrame',
    'requestIdleCallback',
];
var xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];
var ADD_EVENT_LISTENER = 'addEventListener';
var REMOVE_EVENT_LISTENER = 'removeEventListener';
var DEFAULT_SOURCE_TYPE = 'capture-global';
var hookGlobalAsync = function (report, window, xhr) {
    if (window === void 0) { window = getDefaultBrowser(); }
    if (xhr === void 0) { xhr = getDefaultXMLHttpRequest(); }
    var restoreFns = [];
    var wrap = function (fn, sourceData) {
        if (!isFunction(fn))
            return fn;
        var source = {
            type: DEFAULT_SOURCE_TYPE,
            data: __assign({}, sourceData),
        };
        var hookFn = (fn._w_ || (fn._w_ = function () {
            try {
                // NOTE: If you are a Slardar user, and you are seeing this stack frame, it
                //       means the Slardar SDK caught an error invoking your application code. This
                //       is expected behavior and NOT indicative of a bug with Slardar SDK.
                return (fn.handleEvent && isFunction(fn.handleEvent) ? fn.handleEvent : fn).apply(this, [].map.call(arguments, function (arg) { return wrap(arg, sourceData); }));
            }
            catch (e) {
                var error = normalize(e);
                error && report({ error: error, source: source });
                throw e;
            }
        }));
        hookFn._hook_ = true;
        return hookFn;
    };
    window && restoreFns.push.apply(restoreFns, __spreadArray([], __read(DEFAULT_TIME_FUNCTION.filter(function (timeFunc) { return window[timeFunc]; }).map(function (timeFunc) {
        return hookObjectProperty(window, timeFunc, function (origin) {
            return function (handler) {
                var params = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    params[_i - 1] = arguments[_i];
                }
                return (origin && origin.call.apply(origin, __spreadArray([this,
                    wrap(handler, {
                        function: timeFunc,
                    })], __read(params), false)));
            };
        }, false)();
    })), false));
    xhr &&
        xhr.prototype &&
        restoreFns.push(hookObjectProperty(xhr.prototype, 'send', function (origin) {
            return function () {
                var _this = this;
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i] = arguments[_i];
                }
                // filter 防御一个 xhr 实例被多次 send 导致 wrap 多次的情况
                xmlHttpRequestProps
                    .filter(function (prop) { return _this[prop] && !_this[prop]._hook_; })
                    .forEach(function (prop) {
                    // never restore xhr instance callback
                    _this[prop] = wrap(_this[prop], { function: prop });
                });
                return origin.apply(this, params);
            };
        }, false)());
    DEFAULT_EVENT_TARGET.forEach(function (target) {
        var proto = window[target] && window[target].prototype;
        if (!proto || !proto[ADD_EVENT_LISTENER]) {
            return;
        }
        restoreFns.push(hookObjectProperty(proto, ADD_EVENT_LISTENER, function (origin) {
            return function (evName, fn, options) {
                try {
                    var handleEventFn = fn.handleEvent;
                    if (isFunction(handleEventFn)) {
                        fn.handleEvent = wrap(handleEventFn, { function: 'handleEvent', target: target });
                    }
                }
                catch (_a) {
                    //
                }
                return origin && origin.call(this, evName, wrap(fn, { function: ADD_EVENT_LISTENER, target: target }), options);
            };
        }, false)());
        restoreFns.push(hookObjectProperty(proto, REMOVE_EVENT_LISTENER, function (origin) {
            return function (eventName, fn, options) {
                if (fn === null || fn === void 0 ? void 0 : fn._w_) {
                    origin.call(this, eventName, fn._w_, options);
                }
                return origin.call(this, eventName, fn, options);
            };
        }, false)());
    });
    return restoreFns;
};

var isSameErrorString = function (current, previous) {
    return current && previous && current === previous;
};
var shouldDropEvent = function (currentError, previousError) {
    if (!currentError || !previousError) {
        return false;
    }
    if (isSameErrorString(currentError.message, previousError.message) &&
        isSameErrorString(currentError.stack, previousError.stack)) {
        return true;
    }
    return false;
};
var dedupe = function () {
    var __previousError;
    return function (currentError) {
        // just in case something goes wrong
        try {
            if (shouldDropEvent(currentError, __previousError)) {
                __previousError = currentError;
                return undefined;
            }
        }
        catch (e) {
            reportSelfError(e);
        }
        __previousError = currentError;
        return currentError;
    };
};

var JS_ERROR_EV_TYPE$1 = 'js_error';
var jsErrorGetterWithContext = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 2), errorObserver = _b[0], promiseRejectionObserver = _b[1];
    var ignoreErrors = config.ignoreErrors, onerror = config.onerror, onunhandledrejection = config.onunhandledrejection, dedupeFlag = config.dedupe, captureGlobalAsync = config.captureGlobalAsync;
    var ignoreRegExp = getRegexp(ignoreErrors);
    var dedupeFn = dedupe();
    var reportJsError = function (_a) {
        var error = _a.error, extra = _a.extra, react = _a.react, source = _a.source;
        var err = dedupeFlag ? dedupeFn(error) : error;
        if (!err || (ignoreRegExp && ignoreRegExp.test(err.message))) {
            return;
        }
        report({
            ev_type: JS_ERROR_EV_TYPE$1,
            payload: {
                error: err,
                breadcrumbs: [],
                extra: extra,
                react: react,
                source: source,
            },
        });
    };
    onerror &&
        tearDownGroup.push(errorObserver[0](function (ev) { return reportJsError({ error: normalizeError(ev), source: { type: 'onerror' } }); }));
    onunhandledrejection &&
        tearDownGroup.push(promiseRejectionObserver[0](function (ev) {
            return reportJsError({ error: normalizeException(ev), source: { type: 'onunhandledrejection' } });
        }));
    captureGlobalAsync && tearDownGroup.push.apply(tearDownGroup, __spreadArray([], __read(hookGlobalAsync(reportJsError)), false));
    return function (err, extra, react) {
        return reportJsError({ error: normalizeUnknownError(err), extra: extra, react: react, source: { type: 'manual' } });
    };
};

var JS_ERROR_MONITOR_PLUGIN_NAME = 'jsError';
var defaultConfig$5 = {
    ignoreErrors: [],
    onerror: true,
    onunhandledrejection: true,
    captureGlobalAsync: false,
    dedupe: true,
};
function JsErrorMonitorPlugin(client) {
    client.on('init', function () {
        // stop precollect listener no matter what is configured
        window.removeEventListener('error', client.pcErr, true);
        window.removeEventListener('unhandledrejection', client.pcRej, true);
        var config = getPluginConfig(client, JS_ERROR_MONITOR_PLUGIN_NAME, defaultConfig$5);
        if (!config) {
            return;
        }
        var tearDownGroup = [];
        var reportJsError = jsErrorGetterWithContext(function (ev) {
            client.getBreadcrumbs && (ev.payload.breadcrumbs = client.getBreadcrumbs());
            client.report(ev);
        }, tearDownGroup, [initSubjectInGlobal(client, errorSubject), initSubjectInGlobal(client, promiseRejectionSubject)], config);
        client.on('beforeDestroy', function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
        client.provide('captureException', reportJsError);
    });
}

var getOverrides = function (config) {
    return {
        pid: config.pid,
        view_id: config.viewId,
        url: getLocationUrl(),
    };
};
var PV_SUBJECT_NAME = 'view_0';
/**
 * 由于跟当前实例强相关 所以不能挂在global上
 */
var applyPV = function (client) {
    return function (next, tearDown) {
        var currentOverrides = getOverrides(client.config());
        var handleConfig = function (newConfig) {
            var _a;
            if (newConfig.viewId && newConfig.viewId !== ((_a = client.config()) === null || _a === void 0 ? void 0 : _a.viewId)) {
                next(currentOverrides);
                currentOverrides = getOverrides(newConfig);
            }
        };
        client.on('beforeConfig', handleConfig);
        tearDown(function () {
            client.off('beforeConfig', handleConfig);
        });
    };
};
var FIRST_PV_SUBJECT_NAME = 'f_view_0';
/**
 * 由于跟当前实例强相关 所以不能挂在global上
 */
var applyFirstPV = function (client) {
    return function (_, tearDown) {
        var firstOverrides = getOverrides(client.config());
        tearDown(noop, function (subscriber) {
            firstOverrides && subscriber(firstOverrides);
        });
    };
};

var HISTORY_SUBJECT_NAME = 'history_0';
var HASH_SUBJECT_NAME = 'hash_0';
var observeHistory = function (next, tearDown) {
    var history = getDefaultHistory();
    if (!history)
        return;
    var restoreFns = [];
    var historyChangeListener = function () { return next(location.href); };
    var hookStateChange = function (origin) {
        return function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            try {
                origin.apply(history, params);
            }
            finally {
                historyChangeListener();
            }
        };
    };
    restoreFns.push(hookObjectProperty(history, 'pushState', hookStateChange)(), hookObjectProperty(history, 'replaceState', hookStateChange)());
    window.addEventListener('popstate', historyChangeListener, true);
    restoreFns.push(function () { return window.removeEventListener('popstate', historyChangeListener, true); });
    tearDown(function () {
        restoreFns.forEach(function (fn) { return fn(); });
    });
};
var observeHash = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    var hashChangeListener = function () { return next(location.href); };
    window.addEventListener('hashchange', hashChangeListener, true);
    tearDown(function () { return window.removeEventListener('hashchange', hashChangeListener, true); });
};
var hashSubject = [HASH_SUBJECT_NAME, observeHash];
var historySubject = [HISTORY_SUBJECT_NAME, observeHistory];

var getDefaultExtractor = function (routeMode) { return function (url) {
    var _a;
    if (routeMode === 'hash') {
        return ((_a = parseUrl(url).hash) === null || _a === void 0 ? void 0 : _a.replace(/^#/, '')) || '/';
    }
    else {
        return parseUrl(url).path;
    }
}; };
var applyOnPidChange = function (cb, initPid, firstOriginPid, onPidUpdate) {
    // store originalPid from url
    var originalPid = firstOriginPid;
    // store finalPid send to server
    var finalPid = initPid;
    // set init pid in config
    onPidUpdate && onPidUpdate(initPid);
    var onPidChange = function (source, newPid, customPid) {
        // newPid is extractPid from url, should send pageview if changed, no matter customPid changed
        if (source !== "user_set" /* user_set */ && newPid !== originalPid) {
            originalPid = newPid;
            finalPid = customPid !== null && customPid !== void 0 ? customPid : originalPid;
            onPidUpdate && onPidUpdate(finalPid); // update pid in common
            cb(source, finalPid);
            // newPid is by user set, should send pageview if not equal to finalPid
        }
        else if (source === "user_set" /* user_set */ && newPid !== finalPid) {
            finalPid = newPid;
            onPidUpdate && onPidUpdate(finalPid); // update pid in common
            cb(source, finalPid);
        }
    };
    var sendInit = function () {
        initPid && cb("init" /* init */, initPid);
    };
    return [onPidChange, sendInit];
};
var applyOnUrlChange = function (cb, initUrl) {
    var url = initUrl;
    var onUrlChange = function (source, newUrl) {
        if (newUrl !== url) {
            url = newUrl;
            cb(source, url);
        }
    };
    return [onUrlChange];
};
var wrapPageview = function (source, pid) { return ({
    ev_type: 'pageview',
    payload: {
        pid: pid,
        source: source,
    },
}); };
var applyReportPageview = function (report) {
    return function (source, pid) {
        report(wrapPageview(source, pid));
    };
};
var isManualMode = function (routeMode) { return routeMode === 'manual'; };

var pvGetterWithRouteObserver = function (report, tearDownGroup, routeObservers, config) {
    var sendInitFlag = config.sendInit, initPid = config.initPid, routeMode = config.routeMode, extractPid = config.extractPid, onPidUpdate = config.onPidUpdate;
    var extractPidFromUrl = isManualMode(routeMode) ? function () { return ''; } : getDefaultExtractor(routeMode);
    var customPidFromUrl = extractPid || (function () { return undefined; });
    var getFinalPid = function (url) { var _a; return (_a = customPidFromUrl(url)) !== null && _a !== void 0 ? _a : extractPidFromUrl(url); };
    var _a = __read(applyOnPidChange(applyReportPageview(report), initPid || getFinalPid(location.href), extractPidFromUrl(location.href), onPidUpdate), 2), onPidChange = _a[0], sendInit = _a[1];
    if (!isManualMode(routeMode)) {
        var _b = __read(applyOnUrlChange(function (sources, url) { return onPidChange(sources, extractPidFromUrl(url), customPidFromUrl(url)); }, ''), 1), onUrlChange_1 = _b[0];
        routeObservers.length &&
            routeObservers.forEach(function (routeObserver) {
                return tearDownGroup.push(routeObserver[0](function (value) { return onUrlChange_1(routeMode, value); }));
            });
    }
    if (sendInitFlag) {
        sendInit();
    }
    return [onPidChange.bind(null, "user_set" /* user_set */)];
};

var PAGEVIEW_MONITOR_PLUGIN_NAME = 'pageview';
var defaultConfig$4 = {
    sendInit: true,
    routeMode: 'history',
};
function PageviewMonitorPlugin(client) {
    client.on('init', function () {
        var _a;
        var config = getPluginConfig(client, PAGEVIEW_MONITOR_PLUGIN_NAME, defaultConfig$4);
        if (!config || !location) {
            return;
        }
        var tearDownGroup = [];
        var routeMode = config.routeMode;
        var _b = __read(pvGetterWithRouteObserver(client.report.bind(client), tearDownGroup, isManualMode(routeMode) ? [] : [client.initSubject(hashSubject), client.initSubject(historySubject)], __assign(__assign({}, config), { initPid: (_a = client.config()) === null || _a === void 0 ? void 0 : _a.pid, onPidUpdate: function (pid) {
                client.set({ pid: pid, viewId: pid + "_" + now(), actionId: undefined });
            } })), 1), sendPageview = _b[0];
        initPrivateSubject(client, [FIRST_PV_SUBJECT_NAME, applyFirstPV(client)], -1);
        client.on('config', function () {
            sendPageview(client.config().pid);
        });
        client.on('beforeDestroy', function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
        client.provide('sendPageview', sendPageview);
    });
}

var HIDDEN_SUBJECT_NAME = 'hidden_0';
var observeHidden = function (next, tearDown) {
    var window = getDefaultBrowser();
    var document = getDefaultDocument();
    if (!window || !document)
        return;
    var onVisibilityChange = function () {
        if (document.visibilityState === 'hidden') {
            next();
        }
    };
    addEventListener('visibilitychange', onVisibilityChange, true);
    var requestIdleCallback = applyRequestIdleCallback(window);
    tearDown(function () {
        removeEventListener('visibilitychange', onVisibilityChange, true);
    }, function (subscriber) {
        if (document.visibilityState === 'hidden') {
            requestIdleCallback(function () {
                subscriber();
            });
        }
    });
};
var hiddenSubject = [HIDDEN_SUBJECT_NAME, observeHidden];
var LOAD_SUBJECT_NAME = 'load_0';
var observeLoad = function (next, tearDown) {
    var window = getDefaultBrowser();
    var document = getDefaultDocument();
    if (!window || !document)
        return;
    var onLoad = function () {
        setTimeout(function () {
            next();
        }, 0);
    };
    window.addEventListener('load', onLoad, false);
    var requestIdleCallback = applyRequestIdleCallback(window);
    tearDown(function () {
        window.removeEventListener('load', onLoad, false);
    }, function (subscriber) {
        if (document.readyState === 'complete') {
            requestIdleCallback(function () {
                subscriber();
            });
        }
    });
};
var loadSubject = [LOAD_SUBJECT_NAME, observeLoad];
var UNLOAD_SUBJECT_NAME = 'unload_0';
var observeUnload = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    var _a = __read(invokeCallbackOnce(next), 1), invokeCbOnce = _a[0];
    var unloadEventList = ['unload', 'beforeunload', 'pagehide'];
    var handler = function () {
        invokeCbOnce();
    };
    unloadEventList.forEach(function (ev) {
        window.addEventListener(ev, handler);
    });
    tearDown(function () {
        unloadEventList.forEach(function (ev) {
            window.removeEventListener(ev, handler);
        });
    });
};
var unloadSubject = [UNLOAD_SUBJECT_NAME, observeUnload];

var RESOURCE_EV_TYPE$1 = 'resource';
var RESOURCE_PERFORMANCE_ENTRY_TYPE = 'resource';
var RESOURCE_IGNORE_TYPES = ['xmlhttprequest', 'fetch', 'beacon'];
var resourceGetterWithContext = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 2), loadObserver = _b[0], getResourceObserver = _b[1];
    var performance = getDefaultPerformance();
    if (!performance)
        return;
    var ignoreUrls = config.ignoreUrls, slowSessionThreshold = config.slowSessionThreshold, ignoreTypes = config.ignoreTypes;
    var ignoreRegExp = getRegexp(ignoreUrls);
    var reportResource = function (entry, isSlowSession) {
        if (isSlowSession === void 0) { isSlowSession = false; }
        if (arrayIncludes(ignoreTypes || RESOURCE_IGNORE_TYPES, entry.initiatorType) ||
            (ignoreRegExp && ignoreRegExp.test(entry.name)))
            return;
        var data = { ev_type: RESOURCE_EV_TYPE$1, payload: entry };
        isSlowSession && (data.extra = { sample_rate: 1 });
        report(data);
    };
    tearDownGroup.push(loadObserver[0](function () {
        var _a = __read(applyPerformance(performance), 3), timing = _a[0], getEntriesByType = _a[2];
        var checkSlowSession = function () {
            if (!timing) {
                return false;
            }
            var loadTime = timing.loadEventEnd - timing.navigationStart;
            return loadTime > slowSessionThreshold;
        };
        var isSlowSession = checkSlowSession();
        var cacheEntries = getEntriesByType(RESOURCE_PERFORMANCE_ENTRY_TYPE);
        cacheEntries.forEach(function (e) { return reportResource(e, isSlowSession); });
        tearDownGroup.push(getResourceObserver()[0](function (entry) {
            reportResource(entry);
        }));
    }));
};

var RESOURCE_MONITOR_PLUGIN_NAME = 'resource';
var defaultConfig$3 = {
    ignoreUrls: [],
    slowSessionThreshold: 4000,
};
function ResourceMonitorPlugin(client) {
    client.on('init', function () {
        var config = getPluginConfig(client, RESOURCE_MONITOR_PLUGIN_NAME, defaultConfig$3);
        if (!config) {
            return;
        }
        var tearDownGroup = [];
        resourceGetterWithContext(client.report.bind(client), tearDownGroup, [initSubjectInGlobal(client, loadSubject), function () { return initSubjectInGlobal(client, resourceSubject); }], config);
        client.on('beforeDestroy', function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
    });
}

/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
function isHTMLLinkElement(target) {
    return target.tagName.toLowerCase() === 'link';
}
function getElementAttr(target, attr) {
    if (isFunction(target.getAttribute)) {
        // returns what was in the HTML. It may be a relative URL.
        return target.getAttribute(attr) || '';
    }
    // target.src returns absoulute path
    return target[attr] || '';
}
var getSrc = function (target) {
    return getElementAttr(target, isHTMLLinkElement(target) ? 'href' : 'src');
};
var getDataFromEvent = function (e) {
    var target = (e.target || e.srcElement);
    if (!target) {
        return;
    }
    var tagName = target.tagName;
    if (!tagName || !isString(tagName)) {
        return;
    }
    var src = getSrc(target);
    return {
        url: src,
        tagName: tagName,
    };
};
var buildPayload = function (data, getEntriesByName) {
    var url = data.url, tagName = data.tagName, xpath = data.xpath;
    var fullUrl = getFullUrl(url);
    var timing = getEntriesByName(fullUrl)[0];
    return {
        type: tagName.toLowerCase(),
        url: fullUrl,
        xpath: xpath,
        timing: timing,
    };
};

var RESOURCE_ERROR_EV_TYPE = 'resource_error';
var resourceErrorGetterWithContext = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 1), errorObserver = _b[0];
    var window = getDefaultBrowser();
    if (!window)
        return;
    var ignoreUrls = config.ignoreUrls, includeUrls = config.includeUrls, dedupe = config.dedupe;
    var includeRegExp = getRegexp(includeUrls);
    var ignoreRegExp = getRegexp(ignoreUrls);
    var _c = __read(applyPerformance(getDefaultPerformance()), 5), getEntriesByName = _c[4];
    var lastErrPath = undefined;
    var reportResourceError = function (data) {
        var locationHref = location && location.href;
        if (locationHref && data.url === locationHref)
            return;
        if ((includeRegExp && !includeRegExp.test(data.url)) || (ignoreRegExp && ignoreRegExp.test(data.url)))
            return;
        if (!data.url)
            return;
        if (dedupe && data.url === lastErrPath)
            return;
        lastErrPath = data.url;
        // when the error occurs, the timing has been pushed into the buffer pool
        // so use getEntriesByName instead of resourceObserver
        var payload = buildPayload(data, getEntriesByName);
        if (payload) {
            report({
                ev_type: RESOURCE_ERROR_EV_TYPE,
                payload: payload,
            });
        }
    };
    tearDownGroup.push(errorObserver[0](function (event) {
        var e = event || window.event;
        if (!e) {
            return;
        }
        var data = getDataFromEvent(e);
        data && reportResourceError(data);
    }));
    return reportResourceError;
};

var RESOURCE_ERROR_MONITOR_PLUGIN_NAME = 'resourceError';
var defaultConfig$2 = {
    includeUrls: [],
    ignoreUrls: [],
    dedupe: true,
};
function ResourceErrorMonitorPlugin(client) {
    client.on('init', function () {
        var config = getPluginConfig(client, RESOURCE_ERROR_MONITOR_PLUGIN_NAME, defaultConfig$2);
        if (!config) {
            return;
        }
        var tearDownGroup = [];
        var reportResourceError = resourceErrorGetterWithContext(client.report.bind(client), tearDownGroup, [initSubjectInGlobal(client, errorSubject)], config);
        client.on('beforeDestroy', function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
        reportResourceError && client.provide('reportResourceError', reportResourceError);
    });
}

var defaultMetricContext = {
    isSupport: true,
    isPolyfill: false,
    isBounced: false,
    isCustom: false,
    type: 'perf',
};
var initMetric = function (name, value) {
    return __assign({ name: name, value: value }, defaultMetricContext);
};

var PERFORMANCE_MONITOR_PLUGIN_NAME = 'performance';
var defaultPerformancePrecollect = {
    entries: [],
    observer: undefined,
};

var SINGLE_METRIC_EV_TYPE = 'performance';
var LONG_TASK_EV_TYPE = 'performance_longtask';
var applySendOnceAndTearDown = function (wrapPerformanceMetric, report, tearDownGroup) {
    var hasInvoked = false;
    return function (metric) {
        tearDownGroup.length &&
            tearDownGroup.forEach(function (v) {
                v();
            });
        tearDownGroup.length = 0;
        if (hasInvoked)
            return;
        hasInvoked = true;
        report && report(wrapPerformanceMetric(metric));
    };
};
var wrapPerformanceMetric = function (metric, overrides) { return ({
    ev_type: SINGLE_METRIC_EV_TYPE,
    payload: metric,
    overrides: overrides,
}); };
var wrapLongtask = function (entry) { return ({
    ev_type: LONG_TASK_EV_TYPE,
    payload: {
        type: 'perf',
        longtasks: [entry],
    },
}); };
var applyReportMetric = function (report) {
    return function (metric, overrides) {
        report(wrapPerformanceMetric(metric, overrides));
    };
};
var SPA_LOAD_METRIC_NAME = 'spa_load';
var getSPA$1 = function (report) {
    var startTime = 0;
    var metric = initMetric(SPA_LOAD_METRIC_NAME, 0);
    var invokeCb = function (load_time) {
        metric.value = load_time;
        report && report(wrapPerformanceMetric(metric));
    };
    var performanceInit = function () {
        startTime = now();
    };
    var performanceSend = function () {
        invokeCb(now() - startTime);
        startTime = 0;
    };
    return [performanceInit, performanceSend];
};

var FCP_ENTRY_NAME = 'first-contentful-paint';
var FP_ENTRY_NAME = 'first-paint';
var FP_METRIC_NAME = "fp" /* fp */;
var FCP_METRIC_NAME = "fcp" /* fcp */;
var Paint_Type = 'paint';
var getFP = function (report, tearDownGroup, context) {
    return getPaint(FP_ENTRY_NAME, FP_METRIC_NAME, report, tearDownGroup, context);
};
var getFCP = function (report, tearDownGroup, context) {
    return getPaint(FCP_ENTRY_NAME, FCP_METRIC_NAME, report, tearDownGroup, context);
};
var getPaint = function (entryName, metricName, report, tearDownGroup, _a) {
    var _b = __read(_a, 2), hiddenObserver = _b[0], unloadObserver = _b[1];
    var PerformanceObserver = getDefaultPerformanceObserver();
    var performance = getDefaultPerformance();
    var metric = initMetric(metricName, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    if (!performance || !PerformanceObserver) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    var invokePaint = function (_a) {
        var startTime = _a.startTime;
        metric.value = startTime;
        sendOnceAndTearDown(metric);
    };
    var _c = __read(applyPerformance(performance), 5), getEntriesByName = _c[4];
    var paint = getEntriesByName(entryName)[0];
    if (paint) {
        invokePaint(paint);
        return;
    }
    tearDownGroup.push(observePerf(PerformanceObserver, function (entry) {
        entry.name === entryName && invokePaint(entry);
    }, [Paint_Type]));
    tearDownGroup.push(hiddenObserver[0](function () {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
    }));
    tearDownGroup.push(unloadObserver[0](function () {
        metric.isBounced = true;
        sendOnceAndTearDown(metric);
    }));
};
var FP = [FP_METRIC_NAME, getFP];
var FCP = [FCP_METRIC_NAME, getFCP];

var TTI_METRIC_NAME = 'tti';
var GET_METHOD = 'get';
var QUIET_TIME_LIMIT = 5000;
/**
 * start 方法开启一个调度器，传入回调和调度时间
 * reschedule 重新以一个更长的时间调度
 * stop 停止调度
 */
var applyScheduler = function (now) {
    var timerActiveTime = -Infinity;
    var timerId = undefined;
    var callback;
    var clearTime = function () { return window.clearTimeout(timerId); };
    var reschedule = function (futureTime) {
        if (timerActiveTime > futureTime || !callback) {
            return;
        }
        clearTime();
        timerId = window.setTimeout(callback, futureTime - now());
        timerActiveTime = futureTime;
    };
    var start = function (cb, futureTime) {
        callback = cb;
        reschedule(futureTime);
    };
    var stop = function () {
        clearTime();
        callback = undefined;
    };
    return [start, stop, reschedule];
};
/**
 * Computes the time (in milliseconds since requestStart) that the network was
 * last known to have >2 requests in-flight.
 */
var calcLastNet2Busy = function (undoneReqStarts, observedResReqs, now) {
    if (undoneReqStarts.length > 2) {
        return now();
    }
    var endpoints = [];
    for (var i = 0; i < observedResReqs.length; i++) {
        endpoints.push([observedResReqs[i].start, 0 /* S */], [observedResReqs[i].end, 1 /* E */]);
    }
    for (var i = 0; i < undoneReqStarts.length; i++) {
        endpoints.push([undoneReqStarts[i], 0 /* S */]);
    }
    endpoints.sort(function (a, b) { return a[0] - b[0]; });
    var currentActive = undoneReqStarts.length;
    for (var i = endpoints.length - 1; i >= 0; i--) {
        var _a = __read(endpoints[i], 2), timestamp = _a[0], type = _a[1];
        switch (type) {
            case 0 /* S */:
                currentActive--;
                break;
            case 1 /* E */:
                currentActive++;
                if (currentActive > 2) {
                    return timestamp;
                }
                break;
        }
    }
    // If we reach here, we were never network 2-busy.
    return 0;
};
var getRequestTimes = function (requestTimes) {
    var keys = Object.keys(requestTimes);
    var result = [];
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (var i = 0; i < keys.length; i++) {
        var val = requestTimes[keys[i]];
        if (typeof val === 'number') {
            result.push(val);
        }
    }
    return result;
};
/**
 * 监听包含 ['img', 'script', 'iframe', 'link', 'audio', 'video', 'source'] 标签的 dom 变更
 */
var observeResFetchMutations = function (MutationObserver, callback) {
    var requestCreatingNodeNames = ['img', 'script', 'iframe', 'link', 'audio', 'video', 'source'];
    function subtreeContainsNodeName(nodes, nodeNames) {
        for (var i = 0; i < nodes.length; i++) {
            if (arrayIncludes(nodeNames, nodes[i].nodeName.toLowerCase()) ||
                (nodes[i].children &&
                    subtreeContainsNodeName(nodes[i].children, nodeNames))) {
                return true;
            }
        }
        return false;
    }
    var _a = __read(applyMutationObserver(MutationObserver, function (mutations) {
        for (var i = 0; i < mutations.length; i++) {
            if ((mutations[i].type === 'childList' &&
                subtreeContainsNodeName(mutations[i].addedNodes, requestCreatingNodeNames)) ||
                (mutations[i].type === 'attributes' &&
                    arrayIncludes(requestCreatingNodeNames, mutations[i].target.nodeName.toLowerCase()))) {
                callback(mutations[i]);
            }
        }
    }), 2), observe = _a[0], disconnect = _a[1];
    return [
        function () {
            return observe(document, {
                attributes: true,
                childList: true,
                subtree: true,
                attributeFilter: ['href', 'src'],
            });
        },
        disconnect,
    ];
};
/**
 * Returns either a manually set min value or the time since
 * domContentLoadedEventEnd and navigationStart. If the
 * domContentLoadedEventEnd data isn't available, `null` is returned.
 * @return {number|null}
 */
var getMinValue = function (timing) {
    var _a = timing || {}, domContentLoadedEventEnd = _a.domContentLoadedEventEnd, _b = _a.navigationStart, navigationStart = _b === void 0 ? 0 : _b;
    return domContentLoadedEventEnd ? domContentLoadedEventEnd - navigationStart : null;
};
/**
 * Computes the TTI value...
 * @param {number} searchStart
 * @param {number} minValue
 * @param {number} lastKnownNetwork2Busy
 * @param {number} currentTime
 * @param {!Array<{start: (number), end: (number)}>} longTasks
 * @return {number|null}
 */
var computeTTI = function (searchStart, minValue, lastKnownNetwork2Busy, currentTime, longTasks) {
    // Have not reached network 2-quiet yet.
    if (currentTime - lastKnownNetwork2Busy < QUIET_TIME_LIMIT) {
        return null;
    }
    var maybeFCI = longTasks.length === 0 ? searchStart : longTasks[longTasks.length - 1].end;
    // Main thread has not been quiet for long enough.
    if (currentTime - maybeFCI < QUIET_TIME_LIMIT) {
        return null;
    }
    return Math.max(maybeFCI, minValue);
};
var pushLongTaskIntoList = function (entry, list) {
    var startTime = entry.startTime, duration = entry.duration;
    entry.start = startTime;
    entry.end = startTime + duration;
    list.push(entry);
};
var getLastBusyAndLongTasks = function (tearDownGroup, _a, entries) {
    var _b = __read(_a, 5), xhrObserver = _b[0], fetchObserver = _b[1], longtaskObserver = _b[2], resourceObserver = _b[3], MutationObserver = _b[4];
    return function (reschedule, now$1) {
        var longTasks = [];
        var networkRequests = [];
        var _a = __read(applyRecord(), 3), incompleteInitReqStartTimes = _a[0], before = _a[1], after = _a[2];
        entries.forEach(function (entry) {
            if (entry.entryType === LONGTASK_TYPE[0]) {
                pushLongTaskIntoList(entry, longTasks);
            }
        });
        var uniqId = 0;
        tearDownGroup.push(xhrObserver[0](function (_a) {
            var _b = __read(_a, 1), _method = _b[0];
            if ((_method || '').toLowerCase() !== GET_METHOD)
                return noop;
            var requestId = (uniqId += 1);
            before(requestId, now());
            return function () {
                after(requestId);
            };
        }));
        tearDownGroup.push(fetchObserver[0](function (_a) {
            var _b = __read(_a, 2), req = _b[0], options = _b[1];
            if (!window.Request || getFetchMethod(req, options, window.Request) !== GET_METHOD)
                return noop;
            var requestId = (uniqId += 1);
            before(requestId, now());
            return function () {
                after(requestId);
            };
        }));
        var _b = __read((MutationObserver && observeResFetchMutations(MutationObserver, function () { return reschedule(now$1() + QUIET_TIME_LIMIT); })) || [], 2), observeRes = _b[0], stopObserveRes = _b[1];
        observeRes && observeRes();
        var getLastBusy = function () { return calcLastNet2Busy(getRequestTimes(incompleteInitReqStartTimes), networkRequests, now$1); };
        stopObserveRes && tearDownGroup.push(stopObserveRes);
        tearDownGroup.push(longtaskObserver[0](function (entry) {
            pushLongTaskIntoList(entry, longTasks);
            var startTime = entry.startTime, duration = entry.duration;
            // 遇到 longTask 则在 longTask 5秒后 checkTTI
            reschedule(startTime + duration + QUIET_TIME_LIMIT);
        }));
        tearDownGroup.push(resourceObserver[0](function (_a) {
            var fetchStart = _a.fetchStart, responseEnd = _a.responseEnd;
            networkRequests.push({
                start: fetchStart,
                end: responseEnd,
            });
            // 遇到 resource 加载，则在最后一次 busy 5 秒后 checkTTI
            reschedule(getLastBusy() + QUIET_TIME_LIMIT);
        }));
        tearDownGroup.push(function () {
            longTasks.length = 0;
            networkRequests.length = 0;
        });
        return [longTasks, getLastBusy];
    };
};
var getTTI = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 5), xhrObserver = _b[0], fetchObserver = _b[1], longtaskObserver = _b[2], resourceObserver = _b[3], pvObserver = _b[4];
    var metric = initMetric(TTI_METRIC_NAME, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    var performance = getDefaultPerformance();
    var _c = config || {}, _d = _c.entries, entries = _d === void 0 ? [] : _d, snippetObserver = _c.observer;
    tearDownGroup.push(function () {
        snippetObserver && snippetObserver.disconnect();
        entries.length = 0;
    });
    if (!window ||
        !XMLHttpRequest ||
        !performance ||
        !PerformanceObserver ||
        (PerformanceObserver.supportedEntryTypes &&
            !arrayIncludes(PerformanceObserver.supportedEntryTypes || [], LONGTASK_TYPE[0]))) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    var _e = __read(applyPerformance(performance), 5), timing = _e[0], now = _e[1], getEntriesByName = _e[4];
    var _f = __read(applyScheduler(now), 3), startSchedule = _f[0], stopSchedule = _f[1], reschedule = _f[2];
    var _g = __read(getLastBusyAndLongTasks(tearDownGroup, [xhrObserver, fetchObserver, longtaskObserver, resourceObserver, getDefaultMutationObserver()], entries)(reschedule, now), 2), longTasks = _g[0], getLastBusy = _g[1];
    tearDownGroup.push(stopSchedule);
    var checkTTI = function (ttiCallback) {
        var firstContentfulPaint = getEntriesByName(FCP_ENTRY_NAME)[0];
        var maybeFCI = computeTTI((firstContentfulPaint ? firstContentfulPaint.startTime : getMinValue(timing)) || 0, getMinValue(timing) || 0, getLastBusy(), now(), longTasks);
        if (!maybeFCI)
            return reschedule(now() + 1000);
        ttiCallback(maybeFCI);
    };
    var reportTTI = function (value) {
        metric.value = value;
        sendOnceAndTearDown(metric);
    };
    var lastLongTask = longTasks[longTasks.length - 1];
    startSchedule(function () { return checkTTI(reportTTI); }, Math.max(getLastBusy() + QUIET_TIME_LIMIT, lastLongTask ? lastLongTask.end : 0));
    tearDownGroup.push(pvObserver[0](function () {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
    }));
};

/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
var TTI_MONITOR_PLUGIN_NAME = 'tti';
function TTIMonitorPlugin(client) {
    client.on('init', function () {
        var config = getPluginConfig(client, TTI_MONITOR_PLUGIN_NAME, {});
        if (!config) {
            return;
        }
        var tearDownGroup = [];
        getTTI(reportOnInitCommonParams(client), tearDownGroup, [
            initSubjectInGlobal(client, [XHR_SUBJECT_NAME, applyXHR(XMLHttpRequest && XMLHttpRequest.prototype)]),
            initSubjectInGlobal(client, fetchSubject),
            initSubjectInGlobal(client, longtaskSubject),
            initSubjectInGlobal(client, resourceSubject),
            initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]),
        ], client.pp);
        client.on('beforeDestroy', function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
    });
}

var FMP_METRIC_NAME = 'fmp';
var DEFAULT_IGNORE_TAGS$1 = ['SCRIPT', 'STYLE', 'META', 'HEAD'];
var getScore = function (element, depth, exist, ignoreTags) {
    if (!element || ignoreTags.indexOf(element.tagName) > -1) {
        return 0;
    }
    var _a = element.children, children = _a === void 0 ? [] : _a;
    var score = [].slice
        .call(children)
        .reduceRight(function (sum, child) { return sum + getScore(child, depth + 1, sum > 0, ignoreTags); }, 0);
    if (score <= 0 && !exist) {
        if (!isFunction(element.getBoundingClientRect)) {
            return 0;
        }
        var _b = element.getBoundingClientRect() || {}, top_1 = _b.top, height = _b.height;
        if (top_1 > window.innerHeight || height <= 0) {
            return 0;
        }
    }
    return score + 1 + 0.5 * depth;
};
var getFMPInternal = function (_a) {
    var _b = _a === void 0 ? [] : _a, _c = __read(_b), first = _c[0], rest = _c.slice(1);
    return ((rest &&
        rest.reduce(function (_a, cur) {
            var _b = __read(_a, 2), prev = _b[0], target = _b[1];
            var diff = cur.score - prev.score;
            return [cur, cur.time >= prev.time && target.rate < diff ? { time: cur.time, rate: diff } : target];
        }, [first, { time: first === null || first === void 0 ? void 0 : first.time, rate: 0 }])[1].time) ||
        0);
};
var getFMP = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 1), loadObserver = _b[0];
    var document = getDefaultDocument();
    var MutationObserver = getDefaultMutationObserver();
    var performance = getDefaultPerformance();
    var navigationStart = (performance && performance.timing && performance.timing.navigationStart) || undefined;
    var metric = initMetric(FMP_METRIC_NAME, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    if (!document || !MutationObserver || !navigationStart) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    var startTime = now();
    var list = [];
    var record = function () {
        return list.push({
            time: now() - startTime,
            // eslint-disable-next-line compat/compat
            score: getScore(document && document.body, 1, false, DEFAULT_IGNORE_TAGS$1),
        });
    };
    var raf = getDefaultRaf();
    var caf = getDefaultCaf();
    var _c = __read(applyAnimationFrame(document, raf, caf, true), 1), scheduleAF = _c[0];
    // 持续监听 dom 变化，记录下时间和得分
    // scheduleAF 可以避免强制回流，同时真正的变更是在animationFrame 中
    var _d = __read(applyMutationObserver(MutationObserver, function () { return scheduleAF(record); }), 2), observe = _d[0], disconnect = _d[1];
    var tirggerFMP = function (timeGap) {
        if (timeGap === void 0) { timeGap = 0; }
        var fmp = getFMPInternal(list);
        metric.value = fmp ? fmp + timeGap : 0;
        sendOnceAndTearDown(metric);
        list.length = 0;
    };
    var timeGap = startTime - (navigationStart || 0);
    observe(document, { subtree: true, childList: true });
    tearDownGroup.push(disconnect);
    tearDownGroup.push(loadObserver[0](function () {
        setTimeout(function () {
            tirggerFMP(timeGap);
        }, 200);
    }));
};

var FMP_MONITOR_PLUGIN_NAME = 'fmp';
var defaultConfig$1 = {
    renderType: 'CSR',
};
function FMPMonitorPlugin(client) {
    client.on('init', function () {
        var config = getPluginConfig(client, FMP_MONITOR_PLUGIN_NAME, defaultConfig$1);
        if (!config) {
            return;
        }
        var tearDownGroup = [];
        var loadObserver = initSubjectInGlobal(client, loadSubject);
        if (config.renderType === 'SSR') {
            var hiddenObserver = initSubjectInGlobal(client, hiddenSubject);
            var unloadObserver = initSubjectInGlobal(client, unloadSubject);
            // @ts-expect-error
            getPaint(FP_ENTRY_NAME, FMP_MONITOR_PLUGIN_NAME, reportOnInitCommonParams(client), tearDownGroup, [
                hiddenObserver,
                unloadObserver,
            ]);
        }
        else {
            getFMP(reportOnInitCommonParams(client), tearDownGroup, [loadObserver]);
        }
        client.on('beforeDestroy', function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
    });
}

var DEFAULT_IGNORE_TAGS = ['SCRIPT', 'STYLE', 'META', 'HEAD'];
var ERROR_RELATED_TYPE = ['js_error', 'http', 'resource_error'];
var DEFAULT_THRESHOLD = 1.5;
var MAX_RENDER_TIME = 10000;
var MAX_CHECK_TIME = 8000;
var DEFAULT_CHECK_TIME = 2000;
var MAX_RELATED_TIME = 10000;
var DEFAULT_T0_DATA_URL_QUALITY = 0.1;
var CHECK_EXCLUSIVE_EV_TYPES = [
    'performance',
    'performance_longtask',
    'performance_timing',
    'custom',
];
var isSkipBeforeCheck = function (ev) { return ~CHECK_EXCLUSIVE_EV_TYPES.indexOf(ev.ev_type); };
var blankErrorCompare = function (relatedError, ev) {
    if (ERROR_RELATED_TYPE.indexOf(ev.ev_type) === -1)
        return relatedError;
    if (ev.ev_type === 'http' && ev.payload.response.status < 400) {
        return relatedError;
    }
    if (relatedError && ERROR_RELATED_TYPE.indexOf(relatedError.type) < ERROR_RELATED_TYPE.indexOf(ev.ev_type)) {
        return relatedError;
    }
    var message = '';
    switch (ev.ev_type) {
        case 'js_error':
            message = ev.payload.error.message;
            break;
        case 'http':
            message = ev.payload.request.url;
            break;
        case 'resource_error':
            message = ev.payload.url;
            break;
    }
    return { type: ev.ev_type, message: message, timestamp: now() };
};
var measure = function (element, depth, sum, threshold, ignoreTags) {
    if (depth === void 0) { depth = 0; }
    if (sum === void 0) { sum = 0; }
    if (threshold === void 0) { threshold = DEFAULT_THRESHOLD; }
    if (ignoreTags === void 0) { ignoreTags = DEFAULT_IGNORE_TAGS; }
    if (!element || ignoreTags.indexOf(element.tagName) > -1 || sum >= threshold || depth > 4) {
        return sum;
    }
    var score = (function () {
        if (!depth)
            return 0;
        var _a = element.getBoundingClientRect(), top = _a.top, height = _a.height;
        return top > innerHeight || height <= 0 ? 0 : 1 / Math.pow(2, depth - 1);
    })();
    return [].reduceRight.call(element.children, function (all, child) { return measure(child, depth + 1, all, threshold, ignoreTags); }, sum + score);
};
var screenshot = function (_a) {
    var _b;
    var cb = _a.cb, screenshotUrl = _a.screenshotUrl, window = _a.window, document = _a.document, mask = _a.mask, partialShot = _a.partialShot, quality = _a.quality, rootSelector = _a.rootSelector;
    if (!getDefaultPromise() || !window || !document) {
        return;
    }
    function onload() {
        var requestIdleCallback = applyRequestIdleCallback(window);
        requestIdleCallback(function () {
            window.html2canvas &&
                window.html2canvas((partialShot && rootSelector && document.querySelector(rootSelector)) || document.body, {
                    scale: 360 / window.innerWidth,
                    mask: mask,
                }).then(function (canvas) {
                    cb(canvas.toDataURL('image/jpeg', quality));
                });
        });
    }
    if (window.html2canvas) {
        return onload();
    }
    var script = document.createElement('script');
    script.src = screenshotUrl;
    // eslint-disable-next-line compat/compat
    (_b = document.head) === null || _b === void 0 ? void 0 : _b.appendChild(script);
    script.onload = onload;
};

var BlankScreenMonitor = function (win, document, performanceObserver, mutationObserver, performance) {
    if (win === void 0) { win = getDefaultBrowser(); }
    if (document === void 0) { document = getDefaultDocument(); }
    if (performanceObserver === void 0) { performanceObserver = getDefaultPerformanceObserver(); }
    if (mutationObserver === void 0) { mutationObserver = getDefaultMutationObserver(); }
    if (performance === void 0) { performance = getDefaultPerformance(); }
    if (!document || !win) {
        return;
    }
    return function (_b, cb) {
        var threshold = _b.threshold, takeScreenshot = _b.screenshot, rootSelector = _b.rootSelector, autoDetect = _b.autoDetect, ssUrl = _b.ssUrl, quality = _b.quality, mask = _b.mask, partialShot = _b.partialShot;
        var requestIdleCallback = applyRequestIdleCallback(win);
        var _c = __read(applyPerformance(performance), 2), relativeNow = _c[1];
        var blankInfo;
        var errorInfo;
        var otherReportedTimestamp = 0;
        var reported = false;
        var timer;
        var pureReport = function (base64) {
            blankInfo &&
                cb &&
                cb({
                    ev_type: 'blank_screen',
                    payload: {
                        timestamp: blankInfo[0],
                        score: blankInfo[1],
                        screenshot: base64,
                        error: errorInfo,
                    },
                });
        };
        var report = function () {
            if (!blankInfo || reported) {
                return;
            }
            reported = true;
            tearDown();
            takeScreenshot
                ? screenshot({
                    cb: pureReport,
                    screenshotUrl: ssUrl,
                    window: win,
                    document: document,
                    mask: mask,
                    partialShot: partialShot,
                    quality: quality,
                    rootSelector: rootSelector,
                })
                : pureReport();
        };
        var applyOtherReport = function (ev) {
            if (reported || isSkipBeforeCheck(ev))
                return;
            otherReportedTimestamp = now();
            if (errorInfo && otherReportedTimestamp - errorInfo.timestamp > MAX_RELATED_TIME) {
                errorInfo = undefined;
            }
            errorInfo = blankErrorCompare(errorInfo, ev);
        };
        var applyCheck = function (cb) {
            var checkTimer;
            var checkTimestamp;
            return function () {
                if (checkTimer) {
                    return;
                }
                checkTimestamp = now();
                checkTimer = win.setTimeout(function () {
                    checkTimer = 0;
                    if (otherReportedTimestamp > checkTimestamp) {
                        return;
                    }
                    cb();
                }, relativeNow() > MAX_RENDER_TIME ? DEFAULT_CHECK_TIME : MAX_CHECK_TIME);
            };
        };
        var checkAndReport = applyCheck(report);
        onPageUnload(function () {
            !reported && errorInfo && pureReport();
        });
        var schedule = function () {
            timer && clearTimeout(timer);
            timer = win.setTimeout(function () {
                requestIdleCallback(function () {
                    win.requestAnimationFrame(function () {
                        // eslint-disable-next-line compat/compat
                        var element = rootSelector ? document.querySelector(rootSelector) : document.body;
                        if (!element) {
                            return;
                        }
                        var score = measure(element, 0, 0, threshold);
                        if (score < threshold) {
                            blankInfo = [now(), score];
                            checkAndReport();
                        }
                        else {
                            blankInfo = undefined;
                        }
                    });
                });
            }, 1000);
        };
        var tearDown = function () {
            clearTimeout(timer);
            mutDisconnect && mutDisconnect();
            perfDisconnect && perfDisconnect();
        };
        var _d = __read(applyMutationObserver(mutationObserver, schedule), 2), mutObserve = _d[0], mutDisconnect = _d[1];
        var _e = __read(applyPerformanceObserver$1(performanceObserver, function (_a, _i, arr) { return timer && arr.length > 1 && schedule(); }), 2), perfObserve = _e[0], perfDisconnect = _e[1];
        if (autoDetect)
            // start observe blank screen after DOMContentLoaded
            onDOMContentLoaded(function () {
                var _b;
                mutObserve((_b = getDefaultDocument()) === null || _b === void 0 ? void 0 : _b.body, { subtree: true, childList: true });
                perfObserve('longtask', 'resource');
                schedule();
            });
        return [tearDown, applyOtherReport, schedule];
    };
};

var BLANK_SCREEN_MONITOR_PLUGIN_NAME = 'blankScreen';
function BlankScreenMonitorBasePlugin(client, defaultConfig, overrideConfig) {
    client.on('init', function () {
        var config = getPluginConfig(client, BLANK_SCREEN_MONITOR_PLUGIN_NAME, defaultConfig) ||
            getConfig(overrideConfig, defaultConfig);
        if (!config) {
            return;
        }
        var _a = __read(applyMonitor(BlankScreenMonitor, config, client.report.bind(client)), 3), tearDown = _a[0], applyOtherReport = _a[1], detectBlankScreen = _a[2];
        var listenOtherReport = function (ev) {
            applyOtherReport(ev);
            return ev;
        };
        client.on('report', listenOtherReport);
        client.on('beforeDestroy', function () {
            tearDown();
            client.off('report', listenOtherReport);
        });
        client.provide('detectBlankScreen', detectBlankScreen);
    });
}
var defaultByteConfig = {
    autoDetect: true,
    threshold: DEFAULT_THRESHOLD,
    screenshot: true,
    ssUrl: 'https://sf16-short-va.bytedapm.com/slardar/fe/sdk-web/screenshot.min.js',
    mask: false,
    partialShot: false,
    quality: DEFAULT_T0_DATA_URL_QUALITY,
};
function BlankScreenMonitorPlugin(client, overrideConfig) {
    BlankScreenMonitorBasePlugin(client, defaultByteConfig, overrideConfig);
}
var defaultVolConfig = {
    autoDetect: true,
    threshold: DEFAULT_THRESHOLD,
    screenshot: true,
    ssUrl: 'https://apm.volccdn.com/mars-web/apmplus/web/html2canvas.min.js',
    mask: false,
    partialShot: false,
    quality: DEFAULT_T0_DATA_URL_QUALITY,
};
function BlankScreenMonitorVolPlugin(client, overrideConfig) {
    BlankScreenMonitorBasePlugin(client, defaultVolConfig, overrideConfig);
}

var PAGE_ACTIVITY_DELAY = 100;
var MAX_PAGE_ACTIVITY_DELAY = 10000;
var ROOT_TAGS = ['BODY', 'HTML', 'HEAD'];
/**
 * 控制等待策略和强制结算
 * 结算策略: 没有进行中的请求, 没有dom变更, 没有resource or longTask
 */
var waitActionComplete = function (cb, forceClear, win) {
    var idleTimer;
    var maxIdleTimer;
    var started = false;
    var notify = function () {
        win.clearTimeout(idleTimer);
        started &&
            (idleTimer = win.setTimeout(function () {
                cb();
            }, PAGE_ACTIVITY_DELAY));
    };
    var start = function () {
        started = true;
        win.clearTimeout(maxIdleTimer);
        maxIdleTimer = win.setTimeout(function () {
            cb();
            forceClear();
        }, MAX_PAGE_ACTIVITY_DELAY);
        notify();
    };
    var complete = function () {
        started = false;
        win.clearTimeout(idleTimer);
        win.clearTimeout(maxIdleTimer);
    };
    return [start, notify, complete];
};
/**
 * 从target中获取path
 */
var getDomPath = function (element) {
    var el = element;
    var stack = [];
    try {
        while (el.parentNode !== null) {
            var sibCount = 0;
            var sibIndex = 0;
            // eslint-disable-next-line @typescript-eslint/prefer-for-of
            for (var i = 0; i < el.parentNode.childNodes.length; i++) {
                var sib = el.parentNode.childNodes[i];
                if (sib.nodeName === el.nodeName) {
                    if (sib === el) {
                        sibIndex = sibCount;
                    }
                    sibCount++;
                }
            }
            if (el.hasAttribute('id') && el.id !== '') {
                stack.unshift(el.nodeName + '#' + el.id);
            }
            else if (sibCount > 1) {
                stack.unshift(el.nodeName + ':eq(' + sibIndex + ')');
            }
            else {
                stack.unshift(el.nodeName);
            }
            el = el.parentNode;
        }
        // removes the html element
        return stack.slice(1).join('>');
    }
    catch (_a) {
        return;
    }
};
var isSupportsElementClosest = (function () {
    var supportsElementClosest;
    return function () {
        return supportsElementClosest === undefined
            ? (supportsElementClosest = 'closest' in HTMLElement.prototype)
            : supportsElementClosest;
    };
})();
var findElementWithAttributeByParents = function (target, attribute, maxParentLoops) {
    if (maxParentLoops === void 0) { maxParentLoops = 10; }
    var element = target;
    for (var i = 0; i < maxParentLoops && element; i++) {
        if (~ROOT_TAGS.indexOf(element.nodeName))
            return;
        if (element.hasAttribute(attribute)) {
            return element;
        }
        element = element.parentElement;
    }
};
var getActionNameByAttribute = function (target, attribute) {
    var elementWithAttribute;
    if (isSupportsElementClosest()) {
        elementWithAttribute = target.closest("[" + attribute + "]");
    }
    else {
        elementWithAttribute = findElementWithAttributeByParents(target, attribute);
    }
    if (!elementWithAttribute)
        return;
    var name = elementWithAttribute.getAttribute(attribute);
    // Possibly length of name is too long to be stored on backend.Let it go for now.Add truncation if someone oncalled
    return name.trim();
};
var getActionName = function (target, attribute) {
    return getActionNameByAttribute(target, attribute) || target.innerText;
};

var ACTION_EV_TYPE = 'action';
var HTTP_EV_TYPE = 'http';
var LONGTASK_RV_TYPE = 'performance_longtask';
var JS_ERROR_EV_TYPE = 'js_error';
var RESOURCE_EV_TYPE = 'resource';
var RELATED_EV_TYPES = [LONGTASK_RV_TYPE, HTTP_EV_TYPE, JS_ERROR_EV_TYPE, RESOURCE_EV_TYPE];
var SUPPORT_TYPES = ["click" /* CLICK */];
var EVENT_LISTENER_OPTIONS = { capture: true };
var DEFAULT_ATTR_NAME = 'data-apm-action';
/**
 * 劫持 XHR 和 fetch，监听当前页面未完成的 请求数量
 */
var applyIncompleteReq = function (tearDownGroup, _a, notify) {
    var _b = __read(_a, 2), xhrObserver = _b[0], fetchObserver = _b[1];
    var _c = __read(applyRecord(), 3), incompleteReq = _c[0], before = _c[1], after = _c[2];
    var uniqId = 0;
    tearDownGroup.push(xhrObserver[0](function (_a) {
        var _b = __read(_a, 1); _b[0];
        var requestId = (uniqId += 1);
        before(requestId, now());
        notify();
        return function () {
            after(requestId);
            notify();
        };
    }));
    tearDownGroup.push(fetchObserver[0](function () {
        var requestId = (uniqId += 1);
        before(requestId, now());
        notify();
        return function () {
            after(requestId);
            notify();
        };
    }));
    return incompleteReq;
};
var actionGetterWithFetchObserver = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 2), xhrObserver = _b[0], fetchObserver = _b[1];
    var types = config.types, pure = config.pure;
    var currentPayload = null;
    var requestStartAndEnd = [];
    var longtaskDuration = 0;
    var _c = __read(applyPerformance(performance), 2), now = _c[1];
    // 结算
    var reportActionIfAllowed = function () {
        // 不存在action上下文 || 未收集到相关payload || 依然有进行中的请求
        if (!currentPayload ||
            (!pure && !Object.keys(currentPayload.metrics).length) ||
            Object.keys(incompleteReq).length) {
            return;
        }
        // longtask duration
        currentPayload.metrics[LONGTASK_RV_TYPE] && (currentPayload.metrics[LONGTASK_RV_TYPE].duration = longtaskDuration);
        // request duration
        var requestDuration = requestStartAndEnd.length > 0 ? Math.max.apply(Math, __spreadArray([], __read(requestStartAndEnd), false)) - Math.min.apply(Math, __spreadArray([], __read(requestStartAndEnd), false)) : 0;
        currentPayload.metrics[HTTP_EV_TYPE] && (currentPayload.metrics[HTTP_EV_TYPE].duration = requestDuration);
        // end time
        var actionDuration = now() - currentPayload.start_time;
        report({
            ev_type: ACTION_EV_TYPE,
            payload: __assign(__assign({}, currentPayload), { duration: actionDuration, frontend_time: actionDuration - requestDuration }),
        });
        // 上报后重置数据
        resetAction();
    };
    var resetAction = function () {
        complete();
        currentPayload = null;
        requestStartAndEnd = [];
        longtaskDuration = 0;
    };
    var _d = __read(waitActionComplete(reportActionIfAllowed, resetAction, window), 3), start = _d[0], notify = _d[1], complete = _d[2];
    var incompleteReq = applyIncompleteReq(tearDownGroup, [xhrObserver, fetchObserver], notify);
    var _e = __read(applyMutationObserver(MutationObserver, notify), 2), observe = _e[0], disconnect = _e[1];
    observe();
    tearDownGroup.push(disconnect);
    // 补充数据
    var applyOtherReport = function (ev) {
        var _a, _b;
        if (!currentPayload) {
            return;
        }
        if (!arrayIncludes(RELATED_EV_TYPES, ev.ev_type)) {
            return;
        }
        // 通知监听，有相关变更
        notify();
        if (ev.ev_type === HTTP_EV_TYPE) {
            if (!ev.payload.response.timing) {
                return;
            }
            var _c = ev.payload.response.timing, startTime = _c.startTime, duration = _c.duration;
            if (startTime < currentPayload.start_time) {
                return;
            }
            requestStartAndEnd.push(startTime, startTime + duration);
        }
        else if (ev.ev_type === LONGTASK_RV_TYPE) {
            if (!ev.payload.longtasks.length || ev.payload.longtasks[0].startTime < currentPayload.start_time) {
                return;
            }
            ev.payload.longtasks.forEach(function (e) {
                longtaskDuration = longtaskDuration + e.duration;
            });
            // eslint-disable-next-line sonarjs/no-collapsible-if
        }
        else if (ev.ev_type === RESOURCE_EV_TYPE) {
            if (ev.payload.startTime < currentPayload.start_time) {
                return;
            }
        }
        currentPayload.metrics[ev.ev_type] = {
            count: ((_b = (_a = currentPayload.metrics[ev.ev_type]) === null || _a === void 0 ? void 0 : _a.count) !== null && _b !== void 0 ? _b : 0) + 1,
        };
        return currentPayload.id;
    };
    var initAction = function (target, type) {
        // refresh action id in common
        var actionId = uuid();
        var _a = __read(applyPerformance(performance), 2), now = _a[1];
        // init payload
        currentPayload = {
            start_time: now(),
            id: actionId,
            type: type,
            target: target,
            metrics: {},
        };
        start();
    };
    var handleEvent = function (e) {
        reportActionIfAllowed();
        resetAction();
        if (!(e.target instanceof HTMLElement)) {
            return;
        }
        var name = getActionName(e.target, DEFAULT_ATTR_NAME);
        if (!name) {
            return;
        }
        initAction({ name: name, path: getDomPath(e.target) }, e.type);
    };
    types &&
        types.forEach(function (t) {
            if (arrayIncludes(SUPPORT_TYPES, t)) {
                document.addEventListener(t, handleEvent, EVENT_LISTENER_OPTIONS);
                tearDownGroup.push(function () { return document.removeEventListener(t, handleEvent, EVENT_LISTENER_OPTIONS); });
            }
        });
    var startAction = function (name, type) {
        reportActionIfAllowed();
        resetAction();
        initAction({ name: name }, type);
    };
    return [applyOtherReport, startAction];
};

var ACTION_MONITOR_PLUGIN_NAME = 'action';
var defaultConfig = {
    types: ["click" /* CLICK */],
};
function ActionMonitorBasePlugin(client, config) {
    if (config === void 0) { config = defaultConfig; }
    var tearDownGroup = [];
    var document = getDefaultDocument();
    var window = getDefaultBrowser();
    if (!document || !window)
        return;
    var _a = __read(actionGetterWithFetchObserver(client.report.bind(client), tearDownGroup, [
        initSubjectInGlobal(client, [XHR_SUBJECT_NAME, applyXHR(XMLHttpRequest && XMLHttpRequest.prototype)]),
        initSubjectInGlobal(client, fetchSubject),
    ], config), 2), applyOtherReport = _a[0], startAction = _a[1];
    var listenOtherReport = function (ev) {
        var actionId = applyOtherReport(ev);
        actionId && ev.extra && (ev.extra.action_id = actionId);
        return ev;
    };
    client.on('report', listenOtherReport);
    client.provide('startAction', startAction);
    client.on('beforeDestroy', function () {
        tearDownGroup.forEach(function (e) { return e(); });
        client.off('report', listenOtherReport);
    });
}
function ActionMonitorPlugin(client) {
    client.on('init', function () {
        var config = getPluginConfig(client, ACTION_MONITOR_PLUGIN_NAME, defaultConfig);
        if (!config) {
            return;
        }
        ActionMonitorBasePlugin(client, config);
    });
}

var HEATMAP_MONITOR_PLUGIN_NAME = 'heatmap';

var LCP_ENTRY_NAME = 'largest-contentful-paint';
var LCP_METRIC_NAME = "lcp" /* lcp */;
var LCPListenerEventTypes = ['keydown', 'click'];
var getLCP = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 2), hiddenObserver = _b[0], unloadObserver = _b[1];
    var PerformanceObserver = getDefaultPerformanceObserver();
    var metric = initMetric(LCP_METRIC_NAME, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    if (!PerformanceObserver) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    tearDownGroup.push(observePerfWithBuffer(PerformanceObserver, function (_a) {
        var startTime = _a.startTime;
        metric.value = startTime;
    }, LCP_ENTRY_NAME));
    var inputEventHandler = function () {
        sendOnceAndTearDown(metric);
    };
    LCPListenerEventTypes.forEach(function (type) {
        window.addEventListener(type, inputEventHandler, true);
        tearDownGroup.push(function () {
            window.removeEventListener(type, inputEventHandler, true);
        });
    });
    tearDownGroup.push(hiddenObserver[0](function () {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
    }));
    tearDownGroup.push(unloadObserver[0](function () {
        metric.isBounced = true;
        sendOnceAndTearDown(metric);
    }));
};
var LCP = [LCP_METRIC_NAME, getLCP];

var FI_ENTRY_NAME = 'first-input';
var FID_METRIC_NAME = "fid" /* fid */;
var getFID = function (report, tearDownGroup) {
    var PerformanceObserver = getDefaultPerformanceObserver();
    var performance = getDefaultPerformance();
    var metric = initMetric(FID_METRIC_NAME, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    if (!performance || !PerformanceObserver) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    var invokePaint = function (_a) {
        var processingStart = _a.processingStart, startTime = _a.startTime;
        metric.value = processingStart - startTime;
        sendOnceAndTearDown(metric);
    };
    var _a = __read(applyPerformance(performance), 3), getEntriesByType = _a[2];
    var paint = getEntriesByType(FI_ENTRY_NAME)[0];
    if (paint) {
        invokePaint(paint);
        return;
    }
    tearDownGroup.push(observePerf(PerformanceObserver, invokePaint, [FI_ENTRY_NAME]));
};
var FID = [FID_METRIC_NAME, getFID];

var LS_ENTRY_NAME = 'layout-shift';
var CLS_METRIC_NAME = "cls" /* cls */;
var applyHandleEntries = function () {
    var sessionValue = 0;
    var sessionTimes = [];
    var resetSessionValue = function () {
        sessionValue = 0;
    };
    var handleEntriesWithMetric = function (callback, entry) {
        // Only count layout shifts without recent user input.
        if (!entry.hadRecentInput) {
            var firstSessionTime = sessionTimes[0];
            var lastSessionTime = sessionTimes[sessionTimes.length - 1];
            if (sessionValue && entry.startTime - lastSessionTime < 1000 && entry.startTime - firstSessionTime < 5000) {
                sessionValue += entry.value;
                sessionTimes.push(entry.startTime);
            }
            else {
                sessionValue = entry.value;
                sessionTimes = [entry.startTime];
            }
            callback(sessionValue);
        }
    };
    return [resetSessionValue, handleEntriesWithMetric];
};
var getCLS = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 3), hiddenObserver = _b[0], unloadObserver = _b[1], pvObserver = _b[2];
    var PerformanceObserver = getDefaultPerformanceObserver();
    var metric = initMetric(CLS_METRIC_NAME, 0);
    var reportMetric = applyReportMetric(report);
    if (!PerformanceObserver) {
        metric.isSupport = false;
        reportMetric(metric);
        return;
    }
    var _c = __read(applyHandleEntries(), 2), resetSessionValue = _c[0], handleEntriesWithMetric = _c[1];
    var handleEntries = handleEntriesWithMetric.bind(null, function (sessionValue) {
        sessionValue > metric.value && (metric.value = sessionValue);
    });
    tearDownGroup.push(observePerfWithBuffer(PerformanceObserver, handleEntries, LS_ENTRY_NAME));
    tearDownGroup.push(hiddenObserver[0](resetSessionValue));
    tearDownGroup.push(pvObserver[0](function (overrides) {
        reportMetric(metric, overrides);
        resetSessionValue();
        metric = initMetric(CLS_METRIC_NAME, 0);
    }));
    tearDownGroup.push(unloadObserver[0](function () {
        reportMetric(metric);
    }));
};
var CLS = [CLS_METRIC_NAME, getCLS];

var LONGTASK_METRIC_NAME = "longtask" /* longtask */;
var getLongtask = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 3), longtaskObserver = _b[2];
    tearDownGroup.push(longtaskObserver[0](function (entry) {
        report(wrapLongtask(entry));
    }));
};
var LONGTASK = [LONGTASK_METRIC_NAME, getLongtask];

var TIMING_METRIC_NAME = "timing" /* timing */;
var getTiming = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 2), loadObserver = _b[0], unloadObserver = _b[1];
    var performance = getDefaultPerformance();
    var _c = __read(applyPerformance(performance), 3), getEntriesByType = _c[2];
    var wrapTiming = function (isBounced) {
        var timing = (performance && performance.timing) || undefined;
        var navigation = getEntriesByType('navigation')[0];
        return {
            ev_type: 'performance_timing',
            payload: {
                isBounced: isBounced,
                timing: timing,
                navigation_timing: navigation,
            },
        };
    };
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapTiming, report, tearDownGroup);
    tearDownGroup.push(loadObserver[0](function () {
        sendOnceAndTearDown(false);
    }));
    tearDownGroup.push(unloadObserver[0](function () {
        sendOnceAndTearDown(true);
    }));
};
var TIMING = [TIMING_METRIC_NAME, getTiming];

var MPFID_METRIC_NAME = "mpfid" /* mpfid */;
var getMPFID = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 3), loadObserver = _b[0], longtaskObserver = _b[2];
    var PerformanceObserver = getDefaultPerformanceObserver();
    var performance = getDefaultPerformance();
    var metric = initMetric(MPFID_METRIC_NAME, 0);
    var list = [];
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    if (!PerformanceObserver) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    tearDownGroup.push(longtaskObserver[0](function (entry) {
        list.push(entry);
    }));
    var calculateAndSendMetric = function () {
        var _a = __read(applyPerformance(performance), 5), getEntriesByName = _a[4];
        var paint = getEntriesByName(FCP_ENTRY_NAME)[0];
        var FCPStartTime = (paint && paint.startTime) || 0;
        metric.value = list.reduce(function (res, _a) {
            var duration = _a.duration, startTime = _a.startTime;
            return (res < duration && startTime > FCPStartTime ? duration : res);
        }, 0);
        list.length = 0;
        sendOnceAndTearDown(metric);
    };
    tearDownGroup.push(loadObserver[0](function () {
        setTimeout(calculateAndSendMetric, 200);
    }));
};
var MPFID = [MPFID_METRIC_NAME, getMPFID];

function PerformanceMonitorPlugin(client) {
    client.on('init', function () {
        var _a;
        var precollect = client.pp || defaultPerformancePrecollect;
        // clear precollect observer no matter what is configured
        (_a = precollect.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
        var config = getPluginConfig(client, PERFORMANCE_MONITOR_PLUGIN_NAME, {});
        if (!config)
            return;
        var hiddenObserver = initSubjectInGlobal(client, hiddenSubject);
        var unloadObserver = initSubjectInGlobal(client, unloadSubject);
        var loadObserver = initSubjectInGlobal(client, loadSubject);
        var longtaskObserver = initSubjectInGlobal(client, longtaskSubject);
        var tearDownGroup = [];
        var overrides = undefined;
        var firstPVObserver = initPrivateSubject(client, [FIRST_PV_SUBJECT_NAME, applyFirstPV(client)], -1);
        firstPVObserver[0](function (o) {
            overrides = o;
        })();
        var reportMetric = function (data) {
            // every first screen metrics needs to be associated with the context when client init, but CLS and long task are not included
            var payloadWithOverrides = (data.ev_type === SINGLE_METRIC_EV_TYPE && data.payload.name === CLS[0]) ||
                data.ev_type === LONG_TASK_EV_TYPE
                ? data
                : __assign(__assign({}, data), { overrides: overrides });
            client.report(payloadWithOverrides);
        };
        var pvObserver = initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]);
        [FP, FCP, LCP, FID, CLS].forEach(function (cur) {
            if (config[cur[0]] !== false) {
                var tearDown = [];
                cur[1](reportMetric, tearDown, [hiddenObserver, unloadObserver, pvObserver]);
                tearDownGroup.push(tearDown);
            }
        });
        [LONGTASK, TIMING, MPFID].forEach(function (cur) {
            if (config[cur[0]] !== false) {
                var tearDown = [];
                cur[1](reportMetric, tearDown, [loadObserver, unloadObserver, longtaskObserver]);
                tearDownGroup.push(tearDown);
            }
        });
        // spa_load
        var _b = __read(getSPA$1(client.report.bind(client)), 2), performanceInit = _b[0], performanceSend = _b[1];
        client.provide('performanceInit', performanceInit);
        client.provide('performanceSend', performanceSend);
        // clear precollect data after consumed
        precollect.entries.length = 0;
        // provide custom performance API
        var sendPref = function (customMetric) {
            var payload = __assign(__assign(__assign({}, defaultMetricContext), customMetric), { isCustom: true });
            client.report(wrapPerformanceMetric(payload));
        };
        client.provide('sendCustomPerfMetric', sendPref);
        client.on('beforeDestroy', function () {
            tearDownGroup
                .reduce(function (pre, cur) {
                return pre.concat(cur);
            }, [])
                .forEach(function (fn) { return fn(); });
            tearDownGroup.length = 0;
        });
    });
}

var getSPA = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 6), pvObserver = _b[0], xhrObserver = _b[1], fetchObserver = _b[2], resourceObserver = _b[3], longtaskObserver = _b[4], MutationObserver = _b[5];
    var spa_load_start = 0;
    var reportMetric = applyReportMetric(report);
    var startSPA = function () {
        spa_load_start = now();
        observe(document, {
            childList: true,
            subtree: true,
        });
        start();
    };
    var reportSPAIfAllowed = function () {
        if (Object.keys(incompleteReq).length || !spa_load_start) {
            return;
        }
        reportMetric(initMetric(SPA_LOAD_METRIC_NAME, now() - spa_load_start));
        endSPA();
    };
    var endSPA = function () {
        complete();
        spa_load_start = 0;
        disconnect();
    };
    var _c = __read(waitActionComplete(reportSPAIfAllowed, endSPA, window), 3), start = _c[0], notify = _c[1], complete = _c[2];
    // request
    var incompleteReq = applyIncompleteReq(tearDownGroup, [xhrObserver, fetchObserver], notify);
    // resource
    tearDownGroup.push(resourceObserver[0](notify));
    // longtask
    tearDownGroup.push(longtaskObserver[0](notify));
    // dom
    var _d = __read(applyMutationObserver(MutationObserver, notify), 2), observe = _d[0], disconnect = _d[1];
    tearDownGroup.push(disconnect);
    var isFirstPV = true;
    // start SPA when PV change
    tearDownGroup.push(pvObserver[0](function () {
        if (isFirstPV) {
            isFirstPV = false;
            return;
        }
        // force end last SPA if not report
        endSPA();
        // start a new SPA metric
        startSPA();
    }));
    // reset SPA status when tear down
    tearDownGroup.push(endSPA);
};

function SPALoadMonitorPlugin(client) {
    client.on('init', function () {
        var tearDownGroup = [];
        var document = getDefaultDocument();
        var MutationObserver = getDefaultMutationObserver();
        if (!document || !MutationObserver)
            return;
        getSPA(client.report.bind(client), tearDownGroup, [
            initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]),
            initSubjectInGlobal(client, [XHR_SUBJECT_NAME, applyXHR(XMLHttpRequest && XMLHttpRequest.prototype)]),
            initSubjectInGlobal(client, fetchSubject),
            initSubjectInGlobal(client, resourceSubject),
            initSubjectInGlobal(client, longtaskSubject),
            MutationObserver,
        ]);
        client.on('beforeDestroy', function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
    });
}

var CUSTOM_EV_TYPE = 'custom';
var CUSTOM_EVENT_TYPE = 'event';
var CUSTOM_LOG_TYPE = 'log';
var normalizeCustomEventData = function (raw) {
    if (!raw || !isObject(raw)) {
        return;
    }
    // name is required
    if (!raw['name'] || !isString(raw['name'])) {
        return;
    }
    var res = {
        name: raw['name'],
        type: CUSTOM_EVENT_TYPE,
    };
    if ('metrics' in raw && isObject(raw['metrics'])) {
        var rMetrics = raw['metrics'];
        var metrics = {};
        for (var k in rMetrics) {
            if (isNumber(rMetrics[k])) {
                metrics[k] = rMetrics[k];
            }
        }
        res.metrics = metrics;
    }
    if ('categories' in raw && isObject(raw['categories'])) {
        var rCategories = raw['categories'];
        var categories = {};
        for (var k in rCategories) {
            categories[k] = safeStringify(rCategories[k]);
        }
        res.categories = categories;
    }
    return res;
};
var normalizeCustomLogData = function (raw) {
    if (!raw || !isObject(raw)) {
        return;
    }
    // content is required
    if (!raw['content'] || !isString(raw['content'])) {
        return;
    }
    var rContent = raw['content'];
    var res = {
        content: safeStringify(rContent),
        type: CUSTOM_LOG_TYPE,
        level: 'info',
    };
    if ('level' in raw) {
        res.level = raw['level'];
    }
    if ('extra' in raw && isObject(raw['extra'])) {
        var rExtra = raw['extra'];
        var metrics = {};
        var categories = {};
        for (var k in rExtra) {
            if (isNumber(rExtra[k])) {
                metrics[k] = rExtra[k];
            }
            else {
                categories[k] = safeStringify(rExtra[k]);
            }
        }
        res.metrics = metrics;
        res.categories = categories;
    }
    return res;
};
var CustomPlugin = function (client) {
    var sendEvent = function (data) {
        var normalized = normalizeCustomEventData(data);
        if (normalized) {
            client.report({
                ev_type: CUSTOM_EV_TYPE,
                payload: normalized,
                extra: {
                    timestamp: now(),
                },
            });
        }
    };
    var sendLog = function (data) {
        var normalized = normalizeCustomLogData(data);
        if (normalized) {
            client.report({
                ev_type: CUSTOM_EV_TYPE,
                payload: normalized,
                extra: {
                    timestamp: now(),
                },
            });
        }
    };
    client.provide('sendEvent', sendEvent);
    client.provide('sendLog', sendLog);
};

function getNetworkType(netInfo) {
    return (netInfo === null || netInfo === void 0 ? void 0 : netInfo.effectiveType) || (netInfo === null || netInfo === void 0 ? void 0 : netInfo.type) || '';
}
var InjectNetworkTypePlugin = function (client) {
    var netInfo = getDefaultNetworkInformation();
    var network_type = getNetworkType(netInfo);
    if (netInfo) {
        netInfo.onchange = function () {
            network_type = getNetworkType(netInfo);
        };
    }
    client.on('report', function (ev) {
        return __assign(__assign({}, ev), { extra: __assign(__assign({}, (ev.extra || {})), { network_type: network_type }) });
    });
};

/* eslint-disable @typescript-eslint/prefer-for-of */
var withSampleRate = function (ev, sampleRate) {
    var common = ev.common || {};
    common.sample_rate = sampleRate;
    ev.common = common;
    return ev;
};
var hitFnWithRandom = function (preCalc, sampleRate, isHitBySampleRate, random, isHitByRandom) {
    return preCalc
        ? (function (h) { return function () {
            return h;
        }; })(isHitByRandom(random, sampleRate))
        : function () { return isHitBySampleRate(sampleRate); };
};
var parseValues = function (values, type) {
    return values.map(function (v) {
        switch (type) {
            case 'number':
                return Number(v);
            case 'boolean':
                return v === '1';
            case 'string': // default to string
            default:
                return String(v);
        }
    });
};
var checkVal = function (val, values, op) {
    switch (op) {
        case 'eq':
            return arrayIncludes(values, val);
        case 'neq':
            return !arrayIncludes(values, val);
        case 'gt':
            return val > values[0];
        case 'gte':
            return val >= values[0];
        case 'lt':
            return val < values[0];
        case 'lte':
            return val <= values[0];
        case 'regex':
            return Boolean(val.match(new RegExp(values.join('|'))));
        case 'not_regex':
            return !val.match(new RegExp(values.join('|')));
        default: {
            // unknown op
            return false;
        }
    }
};
var checkFilter = function (ev, field, op, values) {
    var val = safeVisit(ev, field, function (t, p) {
        return t[p];
    });
    if (val === undefined) {
        return false;
    }
    var field_type = isBoolean(val) ? 'bool' : isNumber(val) ? 'number' : 'string';
    return checkVal(val, parseValues(values, field_type), op);
};
var matchFilter = function (ev, filter) {
    try {
        return filter.type === 'rule'
            ? checkFilter(ev, filter.field, filter.op, filter.values)
            : filter.type === 'and'
                ? filter.children.every(function (f) { return matchFilter(ev, f); })
                : filter.children.some(function (f) { return matchFilter(ev, f); });
    }
    catch (e) {
        reportSelfError(e);
        return false;
    }
};
var getHitMap = function (rules, preCalcHit, baseRate, isHitBySampleRate, random, isHitByRandom) {
    var hitMap = {};
    Object.keys(rules).forEach(function (name) {
        var _a = rules[name], enable = _a.enable, sample_rate = _a.sample_rate, conditional_sample_rules = _a.conditional_sample_rules;
        if (enable) {
            hitMap[name] = {
                enable: enable,
                sample_rate: sample_rate,
                effectiveSampleRate: sample_rate * baseRate,
                hit: hitFnWithRandom(preCalcHit, sample_rate, isHitBySampleRate, random, isHitByRandom),
            };
            if (conditional_sample_rules) {
                hitMap[name].conditional_hit_rules = conditional_sample_rules.map(function (_a) {
                    var s = _a.sample_rate, filter = _a.filter;
                    return ({
                        sample_rate: s,
                        hit: hitFnWithRandom(preCalcHit, s, isHitBySampleRate, random, isHitByRandom),
                        effectiveSampleRate: s * baseRate,
                        filter: filter,
                    });
                });
            }
        }
        else {
            hitMap[name] = {
                enable: enable,
                hit: function () {
                    /* istanbul ignore next */
                    return false;
                },
                sample_rate: 0,
                effectiveSampleRate: 0,
            };
        }
    });
    return hitMap;
};
var getSampler = function (userId, config, isHitBySampleRate, isHitByRandom) {
    if (!config)
        return id;
    // r的设计是为了允许外部传入随机数，用于彻底实现按用户采样
    var baseRate = config.sample_rate, include_users = config.include_users, sample_granularity = config.sample_granularity, rules = config.rules, _a = config.r, random = _a === void 0 ? Math.random() : _a;
    // 用户名单采样
    var userHit = arrayIncludes(include_users, userId);
    if (userHit) {
        return function (ev) { return withSampleRate(ev, 1); };
    }
    // should pre calculate hit
    var preCalcHit = sample_granularity === 'session';
    var baseHit = hitFnWithRandom(preCalcHit, baseRate, isHitBySampleRate, random, isHitByRandom);
    var hitMap = getHitMap(rules, preCalcHit, baseRate, isHitBySampleRate, random, isHitByRandom);
    return function (ev) {
        var _a;
        log('[sample]', ev);
        // 总采样必须命中才有后续
        if (!baseHit()) {
            log('[sample] base miss');
            return false;
        }
        // 未配置的事件类型
        if (!(ev.ev_type in hitMap)) {
            log('[sample] base hit');
            return withSampleRate(ev, baseRate);
        }
        // 忽略未开启的事件类型
        if (!hitMap[ev.ev_type].enable) {
            log('[sample] ev_type disabled', ev.ev_type);
            return false;
        }
        // 跳过采样配置
        if ((_a = ev.common) === null || _a === void 0 ? void 0 : _a.sample_rate) {
            log('[sample] skip');
            return ev;
        }
        var hitConfig = hitMap[ev.ev_type];
        var conditions = hitConfig.conditional_hit_rules;
        if (conditions) {
            // 先判断条件采样
            for (var i = 0; i < conditions.length; i++) {
                if (matchFilter(ev, conditions[i].filter)) {
                    log('[sample] filter matched');
                    if (conditions[i].hit()) {
                        log('[sample] filter hit');
                        return withSampleRate(ev, conditions[i].effectiveSampleRate);
                    }
                    log('[sample] filter miss');
                    // 条件匹配后不再搜索
                    return false;
                }
            }
        }
        // 事件类型采样
        if (!hitConfig.hit()) {
            log('[sample] ev_type miss');
            return false;
        }
        log('[sample] ev_type hit');
        // 事件类型默认采样已经命中
        return withSampleRate(ev, hitConfig.effectiveSampleRate);
    };
};
var SamplePlugin = function (client) {
    client.on('start', function () {
        var _a = client.config(), userId = _a.userId, sample = _a.sample;
        if (sample && sample.sample_rate === 0) {
            client.destroy();
        }
        var sampler = getSampler(userId, sample, isHitBySampleRate, isHitByRandom);
        client.on('build', sampler);
    });
};

/* eslint-disable @typescript-eslint/prefer-optional-chain */
var getBeaconTransport = function () {
    var window = getDefaultBrowser();
    // eslint-disable-next-line compat/compat
    return window && window.navigator.sendBeacon
        ? {
            get: function () { },
            post: function (url, data) {
                // eslint-disable-next-line compat/compat
                window.navigator.sendBeacon(url, data);
            },
        }
        : {
            get: noop,
            post: noop,
        };
};

var request = function (method, options, XMLHttpRequest) {
    var url = options.url, data = options.data, _a = options.success, success = _a === void 0 ? noop : _a, _b = options.fail, fail = _b === void 0 ? noop : _b, _c = options.getResponseText, getResponseText = _c === void 0 ? noop : _c, _d = options.withCredentials, withCredentials = _d === void 0 ? false : _d;
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = withCredentials;
    xhr.open(method, url, true);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.onload = function () {
        getResponseText === null || getResponseText === void 0 ? void 0 : getResponseText(this.responseText);
        try {
            if (this.responseText) {
                var result = JSON.parse(this.responseText);
                success(result);
            }
            else {
                success({});
            }
        }
        catch (e) {
            fail(e);
        }
    };
    xhr.onerror = function () {
        fail(new Error('Network request failed'));
    };
    xhr.onabort = function () {
        /* istanbul ignore next */
        fail(new Error('Network request aborted'));
    };
    xhr.send(data);
};
var getXhrTransport = function () {
    var XMLHttpRequest = getDefaultXMLHttpRequest();
    return XMLHttpRequest
        ? {
            get: function (options) {
                request('GET', options, XMLHttpRequest);
            },
            post: function (options) {
                request('POST', options, XMLHttpRequest);
            },
        }
        : {
            get: noop,
            post: noop,
        };
};

// createSender has side effects(register onClose behaviour)
// so it must be create lazily
function createBrowserSender(config) {
    var sender = createBatchSender(config);
    var beaconTransport = getBeaconTransport();
    var sendOnClose = function (data) {
        beaconTransport.post(sender.getEndpoint(), stringifyBatch([data]));
    };
    onPageUnload(function () {
        var data = sender.getBatchData();
        if (data) {
            beaconTransport.post(sender.getEndpoint(), data);
            sender.clear();
        }
        sender.send = sendOnClose;
    });
    return sender;
}

export { ACTION_MONITOR_PLUGIN_NAME, AJAX_MONITOR_PLUGIN_NAME, ActionMonitorBasePlugin, ActionMonitorPlugin, AjaxMonitorPlugin, AjaxMonitorVolPlugin, BLANK_SCREEN_MONITOR_PLUGIN_NAME, BREADCRUMB_MONITOR_PLUGIN_NAME, BlankScreenMonitorPlugin, BlankScreenMonitorVolPlugin, BreadcrumbMonitorPlugin, CustomPlugin, FETCH_MONITOR_PLUGIN_NAME, FMPMonitorPlugin, FMP_MONITOR_PLUGIN_NAME, FetchMonitorPlugin, FetchMonitorVolPlugin, HEATMAP_MONITOR_PLUGIN_NAME, InjectNetworkTypePlugin, JS_ERROR_EV_TYPE$1 as JS_ERROR_EV_TYPE, JS_ERROR_MONITOR_PLUGIN_NAME, JsErrorMonitorPlugin, PAGEVIEW_MONITOR_PLUGIN_NAME, PERFORMANCE_MONITOR_PLUGIN_NAME, PageviewMonitorPlugin, PerformanceMonitorPlugin, RESOURCE_ERROR_MONITOR_PLUGIN_NAME, RESOURCE_MONITOR_PLUGIN_NAME, ResourceErrorMonitorPlugin, ResourceMonitorPlugin, SPALoadMonitorPlugin, SamplePlugin, TTIMonitorPlugin, TTI_MONITOR_PLUGIN_NAME, UNKNOWN_PATH, applyAnimationFrame, applyDomAndKeyPress, applyMonitor, applyMutationObserver, applyPerformance, applyPerformanceObserver$1 as applyPerformanceObserver, applyRequestIdleCallback, applyUpdate, captureCurrentContext, createBatchSender, createBrowserSender, defaultPerformancePrecollect, domBreadcrumb, getBeaconTransport, getConfig, getCookieId, getCurrentScript, getDefaultBrowser, getDefaultCaf, getDefaultDocument, getDefaultFetch, getDefaultHistory, getDefaultLocation, getDefaultMutationObserver, getDefaultNavigator, getDefaultNetworkInformation, getDefaultPerformance, getDefaultPerformanceObserver, getDefaultPerformanceTiming, getDefaultPromise, getDefaultRaf, getDefaultXMLHttpRequest, getFullUrl, getGlobalRegistry, getLocationUrl, getNetworkType, getPluginConfig, getSampler, getStorageItem, getValueFromCookieName, getXhrTransport, htmlTreeAsString, invokeCallbackOnce, loadScript, normalizeCustomEventData, normalizeCustomLogData, normalizeUnknownError, now, onDOMContentLoaded, onPageLoad, onPageUnload, onceHidden, parseUrl, removeStorageItem, reportOnInitCommonParams, reportSelfError, setCookie, setStorageItem, syncReportWithCapturedContext, triggerHandlers };
//# sourceMappingURL=index.esm.js.map
