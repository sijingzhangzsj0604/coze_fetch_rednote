import { SafeObservable } from '@slardar/sdk-template';
import { PVNext } from '../../collector/client';
import { XHRNext, FetchNext } from '../../collector/http';
import { LongtaskNext, ResourceNext } from '../../collector/pref';
import { WebReportEvent } from '../../types';
import { PerformanceLongtask } from '../../types/thrift/browser/collector_v2/performance_longtask';
export interface ResourceAndRequestItem {
    start: number;
    end: number;
}
export interface NEWPerformanceLongTask extends PerformanceLongtask {
    start: number;
    end: number;
}
interface PerformancePrecollect {
    entries: PerformanceEntry[];
    observer?: PerformanceObserver;
}
declare type TTIPerfMetricGetterWithLoadContext = (report: (ev: WebReportEvent) => void, tearDownGroup: (() => void)[], context: [
    SafeObservable<XHRNext>,
    SafeObservable<FetchNext>,
    SafeObservable<LongtaskNext>,
    SafeObservable<ResourceNext>,
    SafeObservable<PVNext>
], config: PerformancePrecollect | undefined) => void;
/**
 * start 方法开启一个调度器，传入回调和调度时间
 * reschedule 重新以一个更长的时间调度
 * stop 停止调度
 */
export declare const applyScheduler: (now: typeof performance['now']) => readonly [(cb: () => void, futureTime: number) => void, () => void, (futureTime: number) => void];
/**
 * Computes the time (in milliseconds since requestStart) that the network was
 * last known to have >2 requests in-flight.
 */
export declare const calcLastNet2Busy: (undoneReqStarts: number[], observedResReqs: ResourceAndRequestItem[], now: typeof performance['now']) => number;
export declare const getRequestTimes: (requestTimes: Record<number, number>) => number[];
/**
 * 监听包含 ['img', 'script', 'iframe', 'link', 'audio', 'video', 'source'] 标签的 dom 变更
 */
export declare const observeResFetchMutations: (MutationObserver: false | {
    new (callback: MutationCallback): MutationObserver;
    prototype: MutationObserver;
} | null | undefined, callback: (mutation: MutationRecord) => void) => readonly [() => void, () => false | void | null | undefined];
/**
 * Returns either a manually set min value or the time since
 * domContentLoadedEventEnd and navigationStart. If the
 * domContentLoadedEventEnd data isn't available, `null` is returned.
 * @return {number|null}
 */
export declare const getMinValue: (timing?: PerformanceTiming | undefined) => number | null;
/**
 * Computes the TTI value...
 * @param {number} searchStart
 * @param {number} minValue
 * @param {number} lastKnownNetwork2Busy
 * @param {number} currentTime
 * @param {!Array<{start: (number), end: (number)}>} longTasks
 * @return {number|null}
 */
export declare const computeTTI: (searchStart: number, minValue: number, lastKnownNetwork2Busy: number, currentTime: number, longTasks: Array<{
    start: number;
    end: number;
}>) => number | null;
export declare const getLastBusyAndLongTasks: (tearDownGroup: (() => void)[], [xhrObserver, fetchObserver, longtaskObserver, resourceObserver, MutationObserver]: [SafeObservable<XHRNext>, SafeObservable<FetchNext>, SafeObservable<LongtaskNext>, SafeObservable<ResourceNext>, {
    new (callback: MutationCallback): MutationObserver;
    prototype: MutationObserver;
} | undefined], entries: PerformanceEntry[]) => (reschedule: (futureTime: number) => void, now: () => number) => [NEWPerformanceLongTask[], () => number];
export declare const getTTI: TTIPerfMetricGetterWithLoadContext;
export {};
