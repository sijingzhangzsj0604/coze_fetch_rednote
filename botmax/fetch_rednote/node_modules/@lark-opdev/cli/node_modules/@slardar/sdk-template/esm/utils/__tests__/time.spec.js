import { __awaiter, __generator } from "tslib";
import test from 'ava';
import sinon from 'sinon';
import { applyBufferTimer } from '../time';
test('applyBufferTimer', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var cb, cb2, bufferedCb, canCanceled, bufferedCb2;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                cb = sinon.spy();
                cb2 = sinon.spy();
                bufferedCb = applyBufferTimer(function () { return false; }, cb, 30);
                bufferedCb();
                t.assert(cb.notCalled);
                // eslint-disable-next-line compat/compat
                return [4 /*yield*/, new Promise(function (resolve) {
                        setTimeout(function () {
                            t.assert(cb.calledOnce);
                            resolve(true);
                        }, 40);
                    })];
            case 1:
                // eslint-disable-next-line compat/compat
                _a.sent();
                canCanceled = true;
                bufferedCb2 = applyBufferTimer(function () { return canCanceled; }, cb2, 30);
                bufferedCb2();
                t.assert(cb2.notCalled);
                bufferedCb2();
                t.assert(cb2.notCalled);
                canCanceled = false;
                bufferedCb2();
                t.assert(cb2.notCalled);
                // eslint-disable-next-line compat/compat
                return [4 /*yield*/, new Promise(function (resolve) {
                        setTimeout(function () {
                            t.assert(cb2.calledOnce);
                            resolve(true);
                        }, 40);
                    })];
            case 2:
                // eslint-disable-next-line compat/compat
                _a.sent();
                return [2 /*return*/];
        }
    });
}); });
test('applyBufferTimer -1', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var cb, cb2, bufferedCb;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                cb = sinon.spy();
                cb2 = sinon.spy();
                bufferedCb = applyBufferTimer(cb, cb2, -1);
                bufferedCb();
                t.assert(cb.notCalled);
                t.assert(cb2.notCalled);
                bufferedCb();
                // eslint-disable-next-line compat/compat
                return [4 /*yield*/, new Promise(function (resolve) {
                        setTimeout(function () {
                            t.assert(cb.notCalled);
                            t.assert(cb2.notCalled);
                            resolve(true);
                        }, 40);
                    })];
            case 1:
                // eslint-disable-next-line compat/compat
                _a.sent();
                return [2 /*return*/];
        }
    });
}); });
//# sourceMappingURL=time.spec.js.map