"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisposableMap = exports.RefCountedDisposable = exports.MutableDisposable = exports.DisposableCollection = exports.Disposable = exports.toDisposable = exports.combinedDisposable = exports.dispose = exports.isDisposable = exports.DisposableStore = void 0;
const event_1 = require("./event");
class DisposableStore {
    constructor() {
        this.toDispose = new Set();
        this._isDisposed = false;
    }
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        markTracked(this);
        this._isDisposed = true;
        this.clear();
    }
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    clear() {
        this.toDispose.forEach((item) => item.dispose());
        this.toDispose.clear();
    }
    add(t) {
        if (!t) {
            return t;
        }
        if (t === this) {
            throw new Error('Cannot register a disposable on itself!');
        }
        markTracked(t);
        if (this._isDisposed) {
            // eslint-disable-next-line no-console
            console.warn(new Error('Registering disposable on object that has already been disposed of').stack);
            t.dispose();
        }
        else {
            this.toDispose.add(t);
        }
        return t;
    }
}
exports.DisposableStore = DisposableStore;
function isDisposable(thing) {
    return typeof thing.dispose === 'function' && thing.dispose.length === 0;
}
exports.isDisposable = isDisposable;
function dispose(first, ...rest) {
    if (Array.isArray(first)) {
        first.forEach((d) => {
            if (d) {
                markTracked(d);
                d.dispose();
            }
        });
        return [];
    }
    else if (rest.length === 0) {
        if (first) {
            markTracked(first);
            first.dispose();
            return first;
        }
        return undefined;
    }
    else {
        dispose(first);
        dispose(rest);
        return [];
    }
}
exports.dispose = dispose;
function combinedDisposable(disposables) {
    disposables.forEach(markTracked);
    return trackDisposable({ dispose: () => dispose(disposables) });
}
exports.combinedDisposable = combinedDisposable;
function toDisposable(fn) {
    return {
        dispose() {
            fn();
        },
    };
}
exports.toDisposable = toDisposable;
class Disposable {
    constructor(...toDispose) {
        this.disposables = [];
        this.onDisposeEmitter = new event_1.Emitter();
        this.disposingElements = false;
        toDispose.forEach((d) => this.addDispose(d));
    }
    static create(func) {
        return {
            dispose: func,
        };
    }
    get onDispose() {
        return this.onDisposeEmitter.event;
    }
    checkDisposed() {
        if (this.disposed && !this.disposingElements) {
            this.onDisposeEmitter.fire(undefined);
        }
    }
    get disposed() {
        return this.disposables.length === 0;
    }
    dispose() {
        if (this.disposed || this.disposingElements) {
            return;
        }
        this.disposingElements = true;
        while (!this.disposed) {
            try {
                this.disposables.pop().dispose();
            }
            catch (e) {
                // eslint-disable-next-line no-console
                console.error(e);
            }
        }
        this.disposingElements = false;
        this.checkDisposed();
    }
    addDispose(disposable) {
        if (Array.isArray(disposable)) {
            const disposables = disposable;
            return disposables.map((disposable) => this.addDispose(disposable));
        }
        else {
            return this.add(disposable);
        }
    }
    registerDispose(disposable) {
        if (disposable === this) {
            throw new Error('Cannot register a disposable on itself!');
        }
        this.add(disposable);
        return disposable;
    }
    add(disposable) {
        const disposables = this.disposables;
        disposables.push(disposable);
        const originalDispose = disposable.dispose.bind(disposable);
        const toRemove = Disposable.create(() => {
            const index = disposables.indexOf(disposable);
            if (index !== -1) {
                disposables.splice(index, 1);
            }
            this.checkDisposed();
        });
        disposable.dispose = () => {
            toRemove.dispose();
            originalDispose();
        };
        return toRemove;
    }
}
exports.Disposable = Disposable;
Disposable.NULL = Disposable.create(() => { });
Disposable.None = Object.freeze({ dispose() { } });
class DisposableCollection {
    constructor(...toDispose) {
        this.disposables = [];
        this.onDisposeEmitter = new event_1.Emitter();
        this.disposingElements = false;
        toDispose.forEach((d) => this.push(d));
    }
    get onDispose() {
        return this.onDisposeEmitter.event;
    }
    checkDisposed() {
        if (this.disposed && !this.disposingElements) {
            this.onDisposeEmitter.fire(undefined);
        }
    }
    get disposed() {
        return this.disposables.length === 0;
    }
    dispose() {
        if (this.disposed || this.disposingElements) {
            return;
        }
        const toPromise = [];
        this.disposingElements = true;
        while (!this.disposed) {
            try {
                const maybePromise = this.disposables.pop().dispose();
                if (maybePromise) {
                    toPromise.push(maybePromise);
                }
            }
            catch (e) {
                // eslint-disable-next-line no-console
                console.error('DisposableCollection.dispose error', e);
            }
        }
        this.disposingElements = false;
        this.checkDisposed();
        return Promise.all(toPromise);
    }
    push(disposable) {
        const disposables = this.disposables;
        disposables.push(disposable);
        const originalDispose = disposable.dispose.bind(disposable);
        const toRemove = Disposable.create(() => {
            const index = disposables.indexOf(disposable);
            if (index !== -1) {
                disposables.splice(index, 1);
            }
            this.checkDisposed();
        });
        disposable.dispose = () => {
            toRemove.dispose();
            originalDispose();
        };
        return toRemove;
    }
    pushAll(disposables) {
        return disposables.map((disposable) => this.push(disposable));
    }
}
exports.DisposableCollection = DisposableCollection;
/**
 * Enables logging of potentially leaked disposables.
 *
 * A disposable is considered leaked if it is not disposed or not registered as the child of
 * another disposable. This tracking is very simple an only works for classes that either
 * extend Disposable or use a DisposableStore. This means there are a lot of false positives.
 */
const TRACK_DISPOSABLES = false;
const __is_disposable_tracked__ = '__is_disposable_tracked__';
function markTracked(x) {
    if (!TRACK_DISPOSABLES) {
        return;
    }
    if (x && x !== Disposable.None) {
        try {
            x[__is_disposable_tracked__] = true;
        }
        catch (_e) {
            // noop
        }
    }
}
function trackDisposable(x) {
    if (!TRACK_DISPOSABLES) {
        return x;
    }
    const stack = new Error('Potentially leaked disposable').stack;
    setTimeout(() => {
        if (!x[__is_disposable_tracked__]) {
            // eslint-disable-next-line no-console
            console.log(stack);
        }
    }, 3000);
    return x;
}
/**
 * Manages the lifecycle of a disposable value that may be changed.
 *
 * This ensures that when the the disposable value is changed, the previously held disposable is disposed of. You can
 * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.
 */
class MutableDisposable {
    constructor() {
        this._isDisposed = false;
        trackDisposable(this);
    }
    get value() {
        return this._isDisposed ? undefined : this._value;
    }
    set value(value) {
        if (this._isDisposed || value === this._value) {
            return;
        }
        if (this._value) {
            this._value.dispose();
        }
        if (value) {
            markTracked(value);
        }
        this._value = value;
    }
    clear() {
        this.value = undefined;
    }
    dispose() {
        this._isDisposed = true;
        markTracked(this);
        if (this._value) {
            this._value.dispose();
        }
        this._value = undefined;
    }
}
exports.MutableDisposable = MutableDisposable;
class RefCountedDisposable {
    constructor(_disposable) {
        this._disposable = _disposable;
        this._counter = 1;
    }
    acquire() {
        this._counter++;
        return this;
    }
    release() {
        if (--this._counter === 0) {
            this._disposable.dispose();
        }
        return this;
    }
}
exports.RefCountedDisposable = RefCountedDisposable;
class DisposableMap extends Map {
    disposeKey(key) {
        const disposable = this.get(key);
        if (disposable) {
            disposable.dispose();
        }
        this.delete(key);
    }
    dispose() {
        for (const disposable of this.values()) {
            disposable.dispose();
        }
        this.clear();
    }
}
exports.DisposableMap = DisposableMap;
//# sourceMappingURL=disposable.js.map