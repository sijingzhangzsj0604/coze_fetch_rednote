import { __assign, __awaiter, __generator } from "tslib";
import { createQueue } from './utils';
var DEFAULT_CAPACITY = 10;
/**
 *
 *[pause state]-<startAction>->[running state]-<stopAction>->[stop state]
 *       | 个------<pauseAction>--------| 个-----<startAction>----| 个
 *       |                                                          |
 *       -----------------------------<stopAction>------------------
 */
export function createSampleController(initConfigList) {
    var _configs = initConfigList.reduce(function (res, cur) {
        if (res[cur.name]) {
            throw Error("name " + cur.name + " is exist");
        }
        res[cur.name] = __assign(__assign({}, cur), { _state: 'stop' });
        return res;
    }, {});
    function _valid(name) {
        if (!_configs[name]) {
            throw Error("Sample " + name + " does not exist");
        }
    }
    function _report(name, data) {
        var _a = _configs[name], reportCb = _a.reportCb, sampleRate = _a.sampleRate;
        if (Math.random() <= sampleRate) {
            reportCb(data);
        }
    }
    function _invokeCollectCb(name) {
        return __awaiter(this, void 0, void 0, function () {
            function handleData(data) {
                if (_state === 'pause') {
                    _queue === null || _queue === void 0 ? void 0 : _queue.enqueue(data);
                }
                else {
                    _report(name, data);
                }
            }
            var _a, collectCb, async, _state, _queue, res, data;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = _configs[name], collectCb = _a.collectCb, async = _a.async, _state = _a._state, _queue = _a._queue;
                        res = collectCb();
                        if (!(res instanceof Promise)) return [3 /*break*/, 4];
                        if (!(async === null || async === void 0 ? void 0 : async.isWaitTillReturn)) return [3 /*break*/, 2];
                        return [4 /*yield*/, res];
                    case 1:
                        data = _b.sent();
                        handleData(data);
                        return [3 /*break*/, 3];
                    case 2:
                        void res.then(function (data) { return handleData(data); });
                        _b.label = 3;
                    case 3: return [3 /*break*/, 5];
                    case 4:
                        handleData(res);
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    }
    function _mockInterval(name, isImmediately) {
        return __awaiter(this, void 0, void 0, function () {
            function _timeoutCb() {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, _invokeCollectCb(name)];
                            case 1:
                                _a.sent();
                                void _mockInterval(name, false);
                                return [2 /*return*/];
                        }
                    });
                });
            }
            var collectInterval;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        collectInterval = _configs[name].collectInterval;
                        if (!isImmediately) return [3 /*break*/, 2];
                        return [4 /*yield*/, _invokeCollectCb(name)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        _configs[name]._tid = setTimeout(function () {
                            void _timeoutCb();
                        }, collectInterval);
                        return [2 /*return*/];
                }
            });
        });
    }
    function _transSucCb(name, lastState, nextState) {
        var _a, _b;
        _configs[name]._state = nextState;
        (_b = (_a = _configs[name]).transSucCb) === null || _b === void 0 ? void 0 : _b.call(_a, lastState, nextState);
    }
    function stopAction(name, options) {
        var _a;
        if (options === void 0) { options = {
            isReportAll: true,
        }; }
        _valid(name);
        var _b = _configs[name], _tid = _b._tid, _state = _b._state, _queue = _b._queue;
        var nextState = 'stop';
        var isTransSuc = false;
        if (_state === 'running') {
            isTransSuc = true;
        }
        else if (_state === 'pause') {
            if (options.isReportAll) {
                while (_queue === null || _queue === void 0 ? void 0 : _queue.getSize()) {
                    _report(name, _queue.dequeue());
                }
            }
            (_a = _configs[name]._queue) === null || _a === void 0 ? void 0 : _a.clear();
            isTransSuc = true;
        }
        if (isTransSuc) {
            clearTimeout(_tid);
            _transSucCb(name, _state, nextState);
        }
        return isTransSuc;
    }
    function startAction(name, options) {
        if (options === void 0) { options = { isImmediately: false }; }
        _valid(name);
        var _a = _configs[name], _state = _a._state, _queue = _a._queue;
        var nextState = 'running';
        var isTransSuc = false;
        if (_state === 'stop') {
            void _mockInterval(name, options.isImmediately);
            isTransSuc = true;
        }
        else if (_state === 'pause') {
            while (_queue === null || _queue === void 0 ? void 0 : _queue.getSize()) {
                _report(name, _queue.dequeue());
            }
            isTransSuc = true;
        }
        if (isTransSuc) {
            _transSucCb(name, _state, nextState);
        }
        return isTransSuc;
    }
    function pauseAction(name, options) {
        if (options === void 0) { options = { capacity: DEFAULT_CAPACITY }; }
        _valid(name);
        var _state = _configs[name]._state;
        var nextState = 'pause';
        var isTransSuc = false;
        if (_state === 'running') {
            isTransSuc = true;
            _configs[name]._queue = createQueue(options.capacity);
        }
        if (isTransSuc) {
            _transSucCb(name, _state, nextState);
        }
        return isTransSuc;
    }
    function update(name, updateConfig, options) {
        if (options === void 0) { options = {
            isReStartImmediately: false,
        }; }
        _valid(name);
        _configs[name] = __assign(__assign({}, _configs[name]), updateConfig);
        if (options.isReStartImmediately) {
            stopAction(name, options.stopOptions);
            startAction(name, options.startOptions);
        }
    }
    function getState(name) {
        return _configs[name]._state;
    }
    function getQueueSize(name) {
        var _a, _b;
        return (_b = (_a = _configs[name]._queue) === null || _a === void 0 ? void 0 : _a.getSize()) !== null && _b !== void 0 ? _b : 0;
    }
    return {
        startAction: startAction,
        stopAction: stopAction,
        pauseAction: pauseAction,
        update: update,
        getState: getState,
        getQueueSize: getQueueSize,
    };
}
//# sourceMappingURL=sampleController.js.map